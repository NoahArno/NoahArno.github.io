# 什么是BigKey和HotKey？

> 本文是对阿里开发者公众号发布的相关文章的小总结。将会从定义、产生原因、如何发现、带来的问题、如何解决这五方面去进行总结。

## 1. BigKey和HotKey的定义

对于这两者的定义，似乎并没有一个固定的标准，基本上每个资料的定义都不一样，然而，这些判定标准都有共同点：

- 对于 BigKey 来说，通常以数据大小和成员数量作为评判标准；比如String类型的key的大小超过了一定大小、List类型的key的列表数量超过了一定数量。
- 对于HotKey来说，通常以请求频率和数量来进行评判。当某个key的访问频率远超于其他的key的时候，就可以认为该key是HotKey。比如某个Redis实例的每秒访问量为一万，其中key-a的访问量就达到了七千，很显然该key就是一个hotkey。或者也可以从带宽占用率和CPU使用率的角度去进行考量。

同时需要注意的就是，对于两者的相关定义，还是需要根据Redis的实际使用场景和业务场景进行评判。

## 2. 产生原因

一般而言，是由于初期的设计不规范、Redis的不正确使用等造成的：

- 将Redis用在并不适合其能力的场景。
- 规划和设计不足，导致没有对Key的成员进行合理的拆分。
- 没有对无效的数据进行定期清理，比如使用List作为消息队列的时候，消息消费后没有及时清理或者消费端出现故障等等。
- 意料之外的事件导致请求增多。

## 3. 带来的问题

### 3.1 BigKey带来的问题

- 从客户端，也就是使用者的角度来看，BigKey的存在会导致使用者使用Redis的时候，明显的感觉到Redis变慢，一个是因为BigKey在网络传输的时候所占用的带宽比较高，进而引起服务器上的其余的服务，或者Redis本身。一个是因为对BigKey的操作，无论是删除还是修改，都容易造成Redis主线程阻塞。
- 从持久化的角度考虑：在AOF日志重写和RDB过程中，会存在父进程和子进程之间的写时复制，若修改了一个BigKey，就会造化内存的复制，这也是为什么Redis在AOF重写或RDB过程中，对于哈希表的负载因子为1的时候也不会去进行rehash的重要原因。
- 从集群角度来看，也就是Redis Cluster，BigKey会导致内存分布不均匀，因为数据迁移的最小粒度是key。

### 3.2 HotKey带来的问题

- 从集群角度来看，请求分布不均，可能导致某个Redis实例的压力过大，而其余的实例较为空闲。同时某个Redis实例可能由于压力过大而导致崩溃，进而造成缓存击穿，从而影响到MySQL或其它的一些下流组件，进而造成系统的全面崩溃。
- 同时，如果一个Key的请求过多，占用了大部分的带宽或CPU，则会影响其余的请求。

## 4. 如何发现

**BigKey**

- 使用Redis客户端的 --bigkeys命令去查看，但是只会返回每种类型中最大的那个bigkey，同时对于集合类型来说，只会根据集合中的元素个数进行比较，而不是实际的大小。
- 使用SCAN 对数据库扫描，然后使用 TYPE 分析该 key 的类型，对于 String 类型，使用 STRLEN 去查看字符串的长度；对于集合类型，使用 MEMORY USAGE 命令去查看一个键值对占用的内存空间。

**HotKey**

- 将 Redis 的内存淘汰策略设置为 LFU，然后使用 Redis 客户端的 hotkeys 命令进行发现，也就是返回所有 key 的被访问次数。
- 在业务层进行定位，但是会导致业务层的代码更为复杂，也会降低一定的性能。
- 使用开源的工具。

## 5. 如何处理

对于 BigKey 来说，可以将其进行合理的拆分；在删除方面，可以使用 Redis 4.0 提供的异步删除的方式，或者每次删除一点点。也可以去使用监控系统监控 Redis 的内存使用率或增长率等等。

对于 HotKey 来说，可以将 HotKey 进行复制并迁移到其他的节点中，但是对于数据一致性来说有需要进行额外的处理措施；如果是读多写少的数据，可以进行读写分离。

## 参考资料

[一文详解Redis中BigKey、HotKey的发现与处理 (qq.com)](https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q)

[Redis 常见面试题--redis的大key如何处理 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/base/redis_interview.html#redis-的大-key-如何处理)