## 如何解决大文件上传问题

可以将大文件进行分片，前端将所有文件分片， 然后传给后端之后，然后上传到服务器上。

比如我们一开始选择一个文件，然后生成一个文件的唯一标识，然后检查服务器中该文件有没有上传过，如果上传过，并且该文件所有的分片都上传完毕了，就可以直接秒传。

如果该文件没有上传过，就将其进行分片上传，然后在服务器中将这些分片进行合并，此次文件上传结束。

如果该文件上传过，但是只是上传了部分分片，就可以将该文件的剩余的分片进行上传。

## 如何设计秒杀系统

其实秒杀的逻辑比较简单，就是生成订单，然后减库存，还有一些其余的操作，但是秒杀的难点就在于会有一瞬间的超高流量，也就是高并发，可能会导致很多问题。

也就是说，设计一个秒杀系统需要保证：**高并发、高性能、高可用、一致性**。

- 首先对于热点数据，我们可以使用**redis进行一个缓存**，同时也最好在JVM中写入一份实例，并设置过期时间。因为存放在JVM中的数据访问速度肯定是比存在Redis中的数据效率要高的。但是还得注意如何保障Redis、MySQL、JVM中数据的一致性。
- 同时也可以使用**验证码**的方式来进行一个流量削峰。因为每个人输入验证码的速度是不一样的。
- 使用**RabbitMQ**来进行一个流量削峰。
- 搭建Redis集群，增强它的高可用。
- 可以使用Sentinal，提供流量控制、熔断降级、系统自适应保护等功能来保护系统的稳定性和可用性。 
- 进行一个库存预热，将秒杀的商品的数量放在Redis或JVM中，每秒杀一个商品就会减少一个库存。每一个秒杀请求都先去查看redis或JVM中还有没有库存，这样可以拦截很多请求，减少MySQL的压力。
- 使用MQ进行异步处理。比如我们秒杀成功的时候可以生成消息发送到MQ中，然后将消息发送给订单服务、支付服务、库存服务、短信服务等等。

除了上述的性能优化，还得考虑系统的一致性，千万不能够出现超卖等现象。

可以在sql语句扣减库存的时候查询一下库存是否足够。而在redis扣减库存的时候，需要使用lua脚本保证原子性。

## 如何设计一个排行榜

可能第一眼看到这个系统设计，就想到了使用MySQL，然后配合ORDER BY关键字。对于用户数据量不大，并且排序需求不负责的项目倒是可以采用这种方法。好处就是实现简单，不用额外引入新的组件，成本较低。但是每次生成排行榜都比较消耗性能，无法适用于大数据量场景。

因此就可以使用Redis中的sorted set数据结构来实现排行榜功能。

## 如何统计网站的访问量

为每个页面都维护一个哈希表，网页ID + 日期作为key，value为这一天看过该网页的所有用户ID（set类型的数据结构）。每次访问页面的时候，都得去看看该用户当天是否已经访问过了该页面。在统计指定页面访问量的时候，可以求出set的大小就可以了。

但是这样消耗比较大，如果某网站一天之内的访问量非常大，比如一百万个不同的用户进行访问，就可能造成一个网页就得维护一个一百万的用户ID，还得不断判断指定用户当天是否访问过某页面。而且一个网站还不止一个页面。

因此就可以使用**HyperLogLog**（暂留）

## APP里未读消息已读、未读怎么设计？

就拿微信或者钉钉中的群消息来说，发送者刚发出消息的时候群里其他群成员都是未读状态，陆陆续续有人看到了这个群消息，这时的消息变成x人已读，y人未读。每条消息对应一个唯一的messageId，每一个用户对应一个唯一的userId，应该如何保存这个消息对应的已读、未读状态呢？

简单粗暴的方法：

对于每一个messageId，存当前的readIds + unreadIds，当群成员A已读该消息的时候，就将A的userId从unreadIds中移除，然后写入到readIds中就可以了。

但是这肯定无法在面试的时候去说。

于是此时就可以使用bitmap去存，因为消息的已读和未读其实就是0/1的状态。



