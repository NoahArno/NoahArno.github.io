<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Disruptor：高性能无锁队列</title>
    <link href="/Disruptor/Disruptor%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    <url>/Disruptor/Disruptor%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Disruptor：高性能无锁队列"><a href="#Disruptor：高性能无锁队列" class="headerlink" title="Disruptor：高性能无锁队列"></a>Disruptor：高性能无锁队列</h1><p>从数据结构上来看，Disruptor 是一个支持生产者消费者模型的高性能无锁队列，它内部利用 RingBuffer 环形数组存储数据，能够让消费者按照它们之间的依赖关系对 event 进行消费。不过现在 Disruptor 的官方更新已经不那么频繁了。一个是因为它的性能已经足够优秀而导致难以变化；二来是它的作用范围只支持单机，在如今分布式的时代已经逐渐用处不大了。然而，它内部的一些实现还是值得我们去借鉴。</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>在依赖上，引入 Disruptor 相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.lmax/disruptor --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>Disruptor</code> 的核心是 RingBuffer，甚至来说，我们完全可以不使用 Disruptor 而直接使用 RingBuffer 就能完成所有的操作。不过官方给 RingBuffer 包装了一层 Disruptor，在使用方面还是较之前简便不少。</p><p>一般而言，使用 Disruptor 需要如下步骤：</p><ol><li>创建 Disruptor 实例对象：指定 RingBuffer 的大小、事件工厂、线程池、生产者策略和等待策略。</li><li>根据消费需求，使用 <code>handlerEventsWith</code> 或 <code>handleEventsWithWorkerPool</code> 增加消费者。</li><li>调用 <code>Disruptor#start</code> 方法启动 Disruptor。</li><li>在启动之后，就可以往 Disruptor 生产数据了。在生产中，一定得根据创建 Disruptor 时指定的生产者策略进行，不能指定单生产者模式下启动多个生产者并行生产。</li></ol><p>示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    Disruptor&lt;Trade&gt; disruptor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Disruptor</span>&lt;Trade&gt;(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventFactory</span>&lt;Trade&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Trade <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trade</span>();<br>            &#125;<br>        &#125;,<br>        <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>,<br>        Executors.defaultThreadFactory(),<br>        ProducerType.SINGLE,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusySpinWaitStrategy</span>());<br><br>    <span class="hljs-comment">// 并行操作</span><br>    disruptor.handleEventsWith(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler1</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler2</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler3</span>());<br><br>    <span class="hljs-comment">// 多消费者竞争，对于 eventHandler 而言需要实现 WorkHandler 接口</span><br>    disruptor.handleEventsWithWorkerPool(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler1</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler2</span>());<br><br>    <span class="hljs-comment">// 启动disruptor</span><br>    RingBuffer&lt;Trade&gt; ringBuffer = disruptor.start();<br>    <span class="hljs-comment">// 生产 event</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> ringBuffer.next();<span class="hljs-comment">//0</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Trade</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> ringBuffer.get(sequence);<br>        <span class="hljs-comment">//3 进行实际的赋值处理</span><br>        event.setValue(data.getLong(<span class="hljs-number">0</span>));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//4 提交发布操作</span><br>        ringBuffer.publish(sequence);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Disruptor 而言，使用限制其实比较低，对于生产者和消费者的配合较为灵活，得益于它内部设计的 EventHandlerGroup 和 SequencerBarrier 机制。</p><h2 id="2-Disruptor的实现优点"><a href="#2-Disruptor的实现优点" class="headerlink" title="2. Disruptor的实现优点"></a>2. Disruptor的实现优点</h2><p>Disruptor 的性能优越，它在多个方面进行了细致的优化：</p><ul><li><p>不使用锁，而是使用的 CAS，并且对于单生产者而言用 long 来保存序号，而多生产者用的是 AtomicLong，因为单生产者不涉及到竞争。不过这里的 AtomicLong 其实是类 AtomicLong，原因是 Sequence 类其实也是用的 Unsafe 保证原子更新。</p><blockquote><p>由于 Java8 中新增了 LongAdder 类，它在多线程竞争下的性能比 AtomicLong 还要高，我们似乎可以用其对 Sequence 进行优化。</p></blockquote></li><li><p>使用 RingBuffer 设计。对于传统的队列而言，需要维护 tail、head、size 等变量，入队的时候需要对 tail 进行竞争，出队的时候要对 head 进行竞争，同时还得维护 size 来确认队列的 empty or full。而 RingBuffer 只维护序号来保存下一个可用空间，减小竞争。</p></li><li><p>使用额外的变量，以空间换时间的策略来解决伪共享问题。对于 RingBuffer 存放真正数据的数组也进行了缓存行优化。</p></li><li><p>RingBuffer 在初始化的时候就对环中的数据进行了预填充，详情见 RingBuffer#fill，解决频繁创建和回收对象的垃圾回收问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内存预加载机制的实现，也就是在创建的时候，就将环中的数据填充为空对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(EventFactory&lt;E&gt; eventFactory)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bufferSize; i++) &#123;   <span class="hljs-comment">// 由于数组左边遭受到填充，因此在设置元素的时候，需要跳过</span><br>        entries[BUFFER_PAD + i] = eventFactory.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-缓存行优化最佳实战"><a href="#3-缓存行优化最佳实战" class="headerlink" title="3. 缓存行优化最佳实战"></a>3. 缓存行优化最佳实战</h2><p>在读取数据的时候，CPU 会将内存中的一块连续的数据读取到 CPU 缓存中，该连续的数据被称为缓存块，也就是 CPU Cache Line，一般是 64 字节大小。不过假如存在两个 CPU 核心，并且存在变量 A 和变量 B 位于同一缓存块中。当 CPU1 想要读取 A 的时候，会将 AB 一起读取到它的缓存当中，同时 CPU2 想要读取 B，也会进行相同的操作。这时候 CPU1 和 CPU2 各自的缓存行处于共享状态。</p><p>此时 CPU1 想要更新 A，就必须通过总线将 CPU2 对应的缓存行标记为失效。而 CPU2 想要更新 B，发现缓存行被标记为失效了，就得重新从内存中读取，并且更新之前还得将 CPU1 的缓存行给标记失效。</p><p>如果两个 CPU 核心反复执行更新操作，就会造成缓存失效，也就是伪共享问题。</p><h3 id="3-1-对于普通变量的伪共享解决方案"><a href="#3-1-对于普通变量的伪共享解决方案" class="headerlink" title="3.1 对于普通变量的伪共享解决方案"></a>3.1 对于普通变量的伪共享解决方案</h3><p>在 Sequence 类当中，对于变量 value 而言，由于需要频繁更新，消除伪共享就显得额外重要。并且 value 属性是 long 类型，它占 8字节，而一个缓存行一般都是 64 字节大小，因此就需要在 value 的左右两边分别填充 56 字节，也就是分别填充7 个 long 类型变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LhsPadding</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LhsPadding</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RhsPadding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Value</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p9, p10, p11, p12, p13, p14, p15;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在 Disruptor 当中，并没有写一个从来都不会被调用的方法去使用这些额外填充的无用变量。我们不清楚编译器会不会将这些填充变量给优化掉，因此在自己的实现中，还是添加这么一个方法比较保险。</p><p>同时 JDK1.8 中提供了 <code>@sun.misc.Contended</code> 注解用于将变量自动独占缓存行，不过需要添加 <code>-XX: -RestrictContended</code> 参数才能够生效。</p><h3 id="3-2-针对数组的伪共享解决方案"><a href="#3-2-针对数组的伪共享解决方案" class="headerlink" title="3.2 针对数组的伪共享解决方案"></a>3.2 针对数组的伪共享解决方案</h3><p>对于变量而言，它的伪共享解决方案其实较为简单，因为变量的内存占用大小一般都是固定的。不过针对于数组而言，它的内存占用并不确定，因此无法极限利用空间，而是可以选择在数组的两侧额外填充 64 字节或者 128 字节。</p><p>在 Disruptor 中，对它的处理倒是显得较为复杂，在 <code>RingBuffer.class</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RingBufferFields</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RingBufferPad</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> BUFFER_PAD;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> REF_ARRAY_BASE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> REF_ELEMENT_SHIFT;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">UNSAFE</span> <span class="hljs-operator">=</span> Util.getUnsafe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 Unsafe 的 arrayBaseOffset 和 arrayIndexScale</span><br><span class="hljs-comment">     * 分别获取数组首元素的偏移地址 和 单个元素大小因子</span><br><span class="hljs-comment">     * 后续的相关操作，就可以用这个来确定</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 在 JVM 知识当中，对象是真正被分配到堆中，然后用指针引用，这里使用 Object数组来判断对象的大小，</span><br>        <span class="hljs-comment">// 其实说的是数组中指针的大小，就是 4 字节，所以不必纠结这里用的是 Object 而实际的 entries 可以是 Object 的子类</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> UNSAFE.arrayIndexScale(Object[].class); <span class="hljs-comment">// 4</span><br>        <span class="hljs-comment">// 如果开启指针压缩，指针就是 4 字节，没压缩就是 8 字节</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">4</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">8</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unknown pointer size&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将数组的前后都填充 128 字节，不过不知道为啥不填充 64 字节</span><br>        BUFFER_PAD = <span class="hljs-number">128</span> / scale; <span class="hljs-comment">// 32</span><br>        <span class="hljs-comment">// Including the buffer pad in the array base offset</span><br>        <span class="hljs-comment">// 由于我们在数组的前面填充了 128 字节，因此数组的有效元素偏移量就需要往后推</span><br>        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD &lt;&lt; REF_ELEMENT_SHIFT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建和填充 entires 数组的时候，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[sequencer.getBufferSize() + <span class="hljs-number">2</span> * BUFFER_PAD];<br>entries[BUFFER_PAD + i] = eventFactory.newInstance();<br></code></pre></td></tr></table></figure><p>使用 <code>elementAt</code> 方法获取元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E <span class="hljs-title function_">elementAt</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence)</span> &#123; <br>    <span class="hljs-comment">// 位运算，这就需要 entries 的长度大小为 2 的幂次方，</span><br>    <span class="hljs-comment">// sequence &amp; indexMask：将 sequence 进行截断</span><br>    <span class="hljs-keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，它的使用还是较为复杂的，并且还使用了 UnSafe 类。并且它采用数组真实起始地址和元素偏移量的方式获取元素的设计。如果直接使用数组下标倒是会显得更加麻烦，因为数组是存在两侧的填充的，很难通过下标真实的确定位置。</p><h2 id="4-生产者原理"><a href="#4-生产者原理" class="headerlink" title="4. 生产者原理"></a>4. 生产者原理</h2><p>Disruptor 支持单生产者和多生产者模式，并且使用 Sequencer 管理 Sequence。并且它们都使用了二阶段提交机制。</p><p>对于单生产者而言，也就是 SingleProducerSequencer，使用 long 类型的 nextValue 表示占位，因为它并不涉及到竞争。同时对于表示真正的生产进度的 Sequencer 类型的 cursor 来说，也就是真实填充了数据的指针，当数据在 nextValue 指定的位置填充好之后，就会更新 cursor 的值。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">// 1. 一开始的状态<br>1   <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span>  6<br>     ^<br>nextValue、cursor<br><br>// 2. next 方法去申请1个位置<br>1   <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span>  6<br>     ^          ^<br>   cursor    nextValue<br><br>// 3. 调用 publish 发布之后<br>1   <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span>  6<br>         ^<br>  nextValue、cursor<br></code></pre></td></tr></table></figure><p>对于多生产者而言，也就是 MultiProducerSequencer，为了防止多个线程重复写同一个元素，Disruptor 为每个线程使用 CAS 获取不同的一段数组空间进行操作，只需要在分配元素的时候通过 CAS 判断一下这段空间是否已经被分配出去即可。然而为了防止读取的时候读取到还未写入的元素，就需要一个简单的二阶段提交：它使用了 availableBuffer 辅助数组，当某个位置写成功的时候就会将 availableBuffer 相应的位置标记为写入成功。消费者想要读取元素的时候就会遍历 availableBuffer 来判断元素是否已经就绪。</p><p>availableBuffer 中的值默认为 -1。在设置 availableBuffer 的时候，也就是调用 publish 发布的时候，就需要计算出当前 sequence 是处于哪一轮的，从而设置对应的标志位。这样是因为数组是循环使用的，使用固定特殊值作为标记的方法不可取。</p><p>多生产者模式下大致步骤如下：</p><ol><li><p>当前生产者先看 RingBuffer 中空间是否充足，如果空间不够不停循环判断。</p><blockquote><p>这里的判断会查看消费者的进度，获取消费进度最小的那个消费者的序号。看当前生产进度是否超过。</p></blockquote></li><li><p>如果空间足够就使用 CAS 操作获取指定的空间。</p><blockquote><p>这里注意的是，多生产者模式下的 cursor 变量也会用作占位：<code>cursor.compareAndSet(current, next)</code></p></blockquote></li><li><p>获取成功之后就可以开始往里面写入数据了，同时也会去更新 availableBuffer 中的标志位。</p></li></ol><h2 id="5-消费者原理"><a href="#5-消费者原理" class="headerlink" title="5. 消费者原理"></a>5. 消费者原理</h2><p>Disruptor 支持多个消费者对同一个消息进行并行获取有依赖关系的消费，也支持多个消息去竞争消息消费。</p><ul><li>消费者实现 EventHandler 接口，并且调用 <code>disruptor.handleEventsWith</code> 方法添加消费者，多个 handler 就会对同一个消息进行重复消费，也可以结合 then、after 等方法对数据进行多边形计算。<strong>场景上适用于链路计算，和 CompletableFuture 结合线程池的方法相类似</strong>。</li><li>消费者实现 WorkerHandler 接口，并且调用 <code>disruptor.handleEventsWithWorkerPool</code>，将多个 WorkerHandler 的实现类传入该方法，就可以看作有一个叫做 WorkerPool 的消费者，消息会被它内部的多个 workerHandler 给竞争消费，也就是消息无法被重复消费。<strong>场景上适用于传统的生产者消费者模型</strong>。</li></ul><p>前面也说了，消费者支持依赖关系，也就是消费者 A 需要等待消费者 B 消费完某个消息之后才能消费。在实现原理上面，其实是通过 SequenceBarrier 内部的 dependentSequence，比如 A 想要消费序号 N 中的消息，它就会去看 B 的消费进度是否超过了 N，如果没有超过就只能等待。</p><p>对于 WorkerHandler 模式下的消费者竞争安全性问题，通过 WorkerPool（WorkerPool 中包含了多个 WorkerHandler）中的 workSequence 属性来进行的，也就是多个 WorkerHandler 去通过 CAS 修改该变量，如果能修改成功表示自己获取到了消费该消息的资格，然后进一步消费，也可以理解为一个二阶段。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>在看完 Disruptor 的源码之后，对于一些细节上的优化有了进一步的了解。在听到 Disruptor 号称高性能无锁队列之后，一开始我还以为它能够在不使用锁和 CAS 的情况下也能保证线程安全性，不过后来就有点小失望——它内部还是需要 CAS 机制。</p><p>它在多生产者模式下的二阶段机制较为新颖，将抢占位置和填充数据给分离开来。不过似乎用处不是很大：按照正常的逻辑也是先 CAS 成功再填充数据，也是个二阶段。反倒是它的代码分离导致使用上还复杂了一点，因为需要调用 next 方法获取到可用序号之后，才从 RingBuffer 中获取到序号指定的元素再进行填充。甚至于 Disruptor 官方也提供了 EventTranslator 接口去帮助我们屏蔽掉这些细节，只关注于消息填充。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Disruptor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是BigKey和HotKey</title>
    <link href="/Redis/%E4%BB%80%E4%B9%88%E6%98%AFBigKey%E5%92%8CHotKey/"/>
    <url>/Redis/%E4%BB%80%E4%B9%88%E6%98%AFBigKey%E5%92%8CHotKey/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是BigKey和HotKey？"><a href="#什么是BigKey和HotKey？" class="headerlink" title="什么是BigKey和HotKey？"></a>什么是BigKey和HotKey？</h1><blockquote><p>本文是对阿里开发者公众号中发布的相关文章的小总结。将会从定义、产生原因、如何发现、带来的问题、如何解决这五方面去进行总结。</p></blockquote><h2 id="1-BigKey和HotKey的定义"><a href="#1-BigKey和HotKey的定义" class="headerlink" title="1. BigKey和HotKey的定义"></a>1. BigKey和HotKey的定义</h2><p>对于这两者的定义，似乎并没有一个固定的标准，基本上每个资料的定义都不一样，然而，这些判定标准都有共同点：</p><ul><li>对于 BigKey 来说，通常以数据大小和成员数量作为评判标准；比如String类型的key的大小超过了一定大小、List类型的key的列表数量超过了一定数量。</li><li>对于HotKey来说，通常以请求频率和数量来进行评判。当某个key的访问频率远超于其他的key的时候，就可以认为该key是HotKey。比如某个Redis实例的每秒访问量为一万，其中key-a的访问量就达到了七千，很显然该key就是一个hotkey。或者也可以从带宽占用率和CPU使用率的角度去进行考量。</li></ul><p>同时需要注意的就是，对于两者的相关定义，还是需要根据Redis的实际使用场景和业务场景进行评判。</p><h2 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="2. 产生原因"></a>2. 产生原因</h2><p>一般而言，是由于初期的设计不规范、Redis的不正确使用等造成的：</p><ul><li>将Redis用在并不适合其能力的场景。</li><li>规划和设计不足，导致没有对Key的成员进行合理的拆分。</li><li>没有对无效的数据进行定期清理，比如使用List作为消息队列的时候，消息消费后没有及时清理或者消费端出现故障等等。</li><li>意料之外的事件导致请求增多。</li></ul><h2 id="3-带来的问题"><a href="#3-带来的问题" class="headerlink" title="3. 带来的问题"></a>3. 带来的问题</h2><h3 id="3-1-BigKey带来的问题"><a href="#3-1-BigKey带来的问题" class="headerlink" title="3.1 BigKey带来的问题"></a>3.1 BigKey带来的问题</h3><ul><li>从客户端，也就是使用者的角度来看，BigKey的存在会导致使用者使用Redis的时候，明显的感觉到Redis变慢，一个是因为BigKey在网络传输的时候所占用的带宽比较高，进而引起服务器上的其余的服务，或者Redis本身。一个是因为对BigKey的操作，无论是删除还是修改，都容易造成Redis主线程阻塞。</li><li>从持久化的角度考虑：在AOF日志重写和RDB过程中，会存在父进程和子进程之间的写时复制，若修改了一个BigKey，就会造化内存的复制，这也是为什么Redis在AOF重写或RDB过程中，对于哈希表的负载因子为1的时候也不会去进行rehash的重要原因。</li><li>从集群角度来看，也就是Redis Cluster，BigKey会导致内存分布不均匀，因为数据迁移的最小粒度是key。</li></ul><h3 id="3-2-HotKey带来的问题"><a href="#3-2-HotKey带来的问题" class="headerlink" title="3.2 HotKey带来的问题"></a>3.2 HotKey带来的问题</h3><ul><li>从集群角度来看，请求分布不均，可能导致某个Redis实例的压力过大，而其余的实例较为空闲。同时某个Redis实例可能由于压力过大而导致崩溃，进而造成缓存击穿，从而影响到MySQL或其它的一些下流组件，进而造成系统的全面崩溃。</li><li>同时，如果一个Key的请求过多，占用了大部分的带宽或CPU，则会影响其余的请求。</li></ul><h2 id="4-如何发现"><a href="#4-如何发现" class="headerlink" title="4. 如何发现"></a>4. 如何发现</h2><p><strong>BigKey</strong></p><ul><li>使用Redis客户端的 –bigkeys命令去查看，但是只会返回每种类型中最大的那个bigkey，同时对于集合类型来说，只会根据集合中的元素个数进行比较，而不是实际的大小。</li><li>使用SCAN 对数据库扫描，然后使用 TYPE 分析该 key 的类型，对于 String 类型，使用 STRLEN 去查看字符串的长度；对于集合类型，使用 MEMORY USAGE 命令去查看一个键值对占用的内存空间。</li></ul><p><strong>HotKey</strong></p><ul><li>将 Redis 的内存淘汰策略设置为 LFU，然后使用 Redis 客户端的 hotkeys 命令进行发现，也就是返回所有 key 的被访问次数。</li><li>在业务层进行定位，但是会导致业务层的代码更为复杂，也会降低一定的性能。</li><li>使用开源的工具。</li></ul><h2 id="5-如何处理"><a href="#5-如何处理" class="headerlink" title="5. 如何处理"></a>5. 如何处理</h2><p>对于 BigKey 来说，可以将其进行合理的拆分；在删除方面，可以使用 Redis 4.0 提供的异步删除的方式，或者每次删除一点点。也可以去使用监控系统监控 Redis 的内存使用率或增长率等等。</p><p>对于 HotKey 来说，可以将 HotKey 进行复制并迁移到其他的节点中，但是对于数据一致性来说有需要进行额外的处理措施；如果是读多写少的数据，可以进行读写分离。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q">一文详解Redis中BigKey、HotKey的发现与处理 (qq.com)</a></p><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E7%9A%84%E5%A4%A7-key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">Redis 常见面试题–redis的大key如何处理 | 小林coding (xiaolincoding.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyLFU：A Highly Efficient Cache Admission Policy</title>
    <link href="/TinyLFU/TinyLFU/"/>
    <url>/TinyLFU/TinyLFU/</url>
    
    <content type="html"><![CDATA[<h2 id="1-LRU-和-LFU-的缺陷"><a href="#1-LRU-和-LFU-的缺陷" class="headerlink" title="1. LRU 和 LFU 的缺陷"></a>1. LRU 和 LFU 的缺陷</h2><p>作为我们常用的缓存淘汰策略，LRU 和 LFU 一直被大家所熟知，但是它们其实也存在一些缺陷。</p><p>以 LRU 为例，当一个数据被访问的时候，就会将该数据给移动到最前端，这就存在一个问题，那就是如果有那么一瞬间访问了很多的数据，而这些数据其实只会访问一次，这就导致链表中的那些热点数据被迫移动到链表尾部，从而存在被淘汰的风险。</p><p>因此就可以使用 LFU 来解决这个问题，它为每一个元素都保存了它的被访问次数，访问次数高的将不容易被淘汰，如果访问次数相同就可以按照 LRU 的规则，比较谁是最新访问的。</p><p>总结来说：</p><p>LRU 优点：实现简单，能满足大部分的需求；缺点：对热点数据的命中率不如 LFU</p><p>LFU 优点：对热点数据的命中率更高；缺点：① 难以应对突发的稀疏流量。② 可能存在旧数据长期不被淘汰。③ 由于需要记录被访问次数，造成空间浪费。</p><p>正是由于 LRU 和 LFU 存在或多或少的问题，因此就需要一种新的机制来代替它们。</p><h2 id="2-Window-TinyLFU"><a href="#2-Window-TinyLFU" class="headerlink" title="2. Window-TinyLFU"></a>2. Window-TinyLFU</h2><p>TinyLFU 采用了 Count-Min Sketch 算法来统计数据的访问频率。在该算法中，我们认为一个缓存被访问 15 次就已经算是很高的频率了，因此只需要 4bits 就可以记录一个数据的访问频率。同时，为了解决 cmSktch 算法中出现的假阳性问题，可以给同一个数据多次计算访问次数，然后在查找的时候，就找到这几个不同的位置，然后统计它们的最小值作为结果。</p><p>在实现方面，假设我们的 LFU 容量大小为 n，就可以初始化一个 4 行 n 列的二维数组。对于一个 key 而言，使用四种哈希函数，分别将其分布到二维数组的每一行中，然后找到对应的位置，将其数量进行自增。在查找的时候，同样使用四种哈希函数，然后找到该 key 在二维数组中的每一行的访问次数值，然后取四个值中的最小值。</p><p>同时为了解决第二点的问题，在使用过程中，可以维护一个总访问计数器，如果该计数器达到了访问上限，就可以将 cmSketch 中的二维数组中的值全部减半操作，这就解决了缓存保鲜的问题。</p><p>接下来为了解决第一个问题：难以应对突发的稀疏流量。Window-TinyLFU 的策略中，采用了两个 LRU。其中前端的小 LRU 叫做 Window LRU，它的容量只占用百分之一，它的目的就是用来存放短期的突发访问数据。而用于存放主要元素的 LRU 被称为 Cache LRU，它占内存的百分之九十九。其中它分为两个区域：Protected 和 Probation。其中 Protected 区域（我们将其称为 A1 段）占 Cache LRU 的 80%，而另一个区域 A2 段占 Cache LRU 的 20%。</p><p><img src="image-84.png" alt="img"></p><p>具体上，对于所有的数据都会存入 Window LRU，当 Window 缓存满了，记录淘汰的数据 data1，然后判断 SLRU 中有没有满，如果 SLRU 没有满，将 data1 给插入 SLRU 中的 A2 段。如果满了，就从 A1 中淘汰掉一个数据 data2。此时就需要通过 cmSketch 来判断两者的价值，输的一方将被彻底淘汰，赢的一方则插入到 A2 中。</p><p>而在 A2 中的数据，如果被再次访问到了，就需要升级到 A1，并将 A1 中淘汰的数据给放入 A2 中。</p><p>最后一个问题，为了过滤掉一些低频访问的数据，防止它们污染缓存，可以使用 DoorKeeper 机制，它是一个 BloomFilter。如果一个元素，在 Doorkeeper 中，则直接插入 TinyLFU 的主结构，否则先插入 Doorkeeper 。对于数据查询，会将 Doorkeeper 中的那一个计数值也加到计数值上去。这样 DoorKeeper 就可以将低频数据拦截住，降低了计数器数量。</p><h2 id="3-Redis-中的-LRU-和-LFU"><a href="#3-Redis-中的-LRU-和-LFU" class="headerlink" title="3. Redis 中的 LRU 和 LFU"></a>3. Redis 中的 LRU 和 LFU</h2><p>在 Redis 中的内存淘汰策略中，就使用到了 LRU 和 LFU。</p><p>Redis 实现的 LRU 是一种近似的 LRU 算法，它在进行淘汰的时候，会采用随机采样的方式，也就是随机抽取 5 个值，然后比较它们的最近的访问时间戳（被记录在 redisObject 的 lru 字段上），淘汰掉最久没有使用的数据。</p><p>对于这样的方式，一是不用为所有的数据维护一个大链表，节省空间。二是无需考虑在访问数据的时候将访问项给移动到链表头部，节省时间开销。</p><p>对于 LFU 算法，Redis 将 redisObject 中的 lru 字段拆分成两部分，其实 16 bits 用来记录访问该 key 的时间戳，另外的 8 bits 用于存储 logc，也就是 Logistic Counter，它记录的是 key 的访问频次，值越小越容易被淘汰，初始值为 5。</p><p>当 Redis 访问一个 key 的时候，首先会对 logc 进行衰减，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><h2 id="4-MySQL-Buffer-Pool-中的-LRU"><a href="#4-MySQL-Buffer-Pool-中的-LRU" class="headerlink" title="4.  MySQL Buffer Pool 中的 LRU"></a>4.  MySQL Buffer Pool 中的 LRU</h2><p>为了解决预读失效和 BufferPool 污染问题，MySQL 改进了 LRU 算法。</p><ul><li>预读失效：MySQL 在加载数据页的时候，会将其相邻的数据页一起加载进来并放在链表最头部，这就是 MySQL 的预读机制，但是如果当预读页一直不会被访问，却占据链表的头部，而被淘汰的数据页可能是频繁访问的页，这样就降低了缓存命中率。</li></ul><p>为了解决预读失效，MySQL 将 LRU 划分成两个区域：old 和 young 区。其中 young 区在链表的前半部分，比例为 63：37。对于预读的页只会加入到 old 区域的头部，只有当页被真正访问的时候才会插入到 young 区域的头部。</p><ul><li>Buffer Pool 污染：当一个 SQL 语句扫描了大量的数据的时候，可能会将 BufferPool 中的所有的页都给替换出去，导致大量热点数据被淘汰。</li></ul><p>对于这些全表扫描的语句，很多的缓冲页其实只会被访问一次，如果就因为只访问一次而进入到了 young 区域，就会导致热点数据被替换。因此就需要提高数据进入到 young 区域的门槛，也就是增加一个停留在 young 区域的时间判断。</p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>而该间隔时间默认是 1000 ms，也就是说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p><p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会。</p><h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5. Reference"></a>5. Reference</h2><p>论文原文：<a href="https://arxiv.org/pdf/1512.00727.pdf">https://arxiv.org/pdf/1512.00727.pdf</a></p><p><a href="https://www.bilibili.com/video/BV1tP4y1n7gD/?spm_id_from=333.999.0.0&vd_source=c9f2ba203b0cd7ce73a2f3d0a7b49f8b">硬核课堂：实现更高效的缓存 解读TinyLFU算法_哔哩哔哩 bilibili</a></p><p><a href="https://github.com/dgryski/go-tinylfu/blob/master/tinylfu.go">go-tinylfu&#x2F;tinylfu.go at master · dgryski&#x2F;go-tinylfu (github.com)</a></p><p><a href="https://xiaolincoding.com/redis/module/strategy.html#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">Redis 过期删除策略和内存淘汰策略有什么区别？ | 小林coding (xiaolincoding.com)</a></p><p><a href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87">揭开 Buffer Pool 的面纱 | 小林coding (xiaolincoding.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HotRing: A Hotspot-Aware In-Memory Key-Value Store</title>
    <link href="/HotRing/HotRing/"/>
    <url>/HotRing/HotRing/</url>
    
    <content type="html"><![CDATA[<h1 id="HotRing：A-Hotspot-Aware-In-Memory-Key-Value-Store"><a href="#HotRing：A-Hotspot-Aware-In-Memory-Key-Value-Store" class="headerlink" title="HotRing：A Hotspot-Aware In-Memory Key-Value Store"></a>HotRing：A Hotspot-Aware In-Memory Key-Value Store</h1><blockquote><p>一种热点可感知的内存 KV 存储结构</p></blockquote><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在真实场景中经常会造成热点数据的出现，比如双十一的时候，会给缓存系统带来巨大的访问量；比如微博的热点事件，大多数的访问都集中在少量的数据上，也就是存在访问倾斜。为了解决这些问题，针对集群系统，一般都会采用一致性哈希、数据迁移、前端数据缓存等等。而对于单体应用而言，计算机体系结构能够利用分层存储布局，比如我们最常见的 CPU 三级缓存，将频繁访问的数据给缓存在低延时的存储介质中。</p><p>基于内存的 KV 存储结构（KVS， key-value stores）通常被广泛应用于缓存热数据，以解决基于磁盘的存储或分布式系统中的热点问题。许多的索引结构其实都可以实现 KVS，比如 skiplist、balanced&#x2F;trie trees、hash 等等。我们最常用的索引结构是哈希，因为它的快速查找功能具备大家喜爱，尤其是上层应用在不需要范围查找的时候。但是对于传统的 KVS 来说，它们所使用的底层结构对数据的冷热没有进行区分，都是统一进行管理，因而对于内存中的热点问题没有得到一个很好的解决。</p><p>如Figure 1 所示，这种结构作为底层的 KVS 将无法感知热点数据。如果我们想找到一个热点数据，例如 Item3，就必须遍历整个 Collision Chaining，这样带来的内存访问次数无疑是很高的，所造成的性能影响是很大的。虽然会存在某些机制来减少内存访问次数，比如采用 CPU 缓存，但是 CPU 的大小是有限制的。或者采用 rehash 扩大哈希表来减少每个碰撞链的长度，但是这样会显著增加内存占用（HashMap 的 rehash 会扩容成原来的两倍）。</p><blockquote><p>PS：下列两篇论文都介绍了各自设计的能更好利用 CPU 缓存的缓存友好型索引结构：</p><ol><li>FASTER：A Concurrent Key-Value Store with In-Place Updates</li><li>MICA：A Holistic Approach to Fast In-Memory Key-Value Storage</li></ol></blockquote><p><img src="image-20221221194304667.png" alt="image-20221221194304667"></p><blockquote><p>Figure 1：无热点感知的哈希结构</p></blockquote><p>出于上述的考虑，在本次的 paper 中，作者探索了 KVS 中内存索引结构的热点感知设计，讨论了热点转移和并发访问问题，最终设计了一种新的热点感知 KVS，即 HotRing。</p><ul><li>热点转移：在实际应用中，热点肯定是动态变化的，比如微博的热搜是每时每刻都会变化。因此就需要有一种轻量级的方法来跟踪热度的变化。<ul><li>底层实现基于有序哈希索引结构，通过将头指针移动到更靠近热点项的位置来实现快速访问热点项的功能。同时，它还采用了一种轻量级策略来检测运行时的热点转移。</li></ul></li><li>并发访问：既然是热点数据，肯定存在大量并发请求，为了保证性能，需要支持读&#x2F;写操作的高并发性<ul><li>HotRing在其设计中全面采用了无锁结构来解决并发访问问题 ，用于常见操作（即读取、更新）和特定于 HotRing 的操作（即热点移动检测、头指针移动和 ordered-ring rehash ）。</li></ul></li></ul><h2 id="2-设计原理"><a href="#2-设计原理" class="headerlink" title="2. 设计原理"></a>2. 设计原理</h2><h3 id="2-1-基于有序环的哈希索引设计"><a href="#2-1-基于有序环的哈希索引设计" class="headerlink" title="2.1 基于有序环的哈希索引设计"></a>2.1 基于有序环的哈希索引设计</h3><p>前面提到，一般的 KVS 都采用链表来解决哈希冲突，为了让热点项更快地被访问到，就需要将热点项给放到链表的头部，可是在并发情况下，想要保证该操作的原子性比较麻烦，因此我们就可以从另一个角度思考：不移动热点项到头部，而是直接移动 Head 的指针，使其指向热点项，并且该操作可以使用 CAS 来保证原子性。</p><p>不过这就又引出一个新问题，由于链表是单向的，如果 Head 的指针不再指向头部了，就会导致一部分的节点无法被访问到。为了确保无论头部指针怎么移动，bucket 中的所有 item 始终能访问，就需要将链表设计成环状。</p><p>同时，环形链表没有终结点，为了更好的进行值的查找，需要将环形链表设计成有序的，这样就可以根据前后项的关系判断是否终结本次查询。注意，将头指针指向的第一个 item 作为停止信号是不合适的，因为它可以被并发请求修改。</p><p>此外，比较两个较长的 Key 所带来的开销可能比较昂贵，我们将首先使用 Tag 字段进行比较。也就是说，我们的环的有序性根据其 Tag 和 Key 这一字段进行的, $order_k &#x3D; (tag_k, key_k)$</p><p>至此，我们的 HashRing 就被设计成了一个基于有序环的哈希索引了。</p><p><img src="image-20221221211049084.png" alt="image-20221221211049084"></p><blockquote><p>Figure 2：基于有序环的哈希索引</p></blockquote><p>现在来详细的说一说第三点：环的有序性。如果我们想要查找 item k，并且我们此时正在访问的是 item i，有如下所示的查找规则：</p><ul><li>找到 item k：</li></ul><p>$$<br>order_i &#x3D; order_k<br>$$</p><ul><li>未找到 item k:</li></ul><p>$$<br>\begin{cases} \quad\space order_{i-1} &lt; order_k &lt; order_i \quad①\<br>or \space order_k &lt; order_i &lt; order_{i - 1} \quad ②\<br>or \space order_i &lt; order_{i -1} &lt; order_k \quad ③<br>\end{cases}<br>$$</p><p><img src="image-20221221214644376.png" alt="image-20221221214644376"></p><blockquote><p>Figure 3：Find operation in HotRing</p></blockquote><ul><li>当查找指针指向 C 的时候，发现 C 的值要比 B 大，同时 C 的前项 A 要比 B 小，因此 B miss，对应情况①。</li><li>当查找指针指向 I 的时候，发现 I 的值要比 G 大，同时 I 的前项 F 也大于 G，并且 I 小于 F，因此 G miss，对应情况②。</li><li>H 的 miss 原因对应于情况③。</li></ul><h3 id="2-2-热点转移问题"><a href="#2-2-热点转移问题" class="headerlink" title="2.2 热点转移问题"></a>2.2 热点转移问题</h3><p>采用有序环的哈希索引，在查找过程中能很轻易的判断当前查找项是否命中，剩下的问题就是当热点移动的时候如何识别热点并调整头部指针。由于哈希值的分布非常均匀，热点项在所有桶中均匀分布。在这里，我们专注于独立地识别每个存储桶中的热点。实际上，每个桶中的冲突项的数量相对较少（例如，5 到 10 个项目），因此每个冲突环中通常有一个热点（热点比率低于10%-20%）。我们可以通过将头部指针指向唯一的热点来改进热点访问，这避免了重新组织数据并减少了内存开销。</p><p>为了获得良好的性能，必须考虑两个指标，即识别精度和反应延迟。</p><ul><li>热点识别的准确性通过所识别的热点的比例来衡量。</li><li>反应延迟是新热点发生的时间和我们成功检测到它的时间之间的时间跨度。</li></ul><p>考虑到这两个指标，我们首先引入一种随机移动策略，以识别反应延迟极低的热点。然后，我们提出了一种统计采样策略，该策略在相对较高的反应延迟下提供了更高的识别精度。</p><p>首先，我们定义了本节中使用的几个术语。头指针指向的第一个项目称为热项目，其余项目为冷项目。它们对它们的访问分别定义为热访问和冷访问。</p><h4 id="随机移动策略"><a href="#随机移动策略" class="headerlink" title="随机移动策略"></a>随机移动策略</h4><p>该策略适合于高度倾斜的数据访问，能带来较少的反应延迟，但是相对较低的精度。其基本思想是，头指针从即时决策中周期性地移动到潜在热点，而不记录任何历史元数据。特别是，为每个线程分配了一个线程本地参数，以记录它执行的请求数。在每个R请求之后，线程确定是否执行头指针移动操作。</p><ul><li>如果第 R 次访问是热访问，则头指针的位置不受影响。</li><li>否则，指针将移动到该冷访问访问的项目，该项目将成为新的热项目。</li></ul><p>参数 R 影响反应延迟和识别精度。如果使用小的 R，则实现稳定性能的反应延迟将很低。然而，这也可能导致频繁且无效的头部指针移动。在我们的场景中，数据访问是高度倾斜的，因此头部指针的移动往往很少。默认情况下，参数 R 根据经验设置为 5，这已被证明可提供低反应延迟和可忽略的性能影响。</p><p>注：也就是说在随机移动策略下，由于大部分的请求访问的都是热点数据，因此在大量的请求之后，该环的头部指针会偏向于指向热项目。不过如果一个环中存在不止一个热项目，那么就会导致头部指针的频繁移动，造成性能的丢失，因此该策略无法处理环中多个热点项的情况。</p><h4 id="统计采样策略"><a href="#统计采样策略" class="headerlink" title="统计采样策略"></a>统计采样策略</h4><p>为了实现更高的性能，我们设计了一种统计采样策略，该策略旨在提供更准确的热点识别，并具有略高的反应延迟。在详细解释该策略之前，我们先来介绍一下 HotRing 中的一些结构的内部实现：</p><p><img src="image-20221222134518866.png" alt="image-20221222134518866"></p><blockquote><p>Figure 4：HotRing Index Format.</p></blockquote><ul><li>Index Format</li></ul><p>如 Figure 4 所示，对于我们的头部指针而言，由于物理地址占 48 位，因此可以使用 48位来表示头部指针指向的地址，至于剩下的 16位（计算机可以对 64 位进行原子的 CAS），就可以用来记录一些元数据信息。</p><p>其中 Active：1 bit，用于控制热点识别的统计采样的标志。Total Counter：15 bits，表示访问对应桶中的环中的数据项的总访问次数。</p><p>同时，对于环中的一个数据项的结构而言，除了一些元数据、Tag、Key 和 Value，最重要要的是指向下一个数据项的指针：Next Item Address，同样的，它使用 48 位来表示地址，剩余的 16 位表示一些额外信息。Rehash：控制 Rehash 过程的标志；Occupied：用于确保并发正确性；Counter：记录当前数据项的访问次数。</p><ul><li>Statistical Sample</li></ul><p>在介绍了相关结构之后，接下来的问题就是如何以低开销来动态识别热点。为了在保持精度的同时最小化开销，我们每个线程都为已处理的请求维护一个线程本地计数器，来记录执行了多少次请求。每完成 R 个请求之后线程就需要决定是否移动头部指针。</p><ol><li>如果第 R 个请求是热访问，则意味着当前热点识别仍然准确，不需要触发采样。</li><li>否则需要移动头指针，开启统计采用，采其中 Sample 的次数等于桶中环的数据项个数。<ol><li>使用 CAS 来开启 Active 标志</li><li>对环后续的访问请求将被记录在 head.totalCounter 和 next.counter 上，同样使用 CAS。</li></ol></li></ol><p>根据收集的统计数据，我们能够确定新的热点项目，并根据项目的访问频率移动头部指针。采样过程完成后，最后一个访问线程负责频率计算和热点调整。首先，线程使用 CAS 原语自动重置 Active 位，这确保只有一个线程将执行后续任务。</p><p>然后，该线程计算环中每个项目的访问频率。项目 k 的访问频率是 n<del>k</del>&#x2F;N，其中 N 是环的总计数器，n<del>k</del> 是第 k 个项目的计数器。接下来，我们计算每个项目的头指针的收入。当项目 t（0&lt;t&lt;k)被头指针指向时，相应的收入 W<del>t</del>通过以下公式计算：<br>$$<br>W_t&#x3D;\sum_{i&#x3D;1}^{k} \frac{n_i}{N} * [(i - t) \space mod \space k]<br>$$<br>环中总共有 k 个节点，其中 ni&#x2F;N 表示访问第 i 个节点的概率，i - t 表示当头指针指向节点 t 的时候，移动到 i 需要的内存访问次数。</p><p>W<del>t</del> 测量当项目 t 被选择为由头部指针指向时，环的平均内存访问次数。因此，选择具有最小值（Wt）的项目作为热项目可确保更快地访问热点。如果计算的位置与前一个头部不同，则应使用 CAS 原语移动头部指针。</p><p>注意，该策略不仅处理单个热点，还适用于多个热点。它有助于找出避免热点之间频繁移动的最佳位置（例如，可能不一定是最热的项目）。热点调整完成后，该线程将重置所有计数器，为将来的下一轮采样做准备。</p><ul><li>Write-Intensive Hotspot with RCU</li></ul><p>对于更新操作，HotRing 为那些小于 8 字节的值提供了一种就地更新方法（即，现代机器支持最多8字节的原子操作）。在这种情况下，read 和 update 数据项在热度方面是相同的。然而，对于较大的值，情况完全不同，如图5所示。为了获得高性能，必须应用 read-copy-update（RCU）协议。在这种情况下，需要修改前一项的指针，以在更新期间指向新项。如果修改了头中的写入密集型热点，则必须遍历整个冲突环才能到达其前一项。也就是说，写密集型热项也会使其前一项变热。根据这一见解，我们稍微修改了统计抽样策略。对于RCU下，更新的是其前一项的计数器。这有助于指出写入密集型热点的先例，使整个RCU更新操作快速（This helps to point the head to the precedent of a write-intensive hotspot, making the entire RCU update operation fast.）</p><p>由于在 RCU 下，更新的是前一项的计数器，头指针就会趋向于指向写入项的前一项，在写密集型的热点时，可以直接定位到热点的前一项，更新时就不需要遍历链表。</p><p><img src="image-20221222152043979.png" alt="image-20221222152043979"></p><blockquote><p>Figure 5：Updating hot item A with RCU makes item F hot</p><p>热点是 A，RCU 下，修改 A 需要前一项 F，这就需要遍历整个环。所以 RCU 下，更新的是 F 的计数器，从而让头指针指向 F（写入热点依然是 A），之后写入 A 时，不需要遍历环了。</p></blockquote><ul><li>Hotspot Inheritance</li></ul><p>在头节点上执行 RCU 更新或删除时，我们需要将头指针指向其余的数据项。然而，如果头指针被随机移动，它可能以高概率指向冷项目，这将导致热点识别策略被频繁触发。此外，由于识别策略的频繁触发，系统的性能将严重下降。</p><p>首先，如果碰撞环只有一个项目（即下一个项目地址与头指针的位置相同），则 CAS 会修改头指针以完成更新或删除。如果有多个项，HotRing 使用现有的热点信息（即，头部指针位置）来继承热点。我们为 RCU 更新和删除操作设计了不同的头部指针移动策略，以确保热点调整的有效性：对于头节点的 RCU 更新，由于访问的时间局部性，最近更新的项目很有可能立即被访问。因此，头指针指向新版本的头。对于头节点的删除，只需将头指针移动到下一项，这是一个简单有效的解决方案。</p><h3 id="2-3-并发操作设计"><a href="#2-3-并发操作设计" class="headerlink" title="2.3 并发操作设计"></a>2.3 并发操作设计</h3><p>头部指针的移动使无锁设计更加复杂。这主要体现在以下几个方面：一方面，头部指针的移动可能与其他线程并行。因此，我们需要考虑头部指针移动和其他修改操作的并发性，防止指针指向无效项。</p><p>另一方面，当我们删除或更新项目时，我们需要检查头部指针是否指向该项目。如果是这样，我们需要正确而巧妙地移动头部指针。在本节中，我们主要介绍并发访问的控制方法，以解决 HotRing 中的并发问题。</p><p>为了实现高访问并发性并确保高吞吐量，我们实现了一套完整的无锁设计，这在之前的工作中得到了严格的介绍。原子 CAS 操作用于确保两个线程不会同时修改同一个Next Item Address。如果多个线程试图更新同一个Next Item Address，则只有一个线程成功，其他线程失败。失败的线程必须重新执行其操作。</p><p><img src="image-20221222152307144.png" alt="image-20221222152307144"></p><blockquote><p>Figure 6：Different concurrency issues that involve RCU operations.</p></blockquote><ul><li>Read</li></ul><p>无需任何同步，它本身就是安全的</p><ul><li>Insertion</li></ul><p>创建一个新项目并插入到环中，并修改前面的数据的 Next Item Address。两个并发操作可能会竞争相同的 Next Item Address。而 CAS 操作确保只有一个成功，其余的只能失败重试。</p><ul><li>Update</li></ul><p>我们针对不同的价值大小设计了两种更新策略。就地更新操作（针对8字节值）不会影响其他操作，这是通过CAS保证的。</p><p>然而，RCU 操作（对于较长的值）需要创建一个新项，这对其他操作的并发性提出了挑战。以 RCU 更新和插入为例，如上图 a 所示：一个线程尝试通过修改 item B 的 next 指针（Next item Address）来插入 数据 C，另一个线程尝试同时使用 B‘ 更新 B。两个操作都会成功，因为它们使用 CAS 修改了不同的指针。然而由于环看不到 B，因此即使 C 插入成功，也无法被访问到，从而导致不正确。</p><p>图 b 中也存在这样的问题。为了解决这种问题，HotRing 使用 Occupied 来保证正确性。将分为两部进行更新操作。例如在 update &amp; insert 的情况下：首先我们想要更新 B，它的 next 指针被原子的设置为已占用。一旦设置了 Occupied，C 的插入将失败，并且必须重试。其次，A 的下一个项目地址被原子的改变为 B’，B‘ 的 Occupied 将被重置。</p><ul><li>Deletion</li></ul><p>通过将指向已删除项目的指针修改为其下一个项目来实现删除。因此，必须确保在操作过程中未更改已删除项目的下一个项目地址。类似地，我们使用 Occupied 来确保并发操作的正确性。</p><p>对于如图6（c）所示的 RCU 更新和删除的情况，当项目 B 当前被删除时，通过更新转发项目 B 的指针来处理项目 D 的更新。无法正确遍历更新的项目 D’，导致数据丢失。如果项目 B 的占用位设置为删除，则项目 D 的更新将无法修改项目 B 的下一个项目地址，必须重试。一旦项目 B 的删除完成，就可以成功执行更新操作。</p><ul><li>Head Pointer Movement</li></ul><p>头部指针的移动是 HotRing 中的一个特殊动作。为了确保头部指针移动与其他操作（尤其是更新和删除）的正确性，我们需要额外的管理。有两个主要问题需要解决：（1）如何处理正常操作的并发性和标识策略导致的头指针移动？（2） 如何处理头部项目更新或删除导致的头部指针移动？</p><p>对于由识别策略引起的头部指针移动，我们还使用占用位来确保正确性。当将头指针移动到新项目时，我们设置其占用位，以确保在移动过程中不会更新或删除该项目。对于头项更新，HotRing将头指针移动到此项的新版本。在移动头指针之前，我们需要确保新版本项不会被其他线程更改（即，更新或删除）。因此，在更新项目时，HotRing会先设置新版本项目的占用位，直到移动完成。对于头部项目删除，HotRing不仅需要占用准备删除的项目，还需要占用其下一个项目。因为如果在删除操作期间下一个项目未被占用，则下一个节点可能已被更改，这使得头部指针指向无效项目。</p><h3 id="2-4-无锁化的-rehash"><a href="#2-4-无锁化的-rehash" class="headerlink" title="2.4 无锁化的 rehash"></a>2.4 无锁化的 rehash</h3><p>随着新数据从插入中到达，环中冲突项的数量继续增加，导致每次访问遍历更多项。在这种情况下，KVS 的性能将严重下降。HotRing 中提出了一种无锁重新散列策略，该策略允许随着数据量的增加而灵活地重新散列。传统的重新散列策略由哈希表的负载因子（即平均链长度）触发。</p><p><img src="image-20221222230106482.png" alt="image-20221222230106482"></p><blockquote><p>Figure 7：The lock-free rehash strategy(The dotted line between (c) and (d) represents a transition period before deletion)</p></blockquote><p>然而，这没有考虑热点的影响，因此不适合 HotRing。为了使索引适应热点项目的增长，HotRing使用访问开销（即检索项目的平均内存访问次数）来触发重新散列。我们的无锁重新散列策略包括三个步骤：</p><ul><li>Initialization</li></ul><p>首先，HotRing 创建一个后端 rehash 线程。线程通过共享标记的最高位来初始化新哈希表，该哈希表的大小是旧哈希表的两倍。如图7（a）所示，旧表的存储桶中有一个旧的头指针，相应地，新表中有两个新的头指针。旧表采用哈希值的 k 位作为哈希地址，新表取 k + 1 位。HotRing 根据标记范围划分数据。</p><p>假设哈希值有 n 位，标记范围为 [0，T) (T&#x3D;2^（n-k）^)，两个新的头指针分别管理 [0，T&#x2F;2) 和 [T&#x2F;2，T) 中的项。同时，rehash 线程创建由两个子 rehash 项组成的 rehash 节点，它们分别对应于两个新的头指针。除了没有存储有效的KV对之外，每个重新散列项具有与数据项相同的格式。HotRing 通过每个项中的 rehash 位标识 rehash 项。在初始化阶段，两个子 rehash 项的标记设置不同。如图9（b）所示，相应的 rehash 项分别将标记设置为 0 和 T&#x2F;2。</p><ul><li>Split</li></ul><p>在拆分阶段，rehash 线程通过将两个 rehash 项插入到环中来拆分环。如图 7（c）所示，reash 项分别插入到项 B 和项 E 之前，成为标记范围的边界以划分环。两个插入操作完成后，“新建表”将激活。之后，后续访问（来自新表）需要通过比较标记来选择相应的头指针，而之前的访问（来自旧表）则通过标识 rehash 节点来继续。可以正确访问所有数据，而不影响并发读写。到目前为止，对项目的访问在逻辑上分为两条路径。当我们查找目标项目时，最多需要扫描环的一半。例如，访问项 F 的遍历路径是 Head<del>1</del> -&gt; E -&gt; F</p><ul><li>Deletion</li></ul><p>在此阶段，rehash 线程删除 rehash 节点（如图 7（d）所示）。在此之前，rehash 线程必须保持一个过渡期，以确保从旧表启动的所有访问都已完成，例如读取副本更新同步原语的宽限期。</p><p>当所有访问结束时，重新散列线程可以安全地删除旧表，然后重新散列节点。请注意，过渡期只阻塞 rehash 线程，而不阻塞访问线程。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本篇论文展示了一种全新的优化角度：关注内存中的热点数据问题。为了能够内存感知，该论文设计了一种全新的数据结构 – HotRing。它以我们常见的 HashMap 为模板，进行了一系列改进：将链表设计成环，并且通过移动头指针来保证移动的并发安全性。同时环还是有序的，方便在环中快速查找到对应数据是否存在。同时考虑到热点转移问题，给出了两种热点策略，随机移动策略和统计采样策略。其中随机策略在单桶中多热点情况下表现不佳，而统计采用策略又需要一定量的计算而造成延迟，因此两种策略的选择得视情况而定。</p><p>而在并发性这一方面，HotRing 在设计的时候采用了无锁结构来解决并发访问问题，使用了 RCU 机制和 Occupied 占位符进行限制，并将该无锁结构使用在常见的操作上，即读取、更新、热点移动检测、头指针移动和无锁化的 rehash。</p><p>参考资料：</p><p><a href="https://hardcore.feishu.cn/mindnotes/bmncnt6dBr8eAb9swqLz8L7KJih">硬核课堂：HotRing 论文解读</a></p><p>HotRing 原论文：<a href="https://www.usenix.org/conference/fast20/presentation/chen-jiqiang">https://www.usenix.org/conference/fast20/presentation/chen-jiqiang</a></p><p><a href="https://keys961.github.io/2020/02/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store/">论文阅读-HotRing: A Hotspot-Aware In-Memory Key-Value Store - keys961 | keys961 Blog</a></p><p><a href="https://www.jianshu.com/p/0777755969ab">HotRing: A Hotspot-Aware In-Memory Key-Value Store - 简书 (jianshu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析06：如何进行流控</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9006%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B5%81%E6%8E%A7/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9006%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B5%81%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Sentinel-中如何进行流量控制？"><a href="#Sentinel-中如何进行流量控制？" class="headerlink" title="Sentinel 中如何进行流量控制？"></a>Sentinel 中如何进行流量控制？</h1><p>在 Sentinel 中，有关流量控制的实现在 <code>FlowSlot</code> 中进行体现。</p><p>如官网所说：<code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h2 id="第一章-关于流量控制的基本概念"><a href="#第一章-关于流量控制的基本概念" class="headerlink" title="第一章 关于流量控制的基本概念"></a>第一章 关于流量控制的基本概念</h2><p>首先让我们来看看 Sentinel 提供的默认控制台中关于添加流控规则的界面：</p><p><img src="image-20230223235305222.png" alt="image-20230223235305222"></p><p>可以发现，Sentinel 的流量控制主要有两种统计类型，由 <code>FlowRule.grade</code> 字段来进行定义：</p><ul><li><strong>统计线程数</strong>：线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。</li><li><strong>QPS 流量控制</strong>：当 QPS 超过某个阈值的时候，就可以采取措施进行流量控制，对于流量控制来说，包含三种手段，通过 <code>FlowRule.controlBehavior</code> 字段进行定义：<ul><li><strong>快速失败</strong>：也叫直接拒绝，是默认的流控方式，也就是当 QPS 超过阈值的时候，对于新的请求而言就直接拒绝。这种情况适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位。</li><li><strong>冷启动 Warm Up</strong>：该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</li><li><strong>排队等待</strong>：让请求以均匀的速度通过，对应的是<strong>漏桶算法</strong>。这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</li></ul></li></ul><p>在<strong>流控模式</strong>方面，我们一般都使用默认的直接模式，也就是根据调用方 origin 进行限流，也就是上图中的针对来源，默认是 <code>default</code>，也就是不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了该规则定义的阈值，就触发限流，字面意思上也就是使用我们的 ClusterNode 进行统计分析。</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name} &gt; other &gt; default**。</p><p>至于剩下的根据调用链路入口限流，也就是链路限流，以及根据关联流量控制，这两种流控模式我们在这就不再细说，具体可以参考官方网站上给的介绍，我们只分析直接模式中的三种 QPS 流量控制方式的源代码。</p><h2 id="第二章-对资源添加流控规则的过程"><a href="#第二章-对资源添加流控规则的过程" class="headerlink" title="第二章 对资源添加流控规则的过程"></a>第二章 对资源添加流控规则的过程</h2><p>虽然我们可以使用纯代码的方式对流控规则进行添加，但是无论是从维护角度，还是使用便捷度来说，都推荐使用控制台进行规则的添加。</p><p>在分析 Sentinel 客户端如何和控制台进行交互的时候，我们知道，客户端会使用 <code>CommandHandler</code> 处理来自于控制台的请求，于是我们将目光放在 <code>ModifyRulesCommandHandler</code> 类上，在它的 <code>handle</code> 方法中，可以发现它先去解析请求中的数据，并将其解析成 <code>FlowRule</code> 的 List 集合，然后使用 <code>FlowRuleManager.loadRules(flowRules)</code> 去将流控规则给添加到客户端的内存当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FlowRuleManager#loadRules</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadRules</span><span class="hljs-params">(List&lt;FlowRule&gt; rules)</span> &#123;<br>    currentProperty.updateValue(rules);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 currentProperty 而言，我们暂且知道它是 <code>DynamicSentinelProperty</code> 的实例对象，在它的 <code>updateValue</code> 方法中，其实就是将我们的流控规则保存在它的实例变量 <code>value</code> 中，并且调用它内部的 <code>listeners</code> 对 value 进行解析，然后将解析的结果给封装在 <code>FlowRuleManager</code> 的 <code>flowRules</code> 中（因为 FlowPropertyListener 是 FlowRuleManager 的内部类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DynamicSentinelProperty#updateValue</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateValue</span><span class="hljs-params">(T newValue)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isEqual(value, newValue)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    RecordLog.info(<span class="hljs-string">&quot;[DynamicSentinelProperty] Config will be updated to: &#123;&#125;&quot;</span>, newValue);<br><br>    value = newValue;<br>    <span class="hljs-keyword">for</span> (PropertyListener&lt;T&gt; listener : listeners) &#123;<br>        listener.configUpdate(newValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的分析，我们不难得出，<code>FlowRuleManager</code> 在整个流控中占据非常重要的地位，因为真正的流控规则其实都保存在该类中。接下来我们就着重分析一下该类，首先从属性入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 规则集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 监听器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">FlowPropertyListener</span> <span class="hljs-variable">LISTENER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowPropertyListener</span>();<br><span class="hljs-comment">// 用来监听配置是否发生变化</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SentinelProperty&lt;List&lt;FlowRule&gt;&gt; currentProperty = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicSentinelProperty</span>&lt;List&lt;FlowRule&gt;&gt;();<br><br><span class="hljs-comment">/** the corePool size of SCHEDULER must be set at 1, so the two task (&#123;<span class="hljs-doctag">@link</span> #startMetricTimerListener()&#125; can run orderly by the SCHEDULER **/</span><br><span class="hljs-meta">@SuppressWarnings(&quot;PMD.ThreadPoolCreationRule&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">SCHEDULER</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>,<br>                                                                                           <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;sentinel-metrics-record-task&quot;</span>, <span class="hljs-literal">true</span>));<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">// 设置监听</span><br>    currentProperty.addListener(LISTENER);<br>    <span class="hljs-comment">// 每一秒钟调用一次 MetricTimerListener 的 run 方法</span><br>    startMetricTimerListener();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是它内部定义了 <code>flowRules</code> 去存放真正的流控规则，其中 key 是资源的名字。同时它还定义了一个 <code>FlowPropertyListener</code> 监听器，并将其添加到 currentProperty 中，而这一步的作用，其实就是用来监听配置的变化。也就是在控制台中添加相应的流控规则的时候，就可以将控制台中的流控信息使用监听器的 configUpdate 方法去将其转换成真正的流控规则。</p><p>除此之外，它内部还定义了一个线程池，其实就是当 FlowManager 第一次被加载的时候，每一秒钟去调用一次 <code>MetricTimerListener</code> 的 run 方法，主要作用就是进行定时的数据采集，将系统中的 ClusterNodes 的数据进行收集，并写入到对应的 log 文件中。不过很疑惑的是，为什么要将数据采集到本地文件的步骤放到流控当中？我猜测可能是因为 Flow 是 slotChain 中进行规则判断的第一步，因此当系统中的第一个请求进来的时候，走到 Flow 的时候，就可以说明它应当开始收集了，虽然此时可能没有数据（因为对于数据的统计应该是走完所有的规则校验之后才在 StatisticSlot 中进行）。</p><p>好了，有了上面的基础，我们就可以从头开始梳理一遍基础的流程，以及 FlowSlot 中究竟做了什么了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    checkFlow(resourceWrapper, context, node, count, prioritized);<br><br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFlow</span><span class="hljs-params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized)</span><br>    <span class="hljs-keyword">throws</span> BlockException &#123;<br>    checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Collection&lt;FlowRule&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(String resource)</span> &#123;<br>        <span class="hljs-comment">// Flow rule map should not be null.</span><br>        Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();<br>        <span class="hljs-keyword">return</span> flowRules.get(resource);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>checkFlow</code> 方法中，我们可以发现有一个 <code>checker</code>，它其实是 <code>FlowRuleChecker</code> 类型的实例变量，不过我个人觉得在这里可以使用类变量，因为该类中并没有一些共享数据，而是一个个待调用的方法。</p><p>然后对于 <code>ruleProvider</code> 而言，是一个函数表达式，它的 <code>apply</code> 方法其实就是从 <code>FlowRuleManager</code> 中读取 <code>flowRules</code> 类变量的值，然后获取当前资源所属于的流控规则。前面也说了，对于 flowRules 类变量的修改，是通过监听器进行的。</p><p>在 <code>FlowRuleChecker</code> 类中的 <code>checkFlow</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFlow</span><span class="hljs-params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span><br><span class="hljs-params">                      Context context, DefaultNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized)</span> <span class="hljs-keyword">throws</span> BlockException &#123;<br>    <span class="hljs-keyword">if</span> (ruleProvider == <span class="hljs-literal">null</span> || resource == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回 FlowRuleManager 里面注册的对应于当前资源的规则</span><br>    Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());<br>    <span class="hljs-keyword">if</span> (rules != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (FlowRule rule : rules) &#123;<br>            <span class="hljs-comment">// 如果当前的请求不能通过，就抛出异常，该异常是 BlockException 的子类</span><br>            <span class="hljs-keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowException</span>(rule.getLimitApp(), rule);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本的流程就是先获得该资源所拥有的流控规则，然后挨个按照流控规则进行判断，如果一旦有一个不通过，就直接抛出对应的异常。</p><p>在 <code>canPassCheck</code> 方法中，我们也只会分析 <code>passLocalCheck</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">passLocalCheck</span><span class="hljs-params">(FlowRule rule, Context context, DefaultNode node, <span class="hljs-type">int</span> acquireCount,</span><br><span class="hljs-params">                                      <span class="hljs-type">boolean</span> prioritized)</span> &#123;<br>    <span class="hljs-comment">// // 根据我们的配置选择我们应该对哪个 ClusterNode 中的统计数据进行分析</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">selectedNode</span> <span class="hljs-operator">=</span> selectNodeByRequesterAndStrategy(rule, context, node);<br>    <span class="hljs-keyword">if</span> (selectedNode == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>getRater</code> 其实就是我们的几种流量控制方式，比如快速失败、冷启动 Warm Up、排队等待。</p><p>不过说起来，关于这部分的监听器设计倒是有点意思，首先我们只需要从 flowRules 中拿到对应的流控规则就行，关于它如何改变的，就直接交给我们的监听器，由监听器负责修改，并且对于 flowRules 使用 volatile 进行修饰，以防止可见性问题。不过粗略想想，发现不用监听器设计，而是使用单纯的方法对 flowRules 变量进行修改，似乎也能行得通，但是采用监听器的设计，可以降低耦合度，并且还能增强扩展性，因为你可以添加你自己的监听器，而无需修改以前的代码。至于这里有没有用设计模式，用了什么设计模式，我就不得而知了，毕竟关于设计模式的内容我还是不太熟练，也没有主动的去设计过代码。</p><h2 id="第三章-三种流控方式的分析"><a href="#第三章-三种流控方式的分析" class="headerlink" title="第三章 三种流控方式的分析"></a>第三章 三种流控方式的分析</h2><h3 id="3-1-DefaultController"><a href="#3-1-DefaultController" class="headerlink" title="3.1 DefaultController"></a>3.1 DefaultController</h3><p>对应的是直接拒绝，快速失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPass</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> acquireCount, <span class="hljs-type">boolean</span> prioritized)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> avgUsedTokens(node);<br>    <span class="hljs-keyword">if</span> (curCount + acquireCount &gt; count) &#123;<br>        <span class="hljs-comment">// 只有 prioritized 为 true 才会进入</span><br>        <span class="hljs-comment">// 即使超过限制，但是 prioritized 为 true，则认为是重要任务，可以尝试让业务线程 sleep 到下一个窗口，借用下一个窗口的计数</span><br>        <span class="hljs-keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;<br>            <span class="hljs-type">long</span> currentTime;<br>            <span class="hljs-type">long</span> waitInMs;<br>            currentTime = TimeUtil.currentTimeMillis();<br>            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);<br>            <span class="hljs-keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;<br>                node.addWaitingRequest(currentTime + waitInMs, acquireCount);<br>                node.addOccupiedPass(acquireCount);<br>                sleep(waitInMs);<br><br>                <span class="hljs-comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityWaitException</span>(waitInMs);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前分析的 ClusterNode 的 QPS 数据，然后判断当前的 QPS 是否超过了阈值，如果超过了就直接拒绝请求。</p><p>同时这里有个很有意思的设计，如果当前资源的优先级比较高，即使超过了限制，它仍然可以将其 sleep 到下一个窗口，然后借用下一个窗口的计数，而不是直接将其拒绝。</p><h3 id="3-2-WarmUpController"><a href="#3-2-WarmUpController" class="headerlink" title="3.2 WarmUpController"></a>3.2 WarmUpController</h3><p>该流控模式采用的是令牌桶算法，并且借鉴了 Google Guava 中的 RateLimiter。不过由于我水平有限，并且没有了解过 Guava 和它的预热模型，下面的源码分析其实我也看不太懂，但是参考文献中的几篇博客讲的都还不错，读者可以自行去扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarmUpController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TrafficShapingController</span> &#123;<br>    <span class="hljs-comment">// 【100】</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> count;<br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coldFactor;<br>    <span class="hljs-comment">// 转折点的令牌数【500】</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">warningToken</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 最大的令牌数【1000】</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxToken;<br>    <span class="hljs-comment">// 斜线斜率【1 / 25000】</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> slope;<br><br>    <span class="hljs-comment">// 令牌桶中剩余的令牌数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">storedTokens</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 最后更新令牌的时间</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">lastFilledTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WarmUpController</span><span class="hljs-params">(<span class="hljs-type">double</span> count, <span class="hljs-type">int</span> warmUpPeriodInSec, <span class="hljs-type">int</span> coldFactor)</span> &#123;<br>        construct(count, warmUpPeriodInSec, coldFactor);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">(<span class="hljs-type">double</span> count, <span class="hljs-type">int</span> warmUpPeriodInSec, <span class="hljs-type">int</span> coldFactor)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (coldFactor &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cold factor should be larger than 1&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 假设我们的 QPS 设置为 100，预热时间为 10s</span><br>        <span class="hljs-built_in">this</span>.count = count;<br>        <span class="hljs-comment">// 默认为 3</span><br>        <span class="hljs-built_in">this</span>.coldFactor = coldFactor;<br>        <span class="hljs-comment">// 10 * 100 / 2 = 500</span><br>        warningToken = (<span class="hljs-type">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// maxToken = 500 + （2 * 10 * 100 / 4） = 1000</span><br>        maxToken = warningToken + (<span class="hljs-type">int</span>)(<span class="hljs-number">2</span> * warmUpPeriodInSec * count / (<span class="hljs-number">1.0</span> + coldFactor));<br><br>        <span class="hljs-comment">// slope = 2 / 100 / 500 = 1 / 25000</span><br>        slope = (coldFactor - <span class="hljs-number">1.0</span>) / count / (maxToken - warningToken);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPass</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> acquireCount)</span> &#123;<br>        <span class="hljs-keyword">return</span> canPass(node, acquireCount, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPass</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> acquireCount, <span class="hljs-type">boolean</span> prioritized)</span> &#123;<br>        <span class="hljs-comment">// 获取当前时间窗口的 QPS</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">passQps</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) node.passQps();<br>        <span class="hljs-comment">// 获取上一个窗口的 QPS，跨度为 1s</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">previousQps</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) node.previousPassQps();<br>        <span class="hljs-comment">// 去设置 storedTokens 和 lastFilledTime 到正确的值</span><br>        syncToken(previousQps);<br><br>        <span class="hljs-comment">// 开始计算它的斜率</span><br>        <span class="hljs-comment">// 如果进入了警戒线，开始调整他的qps</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">restToken</span> <span class="hljs-operator">=</span> storedTokens.get();<br>        <span class="hljs-keyword">if</span> (restToken &gt;= warningToken) &#123;<br>            <span class="hljs-comment">// 当前令牌数超过了 warningToken，说明当期系统需要进行预热，或者说预热未结束，当前系统的流量较小</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">aboveToken</span> <span class="hljs-operator">=</span> restToken - warningToken;<br>            <span class="hljs-comment">// current interval = restToken*slope+1/count</span><br>            <span class="hljs-comment">// 计算出此时一秒内能够生成的 token 的数量</span><br>            <span class="hljs-comment">// 然后就需要比较令牌的生成速率 和 令牌的消耗速率</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">warningQps</span> <span class="hljs-operator">=</span> Math.nextUp(<span class="hljs-number">1.0</span> / (aboveToken * slope + <span class="hljs-number">1.0</span> / count));<br>            <span class="hljs-keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;<br>                <span class="hljs-comment">// 如果 token 的消费速度大于生成速度，就进行限流</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前令牌桶中剩余令牌数较小，说明预热结束，此时只需要判断是否超过设置的阈值就行</span><br>            <span class="hljs-keyword">if</span> (passQps + acquireCount &lt;= count) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncToken</span><span class="hljs-params">(<span class="hljs-type">long</span> passQps)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> TimeUtil.currentTimeMillis();<br>        currentTime = currentTime - currentTime % <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">oldLastFillTime</span> <span class="hljs-operator">=</span> lastFilledTime.get();<br>        <span class="hljs-keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;<br>            <span class="hljs-comment">// 如果两个时间相等，说明还处于同一秒内，不进行令牌的计算，避免重复</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> storedTokens.get();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> coolDownTokens(currentTime, passQps);<br>        <span class="hljs-comment">// 使用 CAS 重置令牌的数量</span><br>        <span class="hljs-keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;<br>            <span class="hljs-comment">// 减去上一个时间窗口的通过请求数</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> storedTokens.addAndGet(<span class="hljs-number">0</span> - passQps);<br>            <span class="hljs-keyword">if</span> (currentValue &lt; <span class="hljs-number">0</span>) &#123;<br>                storedTokens.set(<span class="hljs-number">0L</span>);<br>            &#125;<span class="hljs-comment">// 更新 lastFilledTime</span><br>            lastFilledTime.set(currentTime);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">coolDownTokens</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTime, <span class="hljs-type">long</span> passQps)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> storedTokens.get();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> oldValue;<br><br>        <span class="hljs-comment">// 添加令牌的判断前提条件:</span><br>        <span class="hljs-comment">// 当令牌的消耗程度远远低于警戒线的时候</span><br>        <span class="hljs-keyword">if</span> (oldValue &lt; warningToken) &#123;<br>            <span class="hljs-comment">// 此时说明当前没有处于预热阶段</span><br>            newValue = (<span class="hljs-type">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldValue &gt; warningToken) &#123;<br>            <span class="hljs-comment">// 处于预热阶段，如果消费速度小于冷却速度，就添加令牌</span><br>            <span class="hljs-keyword">if</span> (passQps &lt; (<span class="hljs-type">int</span>)count / coldFactor) &#123;<br>                newValue = (<span class="hljs-type">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(newValue, maxToken);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-RateLimiterController"><a href="#3-3-RateLimiterController" class="headerlink" title="3.3 RateLimiterController"></a>3.3 RateLimiterController</h3><p>其实该策略非常简单，它的核心功能就是让请求以固定速率进行通过，也就是说如果我们要求请求每隔 100ms 通过一个，但是第二个请求离第一个请求只差了 50ms，就让其睡眠 50ms 再执行；如果同时有另一个请求，就需要睡眠 150ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TrafficShapingController</span> &#123;<br><br>    <span class="hljs-comment">// 排队最大时常，默认 500ms</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxQueueingTimeMs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> count; <span class="hljs-comment">// QPS 设置的值</span><br>    <span class="hljs-comment">// 上一次请求通过的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">latestPassedTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPass</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> acquireCount, <span class="hljs-type">boolean</span> prioritized)</span> &#123;<br>        <span class="hljs-comment">// Pass when acquire count is less or equal than 0.</span><br>        <span class="hljs-comment">// acquireCount 默认是是 1</span><br>        <span class="hljs-keyword">if</span> (acquireCount &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// Reject when count is less or equal than 0.</span><br>        <span class="hljs-comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span><br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> TimeUtil.currentTimeMillis();<br>        <span class="hljs-comment">// Calculate the interval between every two requests.</span><br>        <span class="hljs-comment">// 计算两个请求之间的间隔，比如 QPS 设置为 10，那么间隔就是 100ms</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">costTime</span> <span class="hljs-operator">=</span> Math.round(<span class="hljs-number">1.0</span> * (acquireCount) / count * <span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// Expected pass time of this request. 我们期望该请求应该执行的时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">expectedTime</span> <span class="hljs-operator">=</span> costTime + latestPassedTime.get();<br>        <span class="hljs-comment">// 如果发现现在可以执行了，就直接执行</span><br>        <span class="hljs-keyword">if</span> (expectedTime &lt;= currentTime) &#123;<br>            <span class="hljs-comment">// Contention may exist here, but it&#x27;s okay.</span><br>            latestPassedTime.set(currentTime);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果发现本次请求应该再等一会才能执行，就计算出等待时间，然后就 sleep 一段时间之后再执行。</span><br>            <span class="hljs-comment">// Calculate the time to wait.</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();<br>            <span class="hljs-keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">oldTime</span> <span class="hljs-operator">=</span> latestPassedTime.addAndGet(costTime);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitTime = oldTime - TimeUtil.currentTimeMillis();<br>                    <span class="hljs-keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;<br>                        latestPassedTime.addAndGet(-costTime);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// in race condition waitTime may &lt;= 0</span><br>                    <span class="hljs-keyword">if</span> (waitTime &gt; <span class="hljs-number">0</span>) &#123;<br>                        Thread.sleep(waitTime);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://sentinelguard.io/zh-cn/docs/flow-control.html">flow-control | Sentinel (sentinelguard.io)</a></p><p>[3. Sentinel源码分析— QPS流量控制是如何实现的？ - luozhiyun&#96;s Blog](<a href="https://www.luozhiyun.com/archives/79">https://www.luozhiyun.com/archives/79</a>)</p><p><a href="https://www.javadoop.com/post/rate-limiter">RateLimiter 源码分析(Guava 和 Sentinel 实现)_Javadoop</a></p><p><a href="https://blog.csdn.net/qq_33811736/article/details/119453868">Sentinel中冷启动限流原理WarmUpController_@Kong的博客-CSDN博客_sentinel warm up</a></p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析05：滑动窗口算法在Sentinel中的应用</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E5%9C%A8Sentinel%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E5%9C%A8Sentinel%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口算法在Sentinel中的应用"><a href="#滑动窗口算法在Sentinel中的应用" class="headerlink" title="滑动窗口算法在Sentinel中的应用"></a>滑动窗口算法在Sentinel中的应用</h1><p>在 Sentinel 中，采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好的支撑写多于读的高并发场景。</p><p>在介绍滑动窗口之前，先来看看 <code>StatisticSlot</code> 究竟做了什么事情。</p><h2 id="第一章-StatisticSlot"><a href="#第一章-StatisticSlot" class="headerlink" title="第一章 StatisticSlot"></a>第一章 StatisticSlot</h2><p>在官方给的解释中，<code>StatisticSlot</code> 是 Sentinel 中最为重要的类之一，用于根据规则判断结果进行相应的统计操作。</p><p>entry 的时候：依次执行后面的判断 slot。每个 slot 触发流控的话就会抛出异常。如果有 BlockException 抛出，则记录 block 数据；若无异常抛出则算作可通过，记录 pass 数据。</p><p>exit 的时候：若无 error，无论是业务异常还是流控异常，记录 complete（success）以及 RT，线程数 -1.</p><p>记录数据的维度：线程数 + 1、记录当前 DefaultNode 数据、记录对应的 originNode 数据（若存在 origin）、累计 IN 统计数据（若流量类型为 IN）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Do some checking.</span><br>        <span class="hljs-comment">// 向后传递：调用 SlotChain 中后续的所有 Slot，完成所有规则检测（执行过程中可能会抛出异常）</span><br>        fireEntry(context, resourceWrapper, node, count, prioritized, args);<br><br>        <span class="hljs-comment">// Request passed, add thread count and pass count.</span><br>        <span class="hljs-comment">// 如果检测通过，就对 node 增加线程数和 通过的请求</span><br>        node.increaseThreadNum();<br>        node.addPassRequest(count); <span class="hljs-comment">// 涉及到滑动窗口，计算qps</span><br><br>        <span class="hljs-comment">// 对于整个应用来说，去增加相应的数据</span><br>        <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Add count for origin node.</span><br>            context.getCurEntry().getOriginNode().increaseThreadNum();<br>            context.getCurEntry().getOriginNode().addPassRequest(count);<br>        &#125;<br><br>        <span class="hljs-comment">// 什么是入口流量：一般就代表我们的接口对外提供服务，那么通常就是控制入口流量</span><br>        <span class="hljs-comment">// 如果我们在用户服务中使用 getOrderInfo 方法，而 getOrderInfo 会去调用订单服务，</span><br>        <span class="hljs-comment">// 那么对于 getOrderInfo 来说，压力都在订单服务当中，我们就可以指定它为出口流量。</span><br>        <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>            <span class="hljs-comment">// 全局的，用于 SystemRule 检查</span><br>            <span class="hljs-comment">// Sentinel 针对所有的入口流量，使用了一个全局的 ENTRY_NODE，进行统计</span><br>            <span class="hljs-comment">// Add count for global inbound entry node for global statistics.</span><br>            Constants.ENTRY_NODE.increaseThreadNum();<br>            Constants.ENTRY_NODE.addPassRequest(count);<br>        &#125;<br><br>        <span class="hljs-comment">// Handle pass event with registered entry callback handlers.</span><br>        <span class="hljs-comment">// MetricEntryCallback，也就是在 MetricCallbackInit 中引入的</span><br>        <span class="hljs-keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;<br>            handler.onPass(context, resourceWrapper, node, count, args);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (PriorityWaitException ex) &#123;<br>        <span class="hljs-comment">// 只有在 DefaultController 中才会有机会抛出该异常</span><br>        node.increaseThreadNum();<br>        <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Add count for origin node.</span><br>            context.getCurEntry().getOriginNode().increaseThreadNum();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>            <span class="hljs-comment">// Add count for global inbound entry node for global statistics.</span><br>            Constants.ENTRY_NODE.increaseThreadNum();<br>        &#125;<br>        <span class="hljs-comment">// Handle pass event with registered entry callback handlers.</span><br>        <span class="hljs-keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;<br>            handler.onPass(context, resourceWrapper, node, count, args);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (BlockException e) &#123;<br>        <span class="hljs-comment">// Blocked, set block exception to current entry.</span><br>        context.getCurEntry().setBlockError(e);<br><br>        <span class="hljs-comment">// Add block count.</span><br>        node.increaseBlockQps(count);<br>        <span class="hljs-keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="hljs-literal">null</span>) &#123;<br>            context.getCurEntry().getOriginNode().increaseBlockQps(count);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;<br>            <span class="hljs-comment">// Add count for global inbound entry node for global statistics.</span><br>            Constants.ENTRY_NODE.increaseBlockQps(count);<br>        &#125;<br><br>        <span class="hljs-comment">// Handle block event with registered entry callback handlers.</span><br>        <span class="hljs-keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;<br>            handler.onBlocked(e, context, resourceWrapper, node, count, args);<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-comment">// Unexpected internal error, set error to current entry.</span><br>        context.getCurEntry().setError(e);<br><br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看 entry 方法：</p><ol><li>先直接向后传递，先看看规则判断部分的 slot 中，经过检查之后，是否会抛出相应的异常。</li><li>如果检测通过<ol><li>增加对应 DefaultNode 的线程数和请求通过数。不过同时也会对资源相对应的 ClusterNode 进行相同的统计数据增加。</li><li>对于整个应用来说，也就是我们之前通过 ContextUtil 配置的 origin，它也会存在一个 originNode，也对它进行相应的统计。不过如果是默认的，也就是 “”，将不会存在 originNode。</li><li>同时还会判断当前资源是否是入口流量，如果是，就使用一个关于系统全局的 <code>ENTRY_NODE</code>，也就是一个 ClusterNode，去统计相应的数据，该 node 的主要作用是留着给 <code>SystemRule</code> 进行检查。</li></ol></li><li>如果抛出了 <code>PriorityWaitException</code> 异常，我们也算该请求是通过的，同样进行相应的数据统计，但是不对上面第二点所操作的节点进行 <code>addPassRequest</code> 操作。</li><li>如果发现是 <code>BlockException</code> 异常，就添加 blockQps、setBlockError等等。</li></ol><blockquote><p>什么是入口流量：一般而言就代表我们的接口对外提供服务，那么通常就是控制入口流量。如果我们在用户服务中使用 getOrderInfo 方法，而该方法会去调用订单服务，那么对于该方法来说，压力都在订单服务当中，我们就可以指定它为出口流量。</p></blockquote><p>对于整个 <code>StatisticSlot</code> 的基本流程而言，就如上面分析的那样，不过还是有几个细节的地方需要进一步分析：</p><ol><li>可以看到，当规则校验通过的时候，会有 <code>ProcessorSlotEntryCallback</code> 的实现类去执行相应的 <code>onPass</code> 方法，而如果失败了也会去执行 <code>onBlocked</code> 方法，那么这些操作的作用究竟是什么呢？</li><li>我们在进行数据统计的时候，它的详细过程究竟是怎么样的呢？滑动窗口算法的具体实现是什么呢？</li></ol><h2 id="第二章-关于规则检验之后通过或失败的回调函数"><a href="#第二章-关于规则检验之后通过或失败的回调函数" class="headerlink" title="第二章 关于规则检验之后通过或失败的回调函数"></a>第二章 关于规则检验之后通过或失败的回调函数</h2><p>我们将目光放在下列代码上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;<br>    handler.onPass(context, resourceWrapper, node, count, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们是使用 <code>StatisticSlotCallbackRegistry</code> 去获取我们的回调，而它的内部又是使用 <code>Map&lt;String, ProcessorSlotEntryCallback&lt;DefaultNode&gt;&gt; entryCallbackMap</code> 去存放我们的回调，于是我们通过查看它的 add 方法，可以发现，我们可以使用两个类去向该注册中心添加相应的回调：<code>MetricCallbackInit</code> 和 <code>ParamFlowStatisticSlotCallbackInit</code>，其中后者是需要额外引入一个依赖，也就是热点规则判断，我们不进行分析；而前者就是我们所熟悉的了，在分析 Sentinel 和控制台进行交互的时候，除了 CommandCenterInitFunc 和 心跳检测之外，还引入了一个 InitFunc，就是我们的 <code>MetricCallbackInit</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    StatisticSlotCallbackRegistry.addEntryCallback(MetricEntryCallback.class.getCanonicalName(),<br>                                                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricEntryCallback</span>());<br>    StatisticSlotCallbackRegistry.addExitCallback(MetricExitCallback.class.getCanonicalName(),<br>                                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetricExitCallback</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，就是该 InitFunc 引入了 <code>MetricEntryCallback</code>。</p><p>然而，从实际调试结果来看，该 MetricEntryCallback 似乎只是提供给我们的一个扩展点，并没有什么实质的作用，当然，可能 Sentinel 在和其他的组件在适配过程中添加了新的作用也不一定。不过我们也暂且知道了 <code>MetricCallbackInit</code> 的作用是什么样的了。</p><h2 id="第三章-滑动窗口算法的体现"><a href="#第三章-滑动窗口算法的体现" class="headerlink" title="第三章 滑动窗口算法的体现"></a>第三章 滑动窗口算法的体现</h2><p>我们就以 <code>DefaultNode</code> 为例，在它新增通过的请求数量的时候，调用的其实是父类的方法，也就是 <code>StatisticNode</code> ，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPassRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    rollingCounterInSecond.addPass(count);<br>    rollingCounterInMinute.addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这两个类究竟是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存储最近 1000 ms 的统计数据，并将 1000 ms 划分成 2 部分</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Metric</span> <span class="hljs-variable">rollingCounterInSecond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);<br><br><span class="hljs-comment">// 存储最近一分钟的统计数据，然后该 window 被划分成 60 个 bucket，</span><br><span class="hljs-comment">// 这也就意味着我们可以准确的获取每秒的统计数据</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Metric</span> <span class="hljs-variable">rollingCounterInMinute</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMetric</span>(<span class="hljs-number">60</span>, <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>可以看到，它们其实是 <code>ArrayMetric</code> 实例对象，我们查看它的 addPass 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPass</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-comment">// 获取当前属于的 bucket，并将其 value 增加 count 值</span><br>    <span class="hljs-comment">// WindowWrap：包装类，包装了 MetricBucket，也就是时间窗口的内容，以及 window 的时间长度，还有该 window 的起始时间</span><br>    WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow();<br>    wrap.value().addPass(count);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 ArrayMetric 是没有相关滑动窗口的能力的，它的核心能力来源与 data 实例变量，也就是 <code>LeapArray&lt;MetricBucket&gt;</code>。现在我们知道了，所谓的滑动时间窗口算法，其实就是一个 LeapArray，你可以将其想象成一个环形数组。举个例子，当我们只需要对最近一分钟的数据进行限流，于是我们就需要保留该请求一分钟之前的统计信息，因此该 LeapArray 的总长度应该是一分钟。但是为了方便统计（具体的原因在第一篇博客介绍传统的限流算法的时候有介绍到），就需要将一分钟给划分成多个小格，我们这里是 60 个 bucket，也就是说，LeapArray 数组的每一个空位的长度应该是一秒钟，这其实就是我们的 <code>MetricBucket</code>。</p><p><strong>在使用过程中，就可以根据请求的当前时间戳，计算出它在 LeapArray 中的具体的位置，然后取出对应的 MetricBucket，对其进行数据的统计。</strong></p><p>然而，我们上述分析的都是基于分钟的，也就是我们有六十个小格，所造成的误差其实是非常小的。但是，<strong>对于 <code>rollingCounterInSecond</code> 来说，我们只会存储最近的 1000 ms 的数据，并且只会将其划分成两部分，这样的误差其实就非常大</strong>。 </p><p>基于这样的疑问，我们来看 <code>ArrayMetric</code> 的构造函数，也就是初始化 LeapArray 的地方，可以发现，它提供了下列这两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayMetric</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs)</span> &#123;<br>    <span class="hljs-comment">// rollingCounterInSecond 使用的</span><br>    <span class="hljs-comment">// 如果对于秒级别的维度统计数据采用 BucketLeapArray 的话，会有较大的误差</span><br>    <span class="hljs-comment">// 因为对于秒级别的来说，array 中只有两个 bucket，精度太低</span><br>    <span class="hljs-comment">// 因而需要使用 OccupiableBucketLeapArray</span><br>    <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayMetric</span><span class="hljs-params">(<span class="hljs-type">int</span> sampleCount, <span class="hljs-type">int</span> intervalInMs, <span class="hljs-type">boolean</span> enableOccupy)</span> &#123;<br>    <span class="hljs-keyword">if</span> (enableOccupy) &#123;<br>        <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// rollingCounterInMinute 使用的，enableOccupy 为 false</span><br>        <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BucketLeapArray</span>(sampleCount, intervalInMs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们知道了，对于秒级别的维度来说，使用的是 <code>OccupiableBucketLeapArray</code>，而对于分钟级别的来说，使用的就是 <code>BucketLeapArray</code>。正是 LeapArray 的实现类不同，正是由于对于秒级维度的统计采用特殊的处理，才能够减少它的误差。不过我们这里只是去分析分钟维度的滑动窗口的做法，也就是分析 <code>BucketLeapArray</code>。</p><p>于是我们来看 LeapArray 的 <code>currentWindow</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> WindowWrap&lt;T&gt; <span class="hljs-title function_">currentWindow</span><span class="hljs-params">(<span class="hljs-type">long</span> timeMillis)</span> &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获得当前请求的时间 在 array 中的索引位置</span><br>    <span class="hljs-comment">// long timeId = timeMillis / windowLengthInMs; </span><br>    <span class="hljs-comment">// return (int)(timeId % array.length());</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> calculateTimeIdx(timeMillis);<br>    <br>    <span class="hljs-comment">// Calculate current bucket start time.</span><br>    <span class="hljs-comment">// 计算当前的 bucket 的开始的时间</span><br>    <span class="hljs-comment">// return timeMillis - timeMillis % windowLengthInMs;</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">windowStart</span> <span class="hljs-operator">=</span> calculateWindowStart(timeMillis); <br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Get bucket item at given time from the array.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span><br><span class="hljs-comment">         * (2) Bucket is up-to-date, then just return the bucket.</span><br><span class="hljs-comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 根据索引 idx，在采用窗口数组中取得一个时间窗口 old</span><br>        WindowWrap&lt;T&gt; old = array.get(idx);<br>        <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            bucket is empty, so create new and update</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span><br><span class="hljs-comment">                 * then try to update circular array via a CAS operation. Only one thread can</span><br><span class="hljs-comment">                 * succeed to update, while other threads yield its time slice.</span><br><span class="hljs-comment">                 */</span><br>            WindowWrap&lt;T&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>            <span class="hljs-keyword">if</span> (array.compareAndSet(idx, <span class="hljs-literal">null</span>, window)) &#123;<br>                <span class="hljs-comment">// Successfully updated, return the created bucket.</span><br>                <span class="hljs-keyword">return</span> window;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span><br>                Thread.<span class="hljs-keyword">yield</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart == old.windowStart()) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *     B0       B1      B2     B3      B4</span><br><span class="hljs-comment">                 * ||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * 200     400     600     800     1000    1200  timestamp</span><br><span class="hljs-comment">                 *                             ^</span><br><span class="hljs-comment">                 *                          time=888</span><br><span class="hljs-comment">                 *            startTime of Bucket 3: 800, so it&#x27;s up-to-date</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span><br><span class="hljs-comment">                 * that means the time is within the bucket, so directly return the bucket.</span><br><span class="hljs-comment">                 */</span><br>            <span class="hljs-keyword">return</span> old;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &gt; old.windowStart()) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 *   (old)</span><br><span class="hljs-comment">                 *             B0       B1      B2    NULL      B4</span><br><span class="hljs-comment">                 * |_______||_______|_______|_______|_______|_______||___</span><br><span class="hljs-comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span><br><span class="hljs-comment">                 *                              ^</span><br><span class="hljs-comment">                 *                           time=1676</span><br><span class="hljs-comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * If the start timestamp of old bucket is behind provided time, that means</span><br><span class="hljs-comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span><br><span class="hljs-comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span><br><span class="hljs-comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span><br><span class="hljs-comment">                 * bucket is deprecated, so in most cases it won&#x27;t lead to performance loss.</span><br><span class="hljs-comment">                 */</span><br>            <span class="hljs-keyword">if</span> (updateLock.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Successfully get the update lock, now we reset the bucket.</span><br>                    <span class="hljs-keyword">return</span> resetWindowTo(old, windowStart);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    updateLock.unlock();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span><br>                Thread.<span class="hljs-keyword">yield</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (windowStart &lt; old.windowStart()) &#123;<br>            <span class="hljs-comment">// Should not go through here, as the provided time is already behind.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowWrap</span>&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>先根据当前请求的时间计算出它在 array 中的索引位置，并计算出当前的 bucket 的开始时间，然后取得该位置的之前的窗口 old。</li><li>如果该 old 窗口根本就不存在，就只需要创建一个新的窗口给放到该位置上。</li><li>如果该 old 窗口的开始时间和我们的请求计算出来的开始时间相同，就直接返回，因为该 old 就是我们需要找的窗口。</li><li>如果发现 old 过期了，就将其替换成一个新的就行。</li></ol><p>最后在说一下 <code>MetricBucket</code> 是如何存储数据的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MetricBucket</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 将所有的 Metric 采用 LongAdder 进行计数</span><br>    MetricEvent[] events = MetricEvent.values();<br>    <span class="hljs-built_in">this</span>.counters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>[events.length];<br>    <span class="hljs-keyword">for</span> (MetricEvent event : events) &#123;<br>        counters[event.ordinal()] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    &#125;<br>    <span class="hljs-comment">// Get the max RT value that Sentinel could accept for system BBR strategy.</span><br>    <span class="hljs-comment">// 默认是 5000</span><br>    initMinRt();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，其实它的内部就是通过 LongAdder 去进行计数</p><p>到这里就把如何使用滑动窗口统计数据就讲明白了，之后的一些流控规则的操作就是根据这里面的数据进行统计分析了。</p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析04：总览Sentinel的核心流程</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004%EF%BC%9A%E6%80%BB%E8%A7%88Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004%EF%BC%9A%E6%80%BB%E8%A7%88Sentinel%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="总览-Sentinel-的核心流程"><a href="#总览-Sentinel-的核心流程" class="headerlink" title="总览 Sentinel 的核心流程"></a>总览 Sentinel 的核心流程</h1><p>在分析完 <code>@SentinelResource</code> 和 Sentinel 如何和控制台进行交互之后，本篇文章开始分析 Sentinel 的核心流程。</p><p>Sentinel 里面的各种种类的统计节点：</p><ul><li><code>StatisticNode</code>：最为基础的统计节点，包含秒级和分钟级两个滑动窗口结构。</li><li><code>DefaultNode</code>：链路节点，用于统计调用链路上某个资源的数据，维持树状结构。</li><li><code>ClusterNode</code>：簇点，用于统计每个资源全局的数据（不区分调用链路），以及存放该资源的按来源区分的调用数据（类型为 <code>StatisticNode</code>）。特别地，<code>Constants.ENTRY_NODE</code> 节点用于统计全局的入口资源数据。</li><li><code>EntranceNode</code>：入口节点，特殊的链路节点，对应某个 Context 入口的所有调用数据。<code>Constants.ROOT</code> 节点也是入口节点。</li></ul><p>构建的时机：</p><ul><li><code>EntranceNode</code> 在 <code>ContextUtil.enter(xxx)</code> 的时候就创建了，然后塞到 Context 里面。</li><li><code>NodeSelectorSlot</code>：根据 context 创建 <code>DefaultNode</code>，然后 set curNode to context。</li><li><code>ClusterBuilderSlot</code>：首先根据 resourceName 创建 <code>ClusterNode</code>，并且 set clusterNode to defaultNode；然后再根据 origin 创建来源节点（类型为 <code>StatisticNode</code>），并且 set originNode to curEntry。</li></ul><p>对于整体流程来说，可以大致概括为如下四个步骤：</p><ol><li>构建 Context</li><li>为每个资源构建自己的 slotChain</li><li>针对该 slotChain 进行信息统计和规则检验</li><li>资源调用结束时候的 exit 操作详情</li></ol><h2 id="第一章-什么是-Context？"><a href="#第一章-什么是-Context？" class="headerlink" title="第一章 什么是 Context？"></a>第一章 什么是 Context？</h2><p>在官网中，是这么解释 Context 的：</p><blockquote><p>Context 代表调用链路上下文，贯穿一次调用链路中的所有 Entry。Context 维持着入口节点（entranceNode）、本次调用链路的 curNode、调用来源（origin）等信息。Context 名称即为调用链路入口名称。</p><p>Context 维持的方式：通过 ThreadLocal 传递，只有在入口 enter 的时候生效。由于 Context 是通过 ThreadLocal 传递的，因此对于异步调用链路，线程切换的时候会丢掉 Context，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 Context。</p></blockquote><p>正如官网所说，Context 只会在该线程第一次调用的时候才会初始化，就算线程后续想换个 Context 也无法成功。</p><p>如前面博客分析的那样，Env 会做一些初始化操作，比如 <code>CommandHandler</code> 和 心跳检测，而我们会使用 <code>SphU</code> 对资源进行创建，然而，真正的对资源进行操作的类是 <code>CtSph</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">entryWithPriority</span><span class="hljs-params">(ResourceWrapper resourceWrapper, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> BlockException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Context 代表调用链路上下文，贯穿一次调用链路中的所有 Entry。</span><br><span class="hljs-comment">      Context 维持着入口节点也就是 entranceNode、本次调用链路正在处理的 curNode、调用来源 origin 等信息。</span><br><span class="hljs-comment">      Context 名称即称为调用链路入口名称</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      Context 维持的方式：通过 ThreadLocal 进行传递，只有在入口 enter 的时候才生效 。</span><br><span class="hljs-comment">      当使用异步调用链路，线程切换之间会丢掉 Context，因此需要手动使用 ContextUtil.runOnContext(context, f) 来交换 context</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      Context 只会在该线程第一次调用的时候才会初始化，就算该线程后续想换个 Context，也是不成功的。</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ContextUtil.getContext();<br>    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> NullContext) &#123;<br>        <span class="hljs-comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span><br>        <span class="hljs-comment">// so here init the entry only. No rule checking will be done.</span><br>        <span class="hljs-comment">// 表示 Context 的数量超过了阈值，所以仅仅只是初始化该 entry，而不做任何规则的检查</span><br>        <span class="hljs-comment">// 然而我们在使用中默认都只会创建同一个 context，也就是 sentinel_default_context</span><br>        <span class="hljs-comment">// 但是不清楚实际企业环境中，会不会有变化。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Using default context.</span><br>        <span class="hljs-comment">// 使用默认的，即 sentinel_default_context，origin 为 “”</span><br>        <span class="hljs-comment">// 笔者个人认为如果手动使用 ContextUtil.enter(name, origin) 进行设置的作用不大</span><br>        <span class="hljs-comment">// 向 sentinel 官方的 annotation 中，其实也使用的是默认的</span><br>        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// Global switch is close, no rule checking will do.</span><br>    <span class="hljs-keyword">if</span> (!Constants.ON) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造 slot chain，每个资源都有自己的一个 slot chain，无论该资源在哪个 Context 中</span><br>    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span><br><span class="hljs-comment">     * so no rule checking will be done.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, <span class="hljs-literal">null</span>, context);<br>    &#125;<br><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtEntry</span>(resourceWrapper, chain, context);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 开始按照构造好的 chain 进行规则检查</span><br>        chain.entry(context, resourceWrapper, <span class="hljs-literal">null</span>, count, prioritized, args);<br>    &#125; <span class="hljs-keyword">catch</span> (BlockException e1) &#123;<br>        e.exit(count, args);<br>        <span class="hljs-keyword">throw</span> e1;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;<br>        <span class="hljs-comment">// This should not happen, unless there are errors existing in Sentinel internal.</span><br>        RecordLog.info(<span class="hljs-string">&quot;Sentinel unexpected exception&quot;</span>, e1);<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>当线程第一次调用的时候，Context 肯定是 null 的，因此就需要去创建 Context，然而，<strong>每个 contextName 其实都关联着同一个 EntranceNode</strong>，因此就需要根据一个 <code>contextNameNodeMap</code> 去判断以当前 contextName 是否被创建过，如果没有创建过，就以 contextName 为 key，以 <code>new EntranceNode(new StringResourceWrapper(name, EntryType.IN), null)</code> 为 value 存放到 <code>contextNameNodeMap</code> 中。具体的代码在 <code>InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME)</code> 中。</p><blockquote><p>EntranceNode：入口节点，特殊的链路节点，对应某个 Context 入口的所有调用数据。<code>Constants.ROOT</code> 节点也是入口节点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Context <span class="hljs-title function_">trueEnter</span><span class="hljs-params">(String name, String origin)</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> contextHolder.get();<br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>        Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;<br>        <span class="hljs-type">DefaultNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> localCacheNameMap.get(name);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;<br>                setNullContext();<br>                <span class="hljs-keyword">return</span> NULL_CONTEXT;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOCK.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    node = contextNameNodeMap.get(name);<br>                    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;<br>                            setNullContext();<br>                            <span class="hljs-keyword">return</span> NULL_CONTEXT;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntranceNode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringResourceWrapper</span>(name, EntryType.IN), <span class="hljs-literal">null</span>);<br>                            <span class="hljs-comment">// Add entrance node.</span><br>                            Constants.ROOT.addChild(node);<br><br>                            Map&lt;String, DefaultNode&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(contextNameNodeMap.size() + <span class="hljs-number">1</span>);<br>                            newMap.putAll(contextNameNodeMap);<br>                            newMap.put(name, node);<br>                            contextNameNodeMap = newMap;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    LOCK.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>        context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(node, name);<br>        context.setOrigin(origin);<br>        contextHolder.set(context);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-如何构建-SlotChain？"><a href="#第二章-如何构建-SlotChain？" class="headerlink" title="第二章 如何构建 SlotChain？"></a>第二章 如何构建 SlotChain？</h2><p>对于 SlotChain 来说，每个资源都有自己的 Slot Chain，无论该资源在哪个 Context 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">ProcessorSlot&lt;Object&gt; <span class="hljs-title function_">lookProcessChain</span><span class="hljs-params">(ResourceWrapper resourceWrapper)</span> &#123;<br>    <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> chainMap.get(resourceWrapper);<br>    <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            chain = chainMap.get(resourceWrapper);<br>            <span class="hljs-keyword">if</span> (chain == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Entry size limit. 超过了限制</span><br>                <span class="hljs-keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 进行链的构造</span><br>                chain = SlotChainProvider.newSlotChain();<br>                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;ResourceWrapper, ProcessorSlotChain&gt;(<br>                    chainMap.size() + <span class="hljs-number">1</span>);<br>                newMap.putAll(chainMap);<br>                newMap.put(resourceWrapper, chain);<br>                chainMap = newMap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码还是比较传统和简单的：先从缓存中拿，如果拿不到，使用 DLC，然后进行一些判断，接着就执行核心逻辑，然后将结果添加到缓存中。</p><p>在 <code>SlotChainProvider.newSlotChain()</code> 中，会使用 SPI 机制获取 <code>SlotChainBuilder</code> 的实现类，然后只选择加载出来的第一个，如果没有就直接使用默认的，也就是 <code>DefaultSlotChainBuilder</code>，然后调用它的 <code>build</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Spi(isDefault = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSlotChainBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SlotChainBuilder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProcessorSlotChain <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProcessorSlotChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultProcessorSlotChain</span>();<br><br>        List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.of(ProcessorSlot.class).loadInstanceListSorted();<br>        <span class="hljs-keyword">for</span> (ProcessorSlot slot : sortedSlotList) &#123;<br>            <span class="hljs-keyword">if</span> (!(slot <span class="hljs-keyword">instanceof</span> AbstractLinkedProcessorSlot)) &#123;<br>                RecordLog.warn(<span class="hljs-string">&quot;The ProcessorSlot(&quot;</span> + slot.getClass().getCanonicalName() + <span class="hljs-string">&quot;) is not an instance of AbstractLinkedProcessorSlot, can&#x27;t be added into ProcessorSlotChain&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，还是 SPI 机制加上排序，不过加入的插槽必须是 <code>AbstractLinkedProcessorSlot</code>  的子类。</p><p>在 <code>Constants</code> 中，就声明了 slotChain 中的各个 slot 的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_NODE_SELECTOR_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_CLUSTER_BUILDER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_LOG_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_STATISTIC_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_AUTHORITY_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_SYSTEM_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_FLOW_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEGRADE_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>当然，还有个关于热点规则的 <code>ParamFlowSlot</code>，不过需要引入依赖 <code>sentinel-parameter-flow-control</code>。</p><h2 id="第三章-NodeSelectorSlot"><a href="#第三章-NodeSelectorSlot" class="headerlink" title="第三章 NodeSelectorSlot"></a>第三章 NodeSelectorSlot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, DefaultNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, DefaultNode&gt;(<span class="hljs-number">10</span>);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * It&#x27;s interesting that we use context name rather resource name as the map key.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Remember that same resource(&#123;@link ResourceWrapper#equals(Object)&#125;) will share</span><br><span class="hljs-comment">     * the same &#123;@link ProcessorSlotChain&#125; globally, no matter in which context. So if</span><br><span class="hljs-comment">     * code goes into &#123;@link #entry(Context, ResourceWrapper, DefaultNode, int, Object...)&#125;,</span><br><span class="hljs-comment">     * the resource name must be same but context name may not.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * If we use &#123;@link com.alibaba.csp.sentinel.SphU#entry(String resource)&#125; to</span><br><span class="hljs-comment">     * enter same resource in different context, using context name as map key can</span><br><span class="hljs-comment">     * distinguish the same resource. In this case, multiple &#123;@link DefaultNode&#125;s will be created</span><br><span class="hljs-comment">     * of the same resource name, for every distinct context (different context name) each.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Consider another question. One resource may have multiple &#123;@link DefaultNode&#125;,</span><br><span class="hljs-comment">     * so what is the fastest way to get total statistics of the same resource?</span><br><span class="hljs-comment">     * The answer is all &#123;@link DefaultNode&#125;s with same resource name share one</span><br><span class="hljs-comment">     * &#123;@link ClusterNode&#125;. See &#123;@link ClusterBuilderSlot&#125; for detail.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 注意这里是使用 context‘s name 去获取 DefaultNode，</span><br>    <span class="hljs-comment">// 是因为对于一个资源来说，它在不同的 context 中会创建不同的 DefaultNode，</span><br>    <span class="hljs-comment">// 然而所有的由同一个资源id所代表的 DefaultNode，都共享着同一个 ClusterNode</span><br>    <span class="hljs-comment">// 如果我们这里使用 resource name 去作为 map 的 key 的话，就会让位于不同 context 中的 资源拥有相同的 DefaultNode</span><br>    <span class="hljs-comment">// 如果 entry 嵌套，比如资源 a 的代码中嵌套了 资源 b，那么 a 和 b 岂不是会使用同一个 DefaultNode？然而经过测试发现，它们之间的 DefaultNode 不同，暂未发现相关代码实现</span><br>    <span class="hljs-comment">// 原来这个 map 不是 static 的，在创建 slotChain 的时候，每个资源都有自己的 chain，也就是每个资源都有自己的 NodeSelectorSLot</span><br>    <span class="hljs-type">DefaultNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(context.getName());<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            node = map.get(context.getName());<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultNode</span>(resourceWrapper, <span class="hljs-literal">null</span>);<br>                HashMap&lt;String, DefaultNode&gt; cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, DefaultNode&gt;(map.size());<br>                cacheMap.putAll(map);<br>                cacheMap.put(context.getName(), node);<br>                map = cacheMap;<br>                <span class="hljs-comment">// Build invocation tree 这里是构建链路数的核心代码</span><br>                ((DefaultNode) context.getLastNode()).addChild(node);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    context.setCurNode(node);<br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>NodeSelectorSlot 作用：负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</p><p>在代码中，可以看到我们是使用 contextName 为 key 从 map 中获取 DefaultNode，而 DefaultNode 是链路节点，用于统计调用链路上某个资源的数据，维持树状结构。<strong>每一个资源在每一个 Context 中都拥有一个 DefaultNode；而每一个资源都只有一个 ClusterNode，不论它在哪个 Context 中</strong>，但是为什么它这里要使用 contextName 作为 key？</p><p>本来我一直对这里很迷糊，甚至一度怀疑是否这里是 bug，然而在调试之后发现，同一个资源在两个不同的 Context 中，的确是两个不同的 DefaultNode，经过再三确定之后，原来这个 map 是实例变量，而不是类变量。又知道每个资源都有自己的 slotChain，因此就意味着都有自己的 NodeSelectorSlot 实例对象，因而，使用 contextName 就能做到同一个资源在不同的链路中拥有不同的 DefaultNode。</p><p>之后通过 <code>fireEntry</code> 进入下一个 slot，也就是 <code>ClusterBuilderSlot</code>。</p><h2 id="第四章-ClusterBuilderSlot"><a href="#第四章-ClusterBuilderSlot" class="headerlink" title="第四章 ClusterBuilderSlot"></a>第四章 ClusterBuilderSlot</h2><p>前面说到，资源是和 <code>ClusterNode</code> 一一对应的，它们通过资源的名字建立连接。</p><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="hljs-type">int</span> count,</span><br><span class="hljs-params">                  <span class="hljs-type">boolean</span> prioritized, Object... args)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (clusterNode == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">if</span> (clusterNode == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Create the cluster node.</span><br>                clusterNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterNode</span>(resourceWrapper.getName(), resourceWrapper.getResourceType());<br>                HashMap&lt;ResourceWrapper, ClusterNode&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(Math.max(clusterNodeMap.size(), <span class="hljs-number">16</span>));<br>                newMap.putAll(clusterNodeMap);<br>                newMap.put(node.getId(), clusterNode);<br><br>                clusterNodeMap = newMap;<br>            &#125;<br>        &#125;<br>    &#125;<br>    node.setClusterNode(clusterNode);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * if context origin is set, we should get or create a new &#123;@link Node&#125; of</span><br><span class="hljs-comment">     * the specific origin.</span><br><span class="hljs-comment">     * 如果是我们自己设置了 origin，也就是 ContextUtil.enter(name, origin)，就也要给该 origin 创建一个 StatisticNode</span><br><span class="hljs-comment">     * 如果是使用的默认的，就不用管</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;&quot;</span>.equals(context.getOrigin())) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">originNode</span> <span class="hljs-operator">=</span> node.getClusterNode().getOrCreateOriginNode(context.getOrigin());<br>        context.getCurEntry().setOriginNode(originNode);<br>    &#125;<br><br>    fireEntry(context, resourceWrapper, node, count, prioritized, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只需要注意，如果我们自己设置了 origin，也就是在 <code>ContextUtil.enter(name, origin)</code>中进行设置，就需要给该 origin 创建一个 <code>StatisticNode</code>，当然，我们这里使用的是默认的 “”，就不用管了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">Sentinel 核心类解析 · alibaba&#x2F;Sentinel Wiki (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析03：Sentinel客户端如何和控制台进行交互</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%EF%BC%9ASentinel%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%EF%BC%9ASentinel%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h2 id="Sentinel客户端如何和控制台进行交互"><a href="#Sentinel客户端如何和控制台进行交互" class="headerlink" title="Sentinel客户端如何和控制台进行交互"></a>Sentinel客户端如何和控制台进行交互</h2><p>为了简化使用的操作过程，Sentinel 提供了开源版本的 Dashboard 供我们基本使用和二次开发，如果想要在我们的系统中接入 Dashboard，我们需要下载相应的 jar 包，并且在我们的项目中添加相关依赖，然后添加一些参数来进行启动。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在我们第一章中，或者说到现在为止的分析中，都还未接触到 Sentinel 的核心流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());<br></code></pre></td></tr></table></figure><p>点进去看，可以发现它使用的其实是 Env 中的 sph 进行相应的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> Env.sph.entryWithType(name, resourceType, trafficType, <span class="hljs-number">1</span>, args);<br></code></pre></td></tr></table></figure><p>我们来看看 Env 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Env</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sph</span> <span class="hljs-variable">sph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtSph</span>();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// If init fails, the process will exit. 初始化工作</span><br>        <span class="hljs-comment">// 值得注意的是，在项目启动的时候，似乎该类并没有被加载，</span><br>        <span class="hljs-comment">// 因为打断点的时候，项目都启动完成了，该静态代码段一直没有执行</span><br>        <span class="hljs-comment">// 直到 sentinel 第一次请求的时候，该 Env 类才真正的被加载进来。</span><br>        InitExecutor.doInit();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在静态代码块中，执行了 <code>InitExecutor.doInit</code> 方法，当我们的 Sentinel 客户端第一次执行请求的时候，该静态代码块被执行，然后这才是我们和控制台进行交互的开始。</p><h2 id="第一章-从InitExecutor开始"><a href="#第一章-从InitExecutor开始" class="headerlink" title="第一章 从InitExecutor开始"></a>第一章 从InitExecutor开始</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * If one &#123;<span class="hljs-doctag">@link</span> InitFunc&#125; throws an exception, the init process</span><br><span class="hljs-comment"> * will immediately be interrupted and the application will exit.</span><br><span class="hljs-comment"> * 无论是 控制台，还是 sentinel 本身，都会调用这个方法</span><br><span class="hljs-comment"> * 对于 sentinel 来说，是在 Env 中自动初始化</span><br><span class="hljs-comment"> * 而对于控制台来说，则是在 DashboardApplication 中的 main 方法中主动调用</span><br><span class="hljs-comment"> * The initialization will be executed only once.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInit</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!initialized.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 使用 SPI 机制加载 InitFunc 的实现类</span><br>        <span class="hljs-comment">// 在包 sentinel-transport 下的 sentinel-transport-common 中，可以看到导入了</span><br>        <span class="hljs-comment">//      com.alibaba.csp.sentinel.transport.init.CommandCenterInitFunc</span><br>        <span class="hljs-comment">//      com.alibaba.csp.sentinel.transport.init.HeartbeatSenderInitFunc</span><br>        <span class="hljs-comment">// 这两个类，前者用来给 dashboard 提供接口去调用；</span><br>        <span class="hljs-comment">// 后者用来给 dashboard 发送心跳，将自己的 ip、port、sentinel 版本等信息告知 dashboard。</span><br>        <span class="hljs-comment">//      对于 dashboard 来说，有了这些信息，就可以对应用进行规则设置、到应用拉取数据用于页面展示等</span><br>        <span class="hljs-comment">// 除此之外，还通过 sentinel-core 中添加了 com.alibaba.csp.sentinel.metric.extension.MetricCallbackInit</span><br>        List&lt;InitFunc&gt; initFuncs = SpiLoader.of(InitFunc.class).loadInstanceListSorted();<br>        List&lt;OrderWrapper&gt; initList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;OrderWrapper&gt;();<br>        <span class="hljs-comment">// 以从小到达的顺序将加载的 InitFunc 包装成 OrderWrapper 并按 @InitOrder 从小到大的顺序进行排列</span><br>        <span class="hljs-keyword">for</span> (InitFunc initFunc : initFuncs) &#123;<br>            RecordLog.info(<span class="hljs-string">&quot;[InitExecutor] Found init func: &#123;&#125;&quot;</span>, initFunc.getClass().getCanonicalName());<br>            insertSorted(initList, initFunc);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (OrderWrapper w : initList) &#123;<br>            w.func.init(); <span class="hljs-comment">// 调用 InitFunc 的初始化方法</span><br>            RecordLog.info(<span class="hljs-string">&quot;[InitExecutor] Executing &#123;&#125; with order &#123;&#125;&quot;</span>,<br>                           w.func.getClass().getCanonicalName(), w.order);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        RecordLog.warn(<span class="hljs-string">&quot;[InitExecutor] WARN: Initialization failed&quot;</span>, ex);<br>        ex.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (Error error) &#123;<br>        RecordLog.warn(<span class="hljs-string">&quot;[InitExecutor] ERROR: Initialization failed with fatal error&quot;</span>, error);<br>        error.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，在我们的 Sentinel 客户端中，会通过 Env 中的静态代码块来执行 <code>InitExecutor</code> 的 <code>doInit</code> 方法；然而，在 Sentinel Dashboard 中，同样也会执行该 doInit 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DashboardApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        triggerSentinelInit();<br>        SpringApplication.run(DashboardApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">triggerSentinelInit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; InitExecutor.doInit()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，笔者现在暂时没搞明白为什么 DashBoard 也会调用该方法，不过这并不影响我们对两者之间如何交互进行分析，让我们将眼光重新放回 doInit 中：</p><ol><li>使用 SPI 机制加载 InitFunc 的实现类，并且按照以小到大的顺序将 InitFunc 的实现类包装成 OrderWrapper。</li><li>挨个调用它们的 InitFunc 的初始化方法 init。</li></ol><p>在这一步中，其实一共加载了三个 InitFunc 实现类：<strong>CommandCenterInitFunc、HeartbeatSenderInitFunc 和 MetricCallbackInit</strong></p><ul><li><code>CommandCenterInitFunc</code>：内部嵌入服务器，提供给 Dashboard去使用。Dashboard会发送相关的请求，然后给服务器接受，并进行相关处理。</li><li><code>HeartbeatSenterInitFunc</code>：给 Dashboard 发送心跳，并且将自己的 ip、port、sentinel 版本等信息告知 dashboard，<strong>对于 dashboard 来说，有了这些信息，就可以对应用进行规则设置，到应用拉去数据用于页面展示等等</strong>。</li><li><code>MetricCallbackInit</code>：内部添加了两个回调方法，留到后续章节进行分析。</li></ul><h2 id="第二章-分析CommandCenterInitFunc"><a href="#第二章-分析CommandCenterInitFunc" class="headerlink" title="第二章 分析CommandCenterInitFunc"></a>第二章 分析CommandCenterInitFunc</h2><p>注意，在我们本次的分析中，采用的是 HTTP 进行通信，因此我们引入的包是 <code>sentinel-transport-simple-http</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@InitOrder(-1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandCenterInitFunc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 本次源码分析中，导入的包是 sentinel-transport-simple-http，因此该 CommandCenter 是</span><br>        <span class="hljs-comment">// SimpleHttpCommandCenter</span><br>        <span class="hljs-type">CommandCenter</span> <span class="hljs-variable">commandCenter</span> <span class="hljs-operator">=</span> CommandCenterProvider.getCommandCenter();<br><br>        <span class="hljs-keyword">if</span> (commandCenter == <span class="hljs-literal">null</span>) &#123;<br>            RecordLog.warn(<span class="hljs-string">&quot;[CommandCenterInitFunc] Cannot resolve CommandCenter&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 初始化工作：加载 CommandHandler 的相关实现类</span><br>        <span class="hljs-comment">// CommandHandler 的实现类用来和控制台进行交互，负责处理。</span><br>        commandCenter.beforeStart();<br>        commandCenter.start();<br>        RecordLog.info(<span class="hljs-string">&quot;[CommandCenterInit] Starting command center: &quot;</span><br>                       + commandCenter.getClass().getCanonicalName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>CommandCenterProvider</code> 类中，会执行静态代码块，而在该静态代码块中，会使用 SPI 加载 <code>CommandCenter</code> 的相关实现类，不过如果系统中存在多个该类的实现类，只会取优先级最高的那个。而在本次分析中，使用的就是 <strong>SimpleHttpCommandCenter</strong>。</p><p>有了 <code>CommandCenter</code> 之后，就可以执行它的 beforeStart 方法和 start 方法。</p><h3 id="2-1-commandCenter-beforeStart-方法"><a href="#2-1-commandCenter-beforeStart-方法" class="headerlink" title="2.1 commandCenter.beforeStart 方法"></a>2.1 commandCenter.beforeStart 方法</h3><p>顾名思义，该方法的作用就是在 <code>commandCenter</code> 真正开始工作之前做一些准备工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeStart</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Register handlers</span><br>    <span class="hljs-comment">// 通过 spi 机制将 CommandHandler 实现类加载进来</span><br>    Map&lt;String, CommandHandler&gt; handlers = CommandHandlerProvider.getInstance().namedHandlers();<br>    <span class="hljs-comment">// 将 handlers 设置进 handlerMap 中</span><br>    registerCommands(handlers);<br>&#125;<br></code></pre></td></tr></table></figure><p>从总体上来说，在该方法中，会通过 SPI 机制将 CommandHandler 的实现类加载进来，不过也会通过 SPI 加载的 CommandHandlerInterceptor 去查看是否存在特殊的 CommandHandler 应该被拦截，然后将特殊的 Handler 封装成 InterceptingCommandHandler，并将其加入到 handlerMap 中（非特殊的 handler 也会被加入到该 map 中）。之后在执行 CommandHandler 的 handler 方法的时候，自然回去根据拦截器去处理特殊的逻辑。</p><p>在上面的代码中，<code>CommandHandlerProvider.getInstance()</code> 其实使用的就是单例模式，而它的 namedHandler 方法就是通过 SPI 机制去寻找我们配置好了的 CommandHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandHandlerProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;CommandHandler&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SpiLoader&lt;CommandHandler&gt; spiLoader = SpiLoader.of(CommandHandler.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get all command handlers annotated with &#123;<span class="hljs-doctag">@link</span> CommandMapping&#125; with command name.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> list of all named command handlers</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, CommandHandler&gt; <span class="hljs-title function_">namedHandlers</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, CommandHandler&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, CommandHandler&gt;();<br>        List&lt;CommandHandler&gt; handlers = spiLoader.loadInstanceList();<br>        <span class="hljs-comment">// 用来拦截一些 特殊的 CommandHandler，Sentinel 默认没有实现，不过用户可以根据 SPI 机制自行扩展来自定义</span><br>        List&lt;CommandHandlerInterceptor&gt; commandHandlerInterceptors = SpiLoader.of(CommandHandlerInterceptor.class).loadInstanceListSorted();<br>        <span class="hljs-keyword">for</span> (CommandHandler handler : handlers) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> parseCommandName(handler);<br>            <span class="hljs-keyword">if</span> (StringUtil.isEmpty(name)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!commandHandlerInterceptors.isEmpty()) &#123;<br>                List&lt;CommandHandlerInterceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (CommandHandlerInterceptor commandHandlerInterceptor : commandHandlerInterceptors) &#123;<br>                    <span class="hljs-comment">// 判断当前 handler 是否应该被拦截</span><br>                    <span class="hljs-keyword">if</span> (commandHandlerInterceptor.shouldIntercept(name)) &#123;<br>                        interceptors.add(commandHandlerInterceptor);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果该 CommandHandler 被拦截了，就将其包装成 InterceptingCommandHandler，</span><br>                <span class="hljs-comment">// 之后在执行 CommandHandler 的 handler 逻辑的时候，会进行特殊的处理</span><br>                <span class="hljs-keyword">if</span> (!interceptors.isEmpty()) &#123;<br>                    handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptingCommandHandler</span>(handler, interceptors);<br>                &#125;<br>            &#125;<br>            map.put(name, handler);<br>        &#125;<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">parseCommandName</span><span class="hljs-params">(CommandHandler handler)</span> &#123;<br>        <span class="hljs-type">CommandMapping</span> <span class="hljs-variable">commandMapping</span> <span class="hljs-operator">=</span> handler.getClass().getAnnotation(CommandMapping.class);<br>        <span class="hljs-keyword">if</span> (commandMapping != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> commandMapping.name();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;CommandHandler&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> spiLoader.loadInstanceList().iterator();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CommandHandlerProvider</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandHandlerProvider</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommandHandlerProvider <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>CommandHandlerInterceptor</code> 机制其实也是 Sentinel 留给我们的扩展点，但是在当前简单的使用 SpringAOP 适配 Sentinel 的过程中，似乎并没有发现该拦截器的具体作用，官方给的它的实现类，比如 <code>AllCommandHandlerInterceptor, EchoCommandHandlerInterceptor, GetRulesCommandHandlerInterceptor</code>，都仅仅只是做了简单的控制台输出功能，并没有进行什么实质的拦截或者增强。</p><p>在查看了 Sentinel 官方的 issue 之后，在 <a href="https://github.com/alibaba/Sentinel/issues/2677">csp.sentinel.api authentication | csp.sentinel.api 是否可以设置使用认证访问 · Issue #2677 · alibaba&#x2F;Sentinel (github.com)</a> 中，发现可以使用 <code>CommandHandlerInterceptor</code> 进行相应的授权校验，因为 Sentinel 开源版本提供给 dashboard 的这些 <code>CommandHandler</code> 一般都是裸露的，可以通过扩展该接口做授权认证。</p><h3 id="2-2-commandCenter-start-方法"><a href="#2-2-commandCenter-start-方法" class="headerlink" title="2.2 commandCenter.start 方法"></a>2.2 commandCenter.start 方法</h3><p>在引入相应的 CommandHandler，做好相应的准备之后，接下来我们继续分析 start 方法，这也是我们的核心方法之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 获取机器的线程数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nThreads</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>    <span class="hljs-built_in">this</span>.bizExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">10</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;sentinel-command-center-service-executor&quot;</span>, <span class="hljs-literal">true</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;<br>                CommandCenterLog.info(<span class="hljs-string">&quot;EventTask rejected&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>();<br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">serverInitTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-comment">// 获取端口号，默认 8719</span><br>        <span class="hljs-type">int</span> port;<br><br>        &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                port = Integer.parseInt(TransportConfig.getPort());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                port = DEFAULT_PORT;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 创建 Server Socket</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> getServerSocketFromBasePort(port);<br><br>            <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-literal">null</span>) &#123;<br>                CommandCenterLog.info(<span class="hljs-string">&quot;[CommandCenter] Begin listening at port &quot;</span> + serverSocket.getLocalPort());<br>                socketReference = serverSocket;<br>                <span class="hljs-comment">// executor 为 SingleThreadExecutor</span><br>                executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerThread</span>(serverSocket));<br>                success = <span class="hljs-literal">true</span>;<br>                port = serverSocket.getLocalPort();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                CommandCenterLog.info(<span class="hljs-string">&quot;[CommandCenter] chooses port fail, http command center will not work&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                port = PORT_UNINITIALIZED;<br>            &#125;<br><br>            TransportConfig.setRuntimePort(port);<br>            executor.shutdown();<span class="hljs-comment">// 关闭线程池</span><br>        &#125;<br><br>    &#125;;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(serverInitTask).start();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过上面的源码可以看到，我们一上来就先创建了一个 bizExecutor 线程池，该线程池是用来执行那些从 dashboard 发来的请求的，章节后续会具体分析。</li><li>创建一个 Runnable 接口的 <code>serverInitTask</code>，于是我们就可以观看该 Task 的 run 方法，在这里面，可以发现我们的默认端口就是 8719，然后创建 <code>ServerSocket</code>，并将其封装成 <code>ServerThread</code> 之后交给单线程线程池去执行它的 run 方法。</li><li>也就是上述代码中的 <code>executor.submit(new ServerThread(serverSocket));</code></li></ol><p>作为 <code>SimpleHttpCommandCenter</code> 的内部类，ServerThread 的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ServerSocket serverSocket;<br><br>    ServerThread(ServerSocket s) &#123;<br>        <span class="hljs-built_in">this</span>.serverSocket = s;<br>        setName(<span class="hljs-string">&quot;sentinel-courier-server-accept-thread&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 接受来自 dashboard 的请求</span><br>                socket = <span class="hljs-built_in">this</span>.serverSocket.accept();<br>                setSocketSoTimeout(socket); <span class="hljs-comment">// 默认超时时间为 3s</span><br>                <span class="hljs-type">HttpEventTask</span> <span class="hljs-variable">eventTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEventTask</span>(socket);<br>                <span class="hljs-comment">// 使用之前创建好的业务线程池进行异步处理 HttpEventTask</span><br>                bizExecutor.submit(eventTask);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                CommandCenterLog.info(<span class="hljs-string">&quot;Server error&quot;</span>, e);<br>                <span class="hljs-keyword">if</span> (socket != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                        CommandCenterLog.info(<span class="hljs-string">&quot;Error when closing an opened socket&quot;</span>, e1);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// In case of infinite log.</span><br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>                    <span class="hljs-comment">// Indicates the task should stop.</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它会接受来自 dashboard 的请求，并使用之前创建好的业务线程池 bizExecutor 异步处理 HttpEventTask。</p><p>具体来说，<code>HttpEventTask</code> 会根据请求解析出它的 CommandName，并根据 name 去找到对应的 CommandHandler 进行处理。<strong>也就是通过这一步，在 dashboard 中设置好的一些流控规则啥的就可以实时的反应到 Sentinel 中了</strong>。当然本次博客后面的章节还会从 dashboard 的角度去查看两者之间的交互。</p><h2 id="第三章-Sentinel-中关于控制台的心跳检测"><a href="#第三章-Sentinel-中关于控制台的心跳检测" class="headerlink" title="第三章 Sentinel 中关于控制台的心跳检测"></a>第三章 Sentinel 中关于控制台的心跳检测</h2><p>在经过上面两章节的分析中以及平时的使用过程中，难免发现一个问题：我们仅仅只在 Sentinel 客户端连接 dashboard 的时候，才会使用 JVM 参数来告知客户端 dashboard 的 ip 地址和端口号是什么，而 dashboard 却在表面层面上并不知道客户端的相关信息，那么这一切到底是怎么做的呢？这就需要我们的心跳检测了。</p><p>在 InitFunc 中，除了引入 CommandCenterInitFunc 之外，还引入了 HeartbeatSenterInitFunc，而它的作用就是周期性的向控制台发送心跳检测。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 返回 SimpleHttpHeartbeatSender</span><br>    <span class="hljs-type">HeartbeatSender</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> HeartbeatSenderProvider.getHeartbeatSender();<br>    <span class="hljs-keyword">if</span> (sender == <span class="hljs-literal">null</span>) &#123;<br>        RecordLog.warn(<span class="hljs-string">&quot;[HeartbeatSenderInitFunc] WARN: No HeartbeatSender loaded&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 初始化 定时线程池</span><br>    initSchedulerIfNeeded();<br>    <span class="hljs-comment">// 获取间隔时间，默认是 10s</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> retrieveInterval(sender);<br>    setIntervalIfNotExists(interval);<br>    <span class="hljs-comment">// 周期性执行心跳检测</span><br>    scheduleHeartbeatTask(sender, interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，Sentinel 会通过 SPI 机制加载系统中的 <code>HeartbeatSenter</code> 类的实现类，并选取优先级最高的那个，在我们本次分析中，也就是 <code>SimpleHttpHeartbeatSender</code>，接下来初始化定时线程池，然后获取我们配置好的间隔时间——如果没有配置则默认 10s，然后周期性的去执行心跳检测。</p><p>至于为什么线程池要定义成两个核心线程数，我才是因为这里面需要使用网络传输，可能遇到网络波动问题，如果只有一个线程数，那么就无法实现心跳检测的周期性，因此需要另一个线程进行缓冲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initSchedulerIfNeeded</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">null</span>) &#123;<br>        pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<br>            <span class="hljs-number">2</span>,                                <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;sentinel-heartbeat-send-task&quot;</span>, <span class="hljs-literal">true</span>),                        <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscardOldestPolicy</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleHeartbeatTask</span><span class="hljs-params">(<span class="hljs-comment">/*@NonNull*/</span> <span class="hljs-keyword">final</span> HeartbeatSender sender, <span class="hljs-comment">/*@Valid*/</span> <span class="hljs-type">long</span> interval)</span> &#123;<br>    pool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 核心逻辑</span><br>                sender.sendHeartbeat();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                RecordLog.warn(<span class="hljs-string">&quot;[HeartbeatSender] Send heartbeat error&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-number">5000</span>, interval, TimeUnit.MILLISECONDS);<br>    RecordLog.info(<span class="hljs-string">&quot;[HeartbeatSenderInit] HeartbeatSender started: &quot;</span><br>                   + sender.getClass().getCanonicalName());<br>&#125;<br></code></pre></td></tr></table></figure><p>而在 <code>SimpleHttpHeartbeatSender</code> 中：</p><ol><li>获取控制台的 ip 和 port 等信息</li><li>设置 request，也就是控制台的 ip + 端口 + 请求路径，<strong>在这一步，就将 Sentinel 客户端的相关信息通过心跳检测的方式告知给了控制台，然后控制台就可以发送指令给客户端了</strong></li><li>使用 httpClient 向控制台发送相应的 post 请求，而请求路径则是 <code>/registry/machine</code>，最终会被控制台的 <code>MachineRegistryController</code> 进行处理。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendHeartbeat</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (TransportConfig.getRuntimePort() &lt;= <span class="hljs-number">0</span>) &#123;<br>        RecordLog.info(<span class="hljs-string">&quot;[SimpleHttpHeartbeatSender] Command server port not initialized, won&#x27;t send heartbeat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取控制台的 ip 和 port 等信息</span><br>    <span class="hljs-type">Endpoint</span> <span class="hljs-variable">addrInfo</span> <span class="hljs-operator">=</span> getAvailableAddress();<br>    <span class="hljs-keyword">if</span> (addrInfo == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置 request，也就是控制台的 ip + 端口 + 请求路径</span><br>    <span class="hljs-comment">// 在这一步，就将 sentinel 的相关信息通过心跳检测的方式告知给了 控制台，然后控制台就可以发送指令给 sentinel了</span><br>    <span class="hljs-comment">// 将 控制台 和 sentinel 给联系了起来。</span><br>    <span class="hljs-comment">// 在 dashboard 中，MachineRegistryController 会处理该 post 请求。</span><br>    <span class="hljs-type">SimpleHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHttpRequest</span>(addrInfo, TransportConfig.getHeartbeatApiPath());<br>    request.setParams(heartBeat.generateCurrentMessage());<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 向服务端发送 post 请求</span><br>        <span class="hljs-type">SimpleHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.post(request);<br>        <span class="hljs-keyword">if</span> (response.getStatusCode() == OK_STATUS) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clientErrorCode(response.getStatusCode()) || serverErrorCode(response.getStatusCode())) &#123;<br>            RecordLog.warn(<span class="hljs-string">&quot;[SimpleHttpHeartbeatSender] Failed to send heartbeat to &quot;</span> + addrInfo<br>                           + <span class="hljs-string">&quot;, http status code: &quot;</span> + response.getStatusCode());<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        RecordLog.warn(<span class="hljs-string">&quot;[SimpleHttpHeartbeatSender] Failed to send heartbeat to &quot;</span> + addrInfo, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-从控制台的角度看交互"><a href="#第四章-从控制台的角度看交互" class="headerlink" title="第四章 从控制台的角度看交互"></a>第四章 从控制台的角度看交互</h2><p>在上一章节的最后我们说到，dashboard 中关于客户端的心跳的处理，是通过 <code>MachineRegistryController</code> 来实现的，而它的内部，其实就是将请求进行解析，然后将各种信息封装成 Machine 对象，并通过 <code>AppManagement</code> 进行相应的管理，具体流程就不细说了。</p><p>在控制台中，存在一个实时监控功能，它能实时的查看当前客户端资源的访问量，并且只能展示五分钟的数据：</p><p><img src="image-20230222155819931.png" alt="image-20230222155819931"></p><p>该功能的实现需要关注 <code>MetricController</code>、<code>MetricFetcher</code> 类，其实总体的原理大致就是，控制台的前端不停的发送相应的请求给控制台后端，然后控制台后端就使用 http 请求和 Sentinel 客户端进行交互，使用对应的 <code>CommandHandler</code> 处理之后，得到相应的信息之后再交给前端进行展示。</p><p>至于其他的规则配置，比如新增流控规则等等，流程都大差不差，只不过其中的实现有区别而已。</p><p>当然，在了解了这些流程之后，就可以对控制台和客户端进行二次开发，一个是可以自定义请求协议，而不是使用 Sentinel 的 HTTP 请求；第二个就是扩展 CommandHandler 和 Controller，增强安全性和符合公司业务的功能。总体来说，Sentinel 的扩展性还是很强的。</p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析02：@SentinelResource注解的基本原理</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%EF%BC%9A@SentinelResource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%EF%BC%9A@SentinelResource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SentinelResource的原理分析"><a href="#SentinelResource的原理分析" class="headerlink" title="@SentinelResource的原理分析"></a>@SentinelResource的原理分析</h1><p>在 Sentinel 中，除了在代码中直接使用它提供的 API 进行资源的控制之外，官方为了减少开发的复杂度，对大部分的主流框架进行了适配，包括 Web Servlet、Dubbo、Spring Cloud、gRPC 等等。</p><p>为了简化分析，只保留核心流程，笔者只分析如下依赖对应的源代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而有关 @SentinelResource 的源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SentinelResource &#123;<br><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the entry type (inbound or outbound), outbound by default</span><br><span class="hljs-comment">     * // 判断规则是入口流量还是出口流量</span><br><span class="hljs-comment">     */</span><br>    EntryType <span class="hljs-title function_">entryType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> EntryType.OUT;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the classification (type) of the resource</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.7.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">resourceType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>    String <span class="hljs-title function_">blockHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    Class&lt;?&gt;[] blockHandlerClass() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">fallback</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">defaultFallback</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    Class&lt;?&gt;[] fallbackClass() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] exceptionsToTrace() <span class="hljs-keyword">default</span> &#123;Throwable.class&#125;;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] exceptionsToIgnore() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="第一章-核心流程总览"><a href="#第一章-核心流程总览" class="headerlink" title="第一章 核心流程总览"></a>第一章 核心流程总览</h2><p>上述依赖包是将 Sentinel 和 Spring 进行整合，于是，对于注解的解析来说，万变不离其宗，都离不开 Spring 的 AOP，因此就如 <code>SentinelResourceAspect</code> 类所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelResourceAspect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSentinelAspectSupport</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sentinelResourceAnnotationPointcut</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;sentinelResourceAnnotationPointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invokeResourceWithSentinel</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">originMethod</span> <span class="hljs-operator">=</span> resolveMethod(pjp);<br><br>        <span class="hljs-type">SentinelResource</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> originMethod.getAnnotation(SentinelResource.class);<br>        <span class="hljs-keyword">if</span> (annotation == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Should not go through here.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Wrong state for SentinelResource annotation&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取资源的名称，如果注解没有指定value，就使用方法所在的类名 + ：+ 方法名 + 参数列表</span><br>        <span class="hljs-comment">// 例如：com.alibaba.csp.sentinel.demo.annotation.aop.service.TestServiceImpl:test()</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> getResourceName(annotation.value(), originMethod);<br>        <span class="hljs-type">EntryType</span> <span class="hljs-variable">entryType</span> <span class="hljs-operator">=</span> annotation.entryType(); <span class="hljs-comment">// 获取流量类型 IN/OUT</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">resourceType</span> <span class="hljs-operator">=</span> annotation.resourceType();<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 定义资源，这里就是走 slotChain 的逻辑了，责任链模式</span><br>            entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());<br>            <span class="hljs-keyword">return</span> pjp.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 出现这个异常说明本次请求被 sentinel 给限流了，就需要走限流逻辑</span><br>            <span class="hljs-keyword">return</span> handleBlockException(pjp, annotation, ex);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-comment">// 如果配置了 exceptionsToIgnore，就进行排查</span><br>            Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] exceptionsToIgnore = annotation.exceptionsToIgnore();<br>            <span class="hljs-comment">// The ignore list will be checked first.</span><br>            <span class="hljs-keyword">if</span> (exceptionsToIgnore.length &gt; <span class="hljs-number">0</span> &amp;&amp; exceptionBelongsTo(ex, exceptionsToIgnore)) &#123;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有配置 exceptionsToTrace，默认就是 Throwable</span><br>            <span class="hljs-keyword">if</span> (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) &#123;<br>                <span class="hljs-comment">// Trace：用来记录除了 BlockException 之外的其他的异常</span><br>                traceException(ex); <span class="hljs-comment">// TODO 暂时不知道 Trace 的作用</span><br>                <span class="hljs-keyword">return</span> handleFallback(pjp, annotation, ex); <span class="hljs-comment">// 进行 fallback 的处理逻辑</span><br>            &#125;<br><br>            <span class="hljs-comment">// No fallback function can handle the exception, so throw it out.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit(<span class="hljs-number">1</span>, pjp.getArgs());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述源码所示，Sentinel 定义了关于 @SentinelResource 注解的切面， 并对它进行环绕通知增强。</p><ol><li>先解析注解中的相关信息。</li><li>使用核心 API <code>SphU.entry</code> 定义相关 resourceName 的资源，即根据 slotChain 进行相应的统计信息和资源控制。</li><li>如果出现了 BlockException，即该资源被限制，就进行 handleBlockException 相应逻辑。</li><li>如果是除了 BlockException 之外的其他的异常，就先看该异常是否可以被忽略，如果不能，先记录该异常（暂时不知道为啥需要使用 Trace 来记录异常），然后进行 fallback 的处理逻辑。</li><li>最后，在最后，需要对创建好的 entry 进行 exit 操作，还原一些系统变量资源。</li></ol><blockquote><p>更新：这里的 Trace 作用是用来记录异常，在内部的实现中，其实大体就是 <code>Context.getContext().getCurEntry().setError(e)</code>，追踪 Entry 的 getError 方法，可以看到它在 StatisticSlot 中进行了相关的处理，具体流程将在后续分析 exit 源码的时候进行详细解析。</p></blockquote><h2 id="第二章-handleBlockException的分析"><a href="#第二章-handleBlockException的分析" class="headerlink" title="第二章 #handleBlockException的分析"></a>第二章 #handleBlockException的分析</h2><p>当我们定义的资源在经过规则检查之后，如果被限流了，就会走到该逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">handleBlockException</span><span class="hljs-params">(ProceedingJoinPoint pjp, SentinelResource annotation, BlockException ex)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 这一步就是根据注解上配置好的相关信息寻找处理 BlockException 的发方法</span><br>    <span class="hljs-comment">// Execute block handler if configured.</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">blockHandlerMethod</span> <span class="hljs-operator">=</span> extractBlockHandlerMethod(pjp, annotation.blockHandler(),<br>                                                          annotation.blockHandlerClass());<br>    <span class="hljs-comment">// 去执行对应的 block handler</span><br>    <span class="hljs-keyword">if</span> (blockHandlerMethod != <span class="hljs-literal">null</span>) &#123;<br>        Object[] originArgs = pjp.getArgs();<br>        <span class="hljs-comment">// Construct args.</span><br>        Object[] args = Arrays.copyOf(originArgs, originArgs.length + <span class="hljs-number">1</span>);<br>        args[args.length - <span class="hljs-number">1</span>] = ex;<br>        <span class="hljs-keyword">return</span> invoke(pjp, blockHandlerMethod, args);<br>    &#125;<br>    <span class="hljs-comment">// 如果找不到这样的 blockHandler 方法，就走 fallback 逻辑</span><br>    <span class="hljs-comment">// 也就是如果只配置了 fallback 而没有配置 blockHandler，如果出现了 BlockException，就会执行 fallback 逻辑</span><br>    <span class="hljs-comment">// If no block handler is present, then go to fallback.</span><br>    <span class="hljs-keyword">return</span> handleFallback(pjp, annotation, ex);<br>&#125;<br></code></pre></td></tr></table></figure><p>从整体流程来看，该异常处理机制大概就是看我们是否在注解上配置了相应的 BlockExceptionHandler，如下列代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SentinelResource(value = &quot;test&quot;, blockHandler = &quot;handleException&quot;, blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Test&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionUtil</span> &#123;<br><br>    <span class="hljs-comment">// 这里的方法返回值需要和 使用该 Exception Handler 的方法的返回值一致</span><br>    <span class="hljs-comment">// TestServiceImpl#test()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleException</span><span class="hljs-params">(BlockException ex)</span> &#123;<br>        <span class="hljs-comment">// Handler method that handles BlockException when blocked.</span><br>        <span class="hljs-comment">// The method parameter list should match original method, with the last additional</span><br>        <span class="hljs-comment">// parameter with type BlockException. The return type should be same as the original method.</span><br>        <span class="hljs-comment">// The block handler method should be located in the same class with original method by default.</span><br>        <span class="hljs-comment">// If you want to use method in other classes, you can set the blockHandlerClass</span><br>        <span class="hljs-comment">// with corresponding Class (Note the method in other classes must be static).</span><br>        System.out.println(<span class="hljs-string">&quot;Oops: &quot;</span> + ex.getClass().getCanonicalName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先检查是否在注解上配置相应的异常处理器。</li><li>如果我们配置了 BlockExceptionHandler，就执行 Handler 中定义好的异常处理器。</li><li>如果没有配置，就使用 FallBack 相应的逻辑。</li></ol><p><strong>也就是，如果我们只配置了 fallback，而没有配置 blockHandler 的话，如果出现了 BlockException，就会执行 fallback 逻辑</strong>。当然，关于 fallback 的逻辑还得后续进行详细分析，现在让我们将目光聚集在如果解析注解上关于异常处理器的相关信息，以及如何找到相应的类中的相应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// in AbstractSentinelAspectSupport.class</span><br><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">extractBlockHandlerMethod</span><span class="hljs-params">(ProceedingJoinPoint pjp, String name, Class&lt;?&gt;[] locationClass)</span> &#123;<br>    <span class="hljs-comment">// name：annotation.blockHandler</span><br> <span class="hljs-comment">// locationClass：blockHandlerClass</span><br>    <span class="hljs-keyword">if</span> (StringUtil.isBlank(name)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果 @SentinelResource 注解中配置了 blockHandlerClass，就从配置好的数组中的第一个所代表的类中找对应的 blockHandler 方法</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">mustStatic</span> <span class="hljs-operator">=</span> locationClass != <span class="hljs-literal">null</span> &amp;&amp; locationClass.length &gt;= <span class="hljs-number">1</span>;<br>    Class&lt;?&gt; clazz;<br>    <span class="hljs-keyword">if</span> (mustStatic) &#123;<br>        clazz = locationClass[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// By default current class. 如果没有 blockHandlerClass，就直接当前方法中寻找</span><br>        clazz = pjp.getTarget().getClass();<br>    &#125; <span class="hljs-comment">// 从缓存 map 中找是否存在以 clazz:name 为 key 的 MethodWrapper</span><br>    <span class="hljs-type">MethodWrapper</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ResourceMetadataRegistry.lookupBlockHandler(clazz, name);<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// First time, resolve the block handler. 总体来说，解析并找到对应的 blockHandler</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> resolveBlockHandlerInternal(pjp, name, clazz, mustStatic);<br>        <span class="hljs-comment">// Cache the method instance. 将解析到的结果保存在 map 中</span><br>        ResourceMetadataRegistry.updateBlockHandlerFor(clazz, name, method);<br>        <span class="hljs-keyword">return</span> method;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!m.isPresent()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m.getMethod();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>可以看到，首先我们去查看我们是否配置了 blockHandlerClass，如果配置了就从该类中找，如果没有配置，就从当前方法所在的类中寻找。</li><li>然后从缓存中查找是否存在以 clazz:name 为 key 的 MethodWrapper，如果存在，直接返回对应的 Method 对象。</li><li>如果不存在，就使用反射进行解析，找到对应类中的对应配置好的 blockHandler 对应的 Method。当然，有关于如何使用反射来进行解析的具体流程笔者就不进行分析了，如果对于反射机制感兴趣的可以自行查看源码。</li><li>找到解析结果之后，就将结果存放在 map 进行缓存，因为反射其实是比较消耗性能的，适当的缓存有利于提高性能。</li></ol><p>在说完如何处理 BlockException 之后，接下来我们去看看 Sentinel 如何处理其他的异常，也就是 fallback 逻辑。</p><h2 id="第三章-handleFallback的分析"><a href="#第三章-handleFallback的分析" class="headerlink" title="第三章 #handleFallback的分析"></a>第三章 #handleFallback的分析</h2><p>如第一章所述，在总体流畅上，如果出现了除了 BlockException 之外的其他异常，就需要结合 exceptionsToTrace 和 exceptionsToIgnore 进行异常的过滤，然后使用 Trace 记录了异常之后，就进入到 fallback 的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">handleFallback</span><span class="hljs-params">(ProceedingJoinPoint pjp, SentinelResource annotation, Throwable ex)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">return</span> handleFallback(pjp, annotation.fallback(), annotation.defaultFallback(), annotation.fallbackClass(), ex);<br>&#125;<br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">handleFallback</span><span class="hljs-params">(ProceedingJoinPoint pjp, String fallback, String defaultFallback,</span><br><span class="hljs-params">                                Class&lt;?&gt;[] fallbackClass, Throwable ex)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Object[] originArgs = pjp.getArgs();<br><br>    <span class="hljs-comment">// Execute fallback function if configured.</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">fallbackMethod</span> <span class="hljs-operator">=</span> extractFallbackMethod(pjp, fallback, fallbackClass);<br>    <span class="hljs-keyword">if</span> (fallbackMethod != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Construct args.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">paramCount</span> <span class="hljs-operator">=</span> fallbackMethod.getParameterTypes().length;<br>        Object[] args;<br>        <span class="hljs-keyword">if</span> (paramCount == originArgs.length) &#123;<br>            args = originArgs;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            args = Arrays.copyOf(originArgs, originArgs.length + <span class="hljs-number">1</span>);<br>            args[args.length - <span class="hljs-number">1</span>] = ex;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke(pjp, fallbackMethod, args);<br>    &#125; <span class="hljs-comment">// 如果没有配置 fallback，就使用默认的 fallback</span><br>    <span class="hljs-comment">// If fallback is absent, we&#x27;ll try the defaultFallback if provided.</span><br>    <span class="hljs-keyword">return</span> handleDefaultFallback(pjp, defaultFallback, fallbackClass, ex);<br>&#125;<br></code></pre></td></tr></table></figure><p>总体来说，fallback 的处理逻辑和 blockException 的处理逻辑大体相同，包括如何使用反射进行方法的解析等等。然而，<strong>如果没有配置 blockHandler 还可以使用 fallback 进行兜底，而如果连 fallback 都没有配置，那么就只能使用 Sentinel 提供的默认的处理逻辑了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">handleDefaultFallback</span><span class="hljs-params">(ProceedingJoinPoint pjp, String defaultFallback,</span><br><span class="hljs-params">                                       Class&lt;?&gt;[] fallbackClass, Throwable ex)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// Execute the default fallback function if configured.</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">fallbackMethod</span> <span class="hljs-operator">=</span> extractDefaultFallbackMethod(pjp, defaultFallback, fallbackClass);<br>    <span class="hljs-keyword">if</span> (fallbackMethod != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Construct args.</span><br>        Object[] args = fallbackMethod.getParameterTypes().length == <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;ex&#125;;<br>        <span class="hljs-keyword">return</span> invoke(pjp, fallbackMethod, args);<br>    &#125;<br>    <span class="hljs-comment">// 由于 @SentinelResource 中的 defaultFallback 不存在，就直接会抛出异常</span><br>    <span class="hljs-comment">// 因此反应给用户的页面就是 Whitelabel Error Page</span><br>    <span class="hljs-comment">// There was an unexpected error (type=Internal Server Error, status=500).</span><br>    <span class="hljs-keyword">throw</span> ex;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果我们配置了 defaultFallback，就可以自定义相关逻辑，然后给用户一个良好的体验。</p><p>然而，如果我们并没有配置，那么只能将异常给抛出去，呈现给用户的页面就是我们常见的 Whitelabel Error Page 了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html">open-source-framework-integrations | Sentinel (sentinelguard.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel源码分析01：什么是Sentinel限流</title>
    <link href="/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSentinel%E9%99%90%E6%B5%81/"/>
    <url>/Sentinel/Sentinel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSentinel%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-什么是限流"><a href="#第一章-什么是限流" class="headerlink" title="第一章 什么是限流"></a>第一章 什么是限流</h2><p>在实际场景中，用户在一定时间内的请求数量是不断变化的，例如我们常见的秒杀常见，可能会存在瞬间的大流量让整个系统都崩溃掉；或者有时候为了防止大量的恶意请求影响系统的稳定性，限制用户的请求流量很重要。然而，限制流量不可避免的会让用户的请求变慢，甚至有时候会直接拒绝掉用户的请求，从而给用户造成体验上的不友好。因此做好选择合适的限流算法，控制限流的平衡性非常重要。</p><h3 id="1-1-计数器限流算法"><a href="#1-1-计数器限流算法" class="headerlink" title="1.1 计数器限流算法"></a>1.1 计数器限流算法</h3><p>这是最简单的限流算法，当系统并不需要严格的限流的时候可以采用该方法。假设该系统仅仅只能同时处理M个请求，就可以在系统中维护一个 AtomicInteger 类型的计数器，每当一个请求进来的时候，就可以将该计数器的值自增。每当一个请求完成的时候就可以将该计数器的值自减。当计数器的值达到系统同时处理请求数量的阈值的时候，就拒绝接下来的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">// 计数器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 阈值</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (counter.intValue() &lt;= threshold) &#123;<br>        counter.incrementAndGet();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (counter.intValue() &gt; <span class="hljs-number">0</span>) &#123;<br>        counter.decrementAndGet();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该限流算法的优点就是足够简单，在不严格要求限流的系统中便于使用，易于维护。然而该算法并没有办法处理突发的流量，比如如果 counter 为 0，并且 threshold 为一个很大的数，那么当系统一瞬间涌入大量流量的时候，该算法并没有起到任何的限制作用。</p><h3 id="1-2-滑动窗口限流算法"><a href="#1-2-滑动窗口限流算法" class="headerlink" title="1.2 滑动窗口限流算法"></a>1.2 滑动窗口限流算法</h3><p>在说滑动窗口之前，先说说固定窗口限流算法。</p><p>所谓固定窗口限流算法，其实就是将时间以某个单位进行划分，比如每一秒钟算作一个窗口，如果在单位窗口内的访问次数超过了限制就拒绝接下来的请求。不过有的人会认为固定窗口限流算法和计数限流算法可以划等号，只不过一个是说的单位时间，一个说的是整体的阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">PERMITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 每秒请求限制数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">// 上一个窗口的开始时间。</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">if</span> (cur - timestamp &lt; <span class="hljs-number">1000</span>) &#123;<br>        <span class="hljs-comment">// 说明当前请求在该窗口内</span><br>        <span class="hljs-keyword">if</span> (counter &lt; PERMITS) &#123;<br>            counter++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-comment">// 窗口过期了，进行数据的重置，也就是进入下一个窗口</span><br>    counter = <span class="hljs-number">0</span>;<br>    timestamp = cur;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而固定窗口限流虽然实现简单，但是它还是存在的问题却显而易见：如果前一秒的请求都集中在后半段，下一秒的请求都集中在前半段，就会造成该时间段的流量过大。因此就需要滑动窗口限流算法。</p><p>在滑动窗口限流算法中，如果请求在 m 时间到达，我们就可以统计 m 之前一秒内系统所接受的请求数量，然后判断该数量是否超过阈值，不过如果按照这样，对于每次请求都往前推一段时间，然后进行统计，这就导致我们需要统计的数据量过大，并且很多的数据重复统计，浪费资源。</p><p>因此就可以将上述的固定窗口划分成多个小格子，每次都移动一小格，而不是固定窗口的长度。该算法解决了前面两个算法的瞬间流量问题，同时，当窗口的划分的粒度越细的时候，对流量的控制将会更加的精准和严格。</p><p>然而，滑动限流算法对于超过阈值的请求的处理方法太过强硬了。在某些应用当中，对于超出限制的请求不采用直接拒绝的方式，而是将其放到队列或者其他地方进行平滑处理。</p><h3 id="1-3-漏桶算法"><a href="#1-3-漏桶算法" class="headerlink" title="1.3 漏桶算法"></a>1.3 漏桶算法</h3><p>漏桶算法，可以联想出一个漏桶，水进入漏桶的速度是不受控制的，而出水的速度可以认为是恒定不变的。一旦漏桶的水满了，接下来的多余的水就只能溢出，这就对应于系统承受不了的请求直接给抛弃掉。</p><p>该算法相对于滑动窗口算法来说，最大的变化是拥有了一个用于过渡的水槽，针对于处理不了的请求，可以放在水槽中进行一个缓冲，等到系统能够处理过来的时候再慢慢处理。这样的思想倒是有一点像消息队列。</p><p>同时，该算法的一个重点在于漏桶的水的流出速度是恒定的，在实现层面上，可以配合队列实现，也就是一旦判断该请求在漏桶阈值之内，就将其添加到队列中，然后只需要开启一个定时任务，周期性的从队列中拿出请求任务进行消耗。</p><p>漏桶算法存在的主要目的是用来平滑突发的流量，提供一种机制来确保网络中的突发流量被整合成平滑稳定的流量。然而对于漏桶的流出速度的控制需要严格一点，如果速度过低就无法充分使用系统资源，如果速度过快就会导致系统的负载过大从而形成恶行循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> rate; <span class="hljs-comment">// 每秒处理数（出水率）</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> currentWater; <span class="hljs-comment">// 当前剩余水量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> refreshTime; <span class="hljs-comment">// 后刷新时间</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> capacity; <span class="hljs-comment">// 桶容量</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <span class="hljs-comment">//获取系统当前时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">outWater</span> <span class="hljs-operator">=</span> (currentTime - refreshTime) / <span class="hljs-number">1000</span> * rate; <span class="hljs-comment">//流出的水量 =(当前时间-上次刷新时间)* 出水率</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">currentWater</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, currentWater - outWater); <span class="hljs-comment">// 当前水量 = 之前的桶内水量-流出的水量</span><br>    refreshTime = currentTime; <span class="hljs-comment">// 刷新时间</span><br><br>    <span class="hljs-comment">// 当前剩余水量还是小于桶的容量，则请求放行</span><br>    <span class="hljs-keyword">if</span> (currentWater &lt; capacity) &#123;<br>        currentWater++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 当前剩余水量大于等于桶的容量，限流</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 该示例代码不完整，还需将请求放入队列中进行一定速率的消费</span><br></code></pre></td></tr></table></figure><h3 id="1-4-令牌桶算法"><a href="#1-4-令牌桶算法" class="headerlink" title="1.4 令牌桶算法"></a>1.4 令牌桶算法</h3><p>如何在限制流量速率的情况下，又能允许突发流量呢？令牌桶算法以恒定的速率向桶中分发令牌，而对于到来的请求，会先去桶中查看能否拿到令牌，如果能拿到就执行，如果拿不到就拒绝。同时，如果桶中的令牌满了，新来的令牌也不再放入桶中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">generatedToken</span> <span class="hljs-operator">=</span> (now - lastAcquireTime) * rate; <span class="hljs-comment">// 当前时间减去上次取令牌的时间 * 令牌生成的速率</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">leftToken</span> <span class="hljs-operator">=</span> min(capacity, leftToken + generatedToken);<br>    <span class="hljs-keyword">if</span> (leftToken &gt;= <span class="hljs-number">1</span>) &#123;<br>        lastAcquireTime = now;<br>        leftToken--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若是存在突发流量，桶中剩余的令牌足以应付。</p><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>针对于上述的几种限流算法，其实并不存在哪一种算法是绝对完整的，因此还是得考虑实际的应用场景选择合适的限流算法。例如漏桶算法其实不适用于要求低时延的系统。</p><p>同时对于单机的限流和分布式的限流，其实将限流的一些变量存放在不同的位置上。针对于令牌桶算法而言，其实可以每次从 Redis 中拿出多个令牌放到对应的机器内存中，这样可以减少系统和 Redis 之间的交互次数，提升性能。</p><p>对于限流算法中的阈值的确定其实也是一个难点，yes 大佬博客中所说的一个办法如下：</p><blockquote><p>限流上线之后先预估个大概的阈值，然后不执行真正的限流操作，而是采取日志记录方式，对日志进行分析查看限流的效果，然后调整阈值，推算出集群总的处理能力，和每台机子的处理能力(方便扩缩容)。</p><p>然后将线上的流量进行重放，测试真正的限流效果，最终阈值确定，然后上线。</p></blockquote><p><code>Google Guava</code> 提供的限流工具类 <code>RateLimiter</code>，是基于令牌桶实现的，并且扩展了算法，支持预热功能。</p><p>阿里开源的限流框架<code>Sentinel</code> 中的匀速排队限流策略，就采用了漏桶算法。</p><h2 id="第二章-初识-Sentinel"><a href="#第二章-初识-Sentinel" class="headerlink" title="第二章 初识 Sentinel"></a>第二章 初识 Sentinel</h2><h3 id="2-1-基本的认识和使用"><a href="#2-1-基本的认识和使用" class="headerlink" title="2.1 基本的认识和使用"></a>2.1 基本的认识和使用</h3><p>Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p><p>在 Sentinel 中，资源是它的关键概念，只要通过 Sentinel 的 API 定义的代码，都可以被称作资源，能够被 Sentinel 给保护起来。</p><p>如果只是想简单使用 Sentinel 的核心功能，而不需要和其他的框架，例如 SpringBoot 进行整合，就可以引入 sentinel-core 依赖，然后使用 Sentinel 提供的 API 对想要进行流控的代码进行保护，使其被定义为资源。</p><p>在使用方面，一般主要分为如下三个步骤：</p><ol><li>定义资源</li><li>定义规则</li><li>检验规则是否生效</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;contextName&quot;</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    entry = SphU.entry(<span class="hljs-string">&quot;resourceName&quot;</span>);<br>    <span class="hljs-comment">// 业务代码</span><br>&#125; <span class="hljs-keyword">catch</span> (BlockException e) &#123;<br>    <span class="hljs-comment">// 进行限流的相关处理</span><br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    <span class="hljs-comment">// 进行其他的一些异常处理</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>        entry.exit(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在使用上述代码之前，可以使用纯 API 代码进行流控规则的设置。</p><p>然而在大部分的使用场景中，都会将其与 SpringBoot 进行适配，只使用一个注解就能完成上述的功能，降低侵入性，在 Sentinel 中，使用的就是 @SentinelResource 注解，具体的注解原理在以后的章节进行详细介绍。</p><p>同时，可以使用官方给定的 dashboard 控制台进行可视化的资源设定，可以随时更改和实时监控，在使用的复杂度方面也大大降低。然而，官方给定的 dashboard 控制台将所有的配置都存放在内存中，这在实际生产环境中肯定是不科学的，因此还需要规则配置的持久化。在实际中，一般都需要根据 Sentinel 和它提供的控制台进行二次开发。</p><p>可以通过实现 <code>DataSource</code> 接口的方式，来自定义规则的存储数据源。</p><ol><li><p>下载控制台相关 jar 包。</p></li><li><p>在客户端引入相应的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启动的时候添加 JVM 参数指定控制台地址和端口。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Dcsp.sentinel.dashboard.server</span>=<span class="hljs-string">consoleIp:port</span><br></code></pre></td></tr></table></figure></li><li><p>确保客户端有访问量，只有第一次访问的时候两者之间才会建立链接。</p></li></ol><h3 id="2-2-Sentinel-的基本流程"><a href="#2-2-Sentinel-的基本流程" class="headerlink" title="2.2 Sentinel 的基本流程"></a>2.2 Sentinel 的基本流程</h3><p>在 Sentinel 中，最重要的可能就属 ProcessorSlotChain 了，它是 Sentinel 的核心骨架，使用责任链模式将不同的 Slot 按照指定的顺序串在一起，从而将不同的功能，比如限流、降级、系统保护等等，组合在一起。从总体上来说，slot chain 可以分为两部分：统计数据构建部分，以及规则判断部分，如下图所示：</p><p><img src="sentinel-slot-chain-architecture.png" alt="sentinel-slot-chain"></p><p>当然，上述图中的规则判断部分的顺序可能和代码中的不太一样，具体的顺序需要按照实际源码进行分析和判断。同时，Sentinel 还提供了相应的 SPI 机制保留了对该规则判断部分的自定义扩展。</p><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_NODE_SELECTOR_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_CLUSTER_BUILDER_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_LOG_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_STATISTIC_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_AUTHORITY_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_SYSTEM_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_FLOW_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ORDER_DEGRADE_SLOT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>在接下来的章节中，笔者将会分析 Sentinel 客户端如何和 Dashboard 进行交互，并且按照 Sentinel 的基本流程进行逐个分析。</p><h2 id="第三章-如何在生产中使用Sentinel？"><a href="#第三章-如何在生产中使用Sentinel？" class="headerlink" title="第三章 如何在生产中使用Sentinel？"></a>第三章 如何在生产中使用Sentinel？</h2><p>Sentinel 毕竟是开源版本的，它的有些特殊的功能肯定无法给放出来开源，然而，Sentinel 本身是一个非常优秀的组件，而想要使用好 Sentinel，就需要对其进行二次开发和扩展， 使其符合我们的业务需求。</p><p>但是，笔者作为一个学生，是断断没有资格和眼界去扩展 Sentinel 的，因为我也不知道在实际的企业中，究竟会遇到什么样的困难，但是，这里有一篇博客说的很不错，对当前 Sentinel 的缺点进行了指出，并结合实际环境提出了一些改进意见。</p><p><a href="https://mp.weixin.qq.com/s/AjHCUmygTr78yo9yMxMEyg">阿里巴巴开源限流降级神器Sentinel大规模生产级应用实践 (qq.com)</a></p><p>获取以后工作之后，有时间会尝试着二次开发 Sentinel 吧。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&mid=2247488795&idx=1&sn=7cc3377f2b6a3acf46c097cfb4213f1f&scene=21#wechat_redirect">阿里云二面：你对限流了解多少？</a></p><p><a href="https://z.itpub.net/article/detail/B049B6F216829EDD0827E97BC1AA9100">面试必备：4种经典限流算法讲解</a></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">introduction | Sentinel (sentinelguard.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>Sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Redis</title>
    <link href="/Redis/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis/"/>
    <url>/Redis/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-Redis中的单线程"><a href="#第一章-Redis中的单线程" class="headerlink" title="第一章 Redis中的单线程"></a>第一章 Redis中的单线程</h2><h3 id="1-1-为什么Redis采用单线程"><a href="#1-1-为什么Redis采用单线程" class="headerlink" title="1.1 为什么Redis采用单线程"></a>1.1 为什么Redis采用单线程</h3><p><strong>redis中的单线程，主要指的是Redis的网络IO和键值对的读写是由一个线程来完成的</strong>，但是其余的功能，比如持久化、异步删除、集群数据同步等功能其实还是由其余的线程来完成的。</p><p><strong>为什么使用单线程？】</strong></p><p>多线程来说，它虽然能够提升系统同时处理的请求数，提高吞吐量。但是其实如果线程过多了，系统的吞吐量其实是会逐渐下降的，因为他们可能会有线程上下文的切换的消耗，而且为了保证在多线程环境下修改共享变量的正确性，还得添加同步机制，这个额外的机制同样也会造成额外的开销，同时也会降低系统的易调试性和可维护性。如果不添加额外的同步机制，就可能会引起多线程编程模式下面临的共享资源的并发访问控制的问题。</p><p>而且早期官方认为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，它的瓶颈最可能是内存的大小或者网络限制。</p><p>因此Redis采用的是单线程。</p><p><strong>单线程Redis为什么这么快？】</strong></p><ol><li>大部分操作都是在内存中进行的。</li><li>高效的数据结构，比如哈希表、跳表</li><li><strong>IO多路复用机制</strong>，能够在网络IO操作中并发处理大量的客户端请求。Redis是基于多路复用模型中的epoll模型进行网络通讯的，epoll模型只需要一个线程就可以监听多个连接，epoll模型的事件监听机制，所有的数据都是异步操作，也不会阻塞主线程。</li></ol><p><strong>Redis单线程处理IO请求性能的瓶颈】</strong></p><ol><li>任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种： <ul><li>操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；</li><li>使用复杂度过高的命令：例如SORT&#x2F;SUNION&#x2F;ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；</li><li>大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；</li><li>淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；</li><li>AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；</li><li>主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li></ul></li><li>并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。这里的同步并不是指直接整个网络IO是同步的，而是指从内核缓冲区中拷贝数据的操作是同步操作。</li></ol><p>针对问题1：一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。 </p><p>针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</p><blockquote><p>Redis6中引入的多线程</p></blockquote><p>主要是为了提高网络IO读写性能，但是Redis的执行命令仍然是单线程顺序执行的，不需要担心线程安全问题。</p><h3 id="1-2-IO多路复用"><a href="#1-2-IO多路复用" class="headerlink" title="1.2 IO多路复用"></a>1.2 IO多路复用</h3><p>在说 IO 多路复用之前，先说一说 Linux 的 IO 模型：</p><p>假设我们在用户态想要读取系统中的某些数据，就需要使用系统调用，然后让操作系统从磁盘读取对应的数据到内核缓冲区，接着将内核缓冲区的数据拷贝到用户态，然后交给我们。</p><ul><li>阻塞 IO：就和上面说的一样，对于数据等待阶段还有数据拷贝阶段，都是阻塞的。</li><li>非阻塞 IO：如果我们发现内核缓冲区不存在对应的数据的时候，就直接返回错误给用户，然后用户只需要去不断轮询去查看内核缓冲区有没有数据，如果有数据了，就等待拷贝，然后返回。注意，非阻塞 IO 在数据等待阶段是非阻塞的，不过需要不停的执行命令来查看，无形中增加了 CPU 的压力，以及用户态和内核态切换的开销。</li></ul><h3 id="1-3-如何避免单线程模型的阻塞"><a href="#1-3-如何避免单线程模型的阻塞" class="headerlink" title="1.3 如何避免单线程模型的阻塞"></a>1.3 如何避免单线程模型的阻塞</h3><p><strong>对于Redis来说，到底有哪些操作会导致主线程阻塞呢？】</strong></p><ul><li><strong>客户端：</strong>网络 IO，键值对增删改查操作，数据库操作；</li></ul><p>对于网络IO来说，如果它有时候比较慢，但是Redis使用了IO多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，因此网络IO不是导致Redis阻塞的因素。</p><p>在Redis中，由于它对很多数据结构操作都做了优化，基本为O(1)，所以如果操作复杂度为O(N)，就必须重视，就比如集合元素中的<strong>聚合统计</strong>如并集、交集、差集等等，或者集合元素全量查询操作如HGETALL、SMEMBERS。</p><p>而且注意，对于<strong>集合自身或者bigkey的删除操作</strong>同样也有潜在的阻塞风险。<strong>删除操作的本质是要释放键值对占用的内存空间，但是操作系统还需要将释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。当然不仅仅是插入到链表，还会伴随着空闲块的合并，以及有可能将内存归还到操作系统。</strong>如果一下子释放了大量内存，也有可能导致Redis主线程阻塞。</p><p>利用FLUSHDB或FLUSHALL操作将Redis数据库给清空，同样也可能会造成主线程阻塞。</p><ul><li><strong>磁盘：</strong>生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li></ul><p>当生成RDB快照和AOF日志重写的时候，虽然是交给了子进程去做，但是在fork阶段同样会导致Redis主线程的阻塞。同样，如果AOF日志开启的策略是同步写，每次执行一条命令都会去写入AOF文件中，再加上可能有大量的写操作，也有可能导致主线程阻塞。</p><ul><li><strong>主从节点：</strong>主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li></ul><p>同样的，主库生成RDB需要阻塞主线程，但是主库在复制过程中，创建和传输RDB文件都是由子进程来完成的，不会阻塞主线程。但是对于从库来说，它在接受了RDB文件之后，需要使用FLUSHDB来清空当前数据库。清空之后还得将RDB文件加载到内存。</p><ul><li><strong>切片集群实例：</strong>向其他实例传输哈希槽信息，数据迁移。</li></ul><p>对于刚开始部署切面集群的时候，每个Redis实例上分配的哈希槽信息需要在不同的实例间传递，同时当需要进行负载均衡或有实例增删时，数据会在不同的实例之间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。</p><p>如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程</p><p><strong>异步的子线程操作】</strong></p><p>对于上述的几个可能阻塞主线程的操作，我们可以利用异步的子线程进行异步操作。</p><p>Redis启动之后，会使用操作系统提供的pthread_create函数创建3个子线程，分别是<strong>AOF日志写操作、键值对删除、文件关闭的异步执行</strong></p><p>主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会将这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但是此时这个删除还未被真正执行。后台子线程会从任务队列中读取任务之后才会开始实际的删除操作，并释放相应的内存空间。<strong>lazy free</strong>。这个删除键值对或清空数据库的操作并不会阻塞主线程，避免了对主线程的性能影响。<strong>注意这种异步删除会现在主线程中将其对应的全局键值对删除，然后对于内存的释放操作等放到任务队列中由子线程执行</strong></p><p>而且如果AOF日志配置选择的是everysec，主线程同样会将AOF写日志操作封装成一个任务放到任务队列中，后台子线程读取任务之后开始自行写入AOF日志，主线程同样也不需要一直等待AOF日志写完了。</p><p><img src="ae004728bfe6d3771c7424e4161e7969.jpg" alt="img"></p><p><strong>lazy free是Redis4.0之后提供的功能</strong>（在Redis6.0中，开启lazyfree-lazy-user-del，使用DEL和UNLINK就没有区别了）</p><ul><li>使用UNLINK命令来删除bigkey或者大集合。</li><li>使用FLUSHDB ASYNC或FLUSHALL ASYNC让子线程异步清空数据库。</li></ul><p>如果是4.0之前的Redis，在删除bigkey的时候可以用集合类型提供的SCAN命令读取数据，然后再进行删除。因为SCAN命令可以每次只读取一部分数据，可以避免一次性删除大量key给主线程带来的阻塞。对于Hash类型的bigkey来说，也可以使用HSCAN，然后使用HDEL。</p><p>由于聚合运算和从库加载RDB文件无法使用异步执行，但同样也有优化空间：</p><ol><li>集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；</li><li>从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</li></ol><h3 id="1-4-细说lazy-free"><a href="#1-4-细说lazy-free" class="headerlink" title="1.4 细说lazy-free"></a>1.4 细说lazy-free</h3><p><strong>lazy-free是Redis4.0新增的功能，默认是关闭的，需要手动开启。</strong></p><p>手动开启lazy-free时，有4个选项可以控制，分别对应不同场景下，要不要开启异步释放内存机制： </p><ul><li>lazyfree-lazy-expire：key在过期删除时尝试异步释放内存</li><li>lazyfree-lazy-eviction：内存达到maxmemory并设置了淘汰策略时尝试异步释放内存</li><li>lazyfree-lazy-server-del：执行RENAME&#x2F;MOVE等命令或需要覆盖一个key时，删除旧key尝试异步释放内存</li><li>replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存</li></ul><p>即使开启了lazy-free，如果直接使用DEL命令还是会同步删除key，只有使用UNLINK命令才会可能异步删除key。</p><p>这也是最关键的一点，上面提到开启lazy-free的场景，除了replica-lazy-flush之外，其他情况都只是<strong>可能</strong>去异步释放key的内存，并不是每次必定异步释放内存的。 </p><p><strong>开启lazy-free后，Redis在释放一个key的内存时，首先会评估代价，如果释放内存的代价很小，那么就直接在主线程中操作了，没必要放到异步线程中执行（不同线程传递数据也会有性能消耗）。</strong></p><p>什么情况才会真正异步释放内存？这和key的类型、编码方式、元素数量都有关系（详细可参考源码中的lazyfreeGetFreeEffort函数）：</p><ul><li>当Hash&#x2F;Set底层采用哈希表存储（非ziplist&#x2F;int编码存储）时，并且元素数量超过64个</li><li>当ZSet底层采用跳表存储（非ziplist编码存储）时，并且元素数量超过64个</li><li>当List链表节点数量超过64个（注意，不是元素数量，而是链表节点的数量，List的实现是在每个节点包含了若干个元素的数据，这些元素采用ziplist存储）</li></ul><p>只有以上这些情况，在删除key释放内存时，才会真正放到异步线程中执行，其他情况一律还是在主线程操作。也就是说String（不管内存占用多大）、List（少量元素）、Set（int编码存储）、Hash&#x2F;ZSet（ziplist编码存储）这些情况下的key在释放内存时，依旧在主线程中操作。 </p><p>可见，即使开启了lazy-free，String类型的bigkey，在删除时依旧有阻塞主线程的风险。所以，即便Redis提供了lazy-free，我建议还是尽量不要在Redis中存储bigkey。 </p><p>个人理解Redis在设计评估释放内存的代价时，不是看key的内存占用有多少，而是关注释放内存时的工作量有多大。从上面分析基本能看出，如果需要释放的内存是连续的，Redis作者认为释放内存的代价比较低，就放在主线程做。如果释放的内存不连续（大量指针类型的数据），这个代价就比较高，所以才会放在异步线程中去执行。</p><h2 id="第二章-底层数据结构"><a href="#第二章-底层数据结构" class="headerlink" title="第二章 底层数据结构"></a>第二章 底层数据结构</h2><p>Redis其实是存在数据库的概念的，比如默认的就有16个数据库，只不过我们平时都是默认使用0号数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    dict *dict;                 <span class="hljs-comment">/* The keyspace for this DB */</span><br>    dict *expires;              <span class="hljs-comment">/* Timeout of keys with a timeout set */</span><br>    dict *blocking_keys;        <span class="hljs-comment">/* Keys with clients waiting for data (BLPOP)*/</span><br>    dict *ready_keys;           <span class="hljs-comment">/* Blocked keys that received a PUSH */</span><br>    dict *watched_keys;         <span class="hljs-comment">/* WATCHED keys for MULTI/EXEC CAS */</span><br>    <span class="hljs-type">int</span> id;                     <span class="hljs-comment">/* Database ID */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl;          <span class="hljs-comment">/* Average TTL, just for stats */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor; <span class="hljs-comment">/* Cursor of the active expire cycle. */</span><br>    <span class="hljs-built_in">list</span> *defrag_later;         <span class="hljs-comment">/* List of key names to attempt to defrag one by one, gradually. */</span><br>    clusterSlotToKeyMapping *slots_to_keys; <span class="hljs-comment">/* Array of slots to keys. Only used in cluster mode (db 0). */</span><br>&#125; redisDb;<br></code></pre></td></tr></table></figure><h3 id="2-0-全局哈希表（hashtable）"><a href="#2-0-全局哈希表（hashtable）" class="headerlink" title="2.0 全局哈希表（hashtable）"></a>2.0 全局哈希表（hashtable）</h3><p><strong>概念】</strong></p><p>所谓的哈希表，其实就是一个保存键值对（key-value）的数据结构。</p><p>在Redis中，用了一张全局的哈希表来存取所有的key，它的优点在于能够以O(1)的复杂度快速的查询数据。但是随着key的值越来越多，难免会造成哈希冲突，而Redis解决哈希冲突的办法就是使用拉链法，将冲突的key构成一个链表。</p><p>但是如果链表过长了，它的查询效率就会退化成O(n)，因此在就会触发<strong>rehash</strong>进行扩容，对哈希表的大小进行扩展。 </p><p><strong>rehash】</strong></p><p>首先rehash的触发条件和<strong>负载因子</strong>有关，而负载因子：哈希表已经保存的节点数量&#x2F;哈希表的大小</p><ol><li>当负载因子大于等于1，并且Redis没有在执行bgsave命令（rdb全量快照）或者bgrewiteaof命令（aof重写），也就是没有执行RDB快照或者没有进行AOF重写的时候，就会进行rehash。</li><li>当负载因子大于等于5，此时说明哈希冲突非常严重了，不管有没有在进行RDB快照或者AOF重写都会强制性的rehash操作。</li><li>当负载因此小于0.1的时候，会触发<strong>缩容机制</strong>。同样也不会考虑AOF和RDB过程是否进行中。</li></ol><p><strong>那么Redis是如何进行rehash过程的呢？】</strong></p><p>首先我们得知道，全局哈希表的具体结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 源码文件 src\dict.h */</span><br><br><span class="hljs-comment">/* 哈希表</span><br><span class="hljs-comment"> * 每个字典都使用两个哈希表，以实现渐进式 rehash 。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    dictEntry **table;       <span class="hljs-comment">// 哈希表数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;      <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;  <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;      <span class="hljs-comment">// 该哈希表 已有节点数量</span><br>&#125; dictht;<br><br><span class="hljs-comment">// Redis 中的字典结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    dictType *type; <span class="hljs-comment">// 类型特定函数</span><br>    <span class="hljs-type">void</span> *privdata; <span class="hljs-comment">// 私有数据</span><br>    dictht ht[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 哈希表</span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* Rehash 索引，当不在进行Rehash时 值为 -1 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">/* 目前正在运行的安全迭代器的数量 */</span><br>&#125; dict;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">// 键</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>   <span class="hljs-comment">// 值</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p><img src="1620.png" alt="img"></p><p>可以看到，在Redis中的字典结构中，会有两个哈希表，同时考虑到在Redis数据量大的时候，进行rehash过程中可能会造成Redis线程阻塞，无法服务其他的请求，这样Redis就无法快速访问数据了，因此，Redis中的rehash采用的是<strong>渐进式rehash</strong>：</p><p>所谓的渐进式哈希，其实就是并不是集中式的一次性完成整个哈希过程，而是<strong>分多次、渐进式地完成的，Redis将数据的迁移任务分散到了每次的请求中。</strong></p><ol><li>在字典中维护了一个rehashidx变量，刚开始rehash的时候，它的值被设置为0，也就是表示第一个哈希表从索引0开始。</li><li>在每次的增删改查等redis操作的时候，都会去判断当前的rehashidx变量的值，如果不是-1就表示正在进行rehash，就会顺带的把rehashidx索引位置的元素迁移到第二个哈希表中。</li><li>随着操作的不断执行，最终会在某个时间点上，哈希表1中所有的键值对都会被rehash到哈希表2中，此时就将rehashidx重新设置为-1，表示rehash操作已经完成。</li></ol><p>同时，rehash被触发之后，Redis会按照一定的频率（100ms&#x2F;次）执行rehash操作。所以即使没有收到新请求，Redis也会<strong>定时执行一次rehash操作</strong>。缩短整个rehash的过程。而且每次执行时常不会超过1ms，以免对其他任务造成影响。</p><p><strong>rehash过程中的增删改查】</strong></p><p>在渐进式rehash过程中，字典会同时使用到两个哈希表，因此在此过程中，字典的增删改查等操作就会在两个哈希表上进行：比如说查找一个key，会先在第一个哈希表中查找，如果没找到就会去第二个哈希表中查找；而且对于新添加的字典的键值对，会一律保存到第二个哈希表。这样就能保证第一个哈希表中的键值对数量只减不增，并随着rehash操作的执行而最终变成空表。</p><h3 id="2-1-SDS（symbol-dynamic-string）"><a href="#2-1-SDS（symbol-dynamic-string）" class="headerlink" title="2.1 SDS（symbol dynamic string）"></a>2.1 SDS（symbol dynamic string）</h3><p>简单动态字符串，Redis中的String类型有什么特殊之处呢？</p><p>虽然Redis采用的是c语言进行实现，但是它并没有直接使用C语言中的char*数组来实现字符串，而是自己封装了一个名为Simple Dynamic String的数据结构来表示字符串。</p><p><strong>C语言字符串的缺陷】</strong></p><ol><li><strong>获取字符串长度的时间复杂度为O(N)：</strong>对于C语言来说，它的char*指针只是指向字符数组的起始位置，字符数组的结尾位置就用”\0”来表示。因此获取字符串长度的时候就得从头遍历到尾部。</li><li><strong>无法保存二进制数据：</strong>它的结尾是以”\0”字符标识，因此字符串中不能够包含”\0”字符，但是二进制流等数据中就有可能包含这种特殊字符。</li><li><strong>字符串操作函数不高效不安全：</strong>比如有缓冲区溢出的风险，有可能造成程序运行终止。</li></ol><p><strong>SDS的数据结构】</strong></p><ol><li><strong>len</strong>：记录字符串的长度，在获取长度的时候，只需返回这个变量即可。1字节，因此SDS的内容最大512MB</li><li><strong>alloc：</strong>分配给字符串的空间长度。在修改字符串的时候，就可以通过alloc-len计算出剩余的空间大小。如果剩余空间不满足修改需求，就会自动将SDS空间扩展至执行修改所需的空间大小（小于1MB翻倍扩容，大于1MB按照1MB扩容），然后才执行实际的修改操作。因此SDS就无需担心缓冲区溢出的风险。1字节</li><li><strong>flags：</strong>用来表示不同类型的SDS，分别为sdshdr5、8、16、32、54。1字节</li><li><strong>buf[]：</strong>字符数组，用来保存实际的数据，不仅可以保存字符串，也可以保存二进制数据。’\0’会额外占用1字节</li></ol><p><strong>5种类型的SDS】</strong></p><p>上述的SDS是Redis6.x的结构，在Redis3.0的时候它的结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">// 记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span><br>    <span class="hljs-comment">// 注意末尾的&#x27;\0&#x27;并不会计算在这个长度中</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br>    <span class="hljs-comment">// 记录buf数组中未使用字节的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br>    <span class="hljs-comment">// char数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><p>但是Redis中不同长度的字符串占用的头部是相同的，造成空间的浪费，因此就有了Redis6中的SDS模型（在3.2的时候变化的）。</p><p>上述说到，SDS中有一个flags标志位，用来标志不同类型的SDS，那么他们的区别是什么呢？</p><p><strong>数据结构中的len和allo成员的数据类型不同。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span><br><span class="hljs-comment"> * However is here to document the layout of type 5 SDS strings. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>之所以这么设计是为了能够<strong>灵活保存不同大小的字符串，从而有效节省内存空间</strong>，当保存小字符串的时候，结构体占用的空间也比较小。</p><p>除了设置不同类型的结构体，Redis在编程上还使用了专门的编译优化来节省内存空间，即在struct声明了<strong>attribute((packed))<strong>，作用是</strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p><strong>SDS优点】</strong></p><ol><li>使用O1复杂度获取字符串长度</li><li>放置缓冲区溢出，因为扩容机制</li><li>减少字符串修改带来的内存分配次数：<strong>空间预先分配</strong>和<strong>惰性空间释放机制</strong>（当Redis需要减少SDS字符串长度的时候，redis并不会直接释放多余的空间，而是使用free字段进行记录，以便下一次增加长度的时候使用。当然如果有需要的话，redis底层会自动的回收这部分空间，而不用担心这部分空间的冗余）。</li><li>二进制安全。</li></ol><h3 id="2-2-压缩列表（ziplist）"><a href="#2-2-压缩列表（ziplist）" class="headerlink" title="2.2 压缩列表（ziplist）"></a>2.2 压缩列表（ziplist）</h3><p>在一般的数组中，会要求我们每个元素的大小相同，如果我们想要存储不同长度的字符串，就需要以最大长度的字符串的大小为数组元素的大小，就会非常浪费空间。</p><p>但是数组是占用连续空间的，这种结构能很好的利用CPU缓存访问数据，提升效率，因此我们就可以去将数组进行压缩，让他同时兼顾效率和空间。</p><p><img src="9587e483f6ea82f560ff10484aaca4a0.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ziplist</span>&#123;</span><br>    <span class="hljs-comment">/*ziplist分配的内存大小，在对ziplist进行内存重分配或者计算zlend位置时使用*/</span><br>    <span class="hljs-type">uint32_t</span> zlbytes;<br>    <span class="hljs-comment">/*达到尾部的偏移量*/</span><br>    <span class="hljs-type">uint32_t</span> zltail_offset;<br>    <span class="hljs-comment">/*存储元素实体个数*/</span><br>    <span class="hljs-type">uint16_t</span> zllength;<br>    <span class="hljs-comment">/*存储内容实体元素*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* content[];<br>    <span class="hljs-comment">/*尾部标识， 0xFF，十进制255*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> zlend;<br>&#125;ziplist;<br><br><span class="hljs-comment">// redis对压缩列表中节点的定义如下：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlensize; <span class="hljs-comment">// 存储上一个节点长度的数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen;     <span class="hljs-comment">// 上一个节点的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize;        <span class="hljs-comment">// 当前节点长度的数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;           <span class="hljs-comment">// 当前节点的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize;    <span class="hljs-comment">// 当前节点的头部大小， = prevrawlensize + lensize</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding;      <span class="hljs-comment">// 编码方式，ZIP_STR_*或ZIP_INT_*</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p;            <span class="hljs-comment">// 指向节点内容的指针</span><br>&#125; zlentry;<br></code></pre></td></tr></table></figure><p>虽然定义了这个结构体，但是<strong>根本就没有使用zlentry这个结构来作为压缩列表中用来存储数据节点中的结构</strong>，因为造成的空间浪费太严重了。</p><p><strong>真正的节点结构】</strong></p><p><img src="image-20220429165414706.png" alt="image-20220429165414706"></p><ol><li><strong>prev_entry_len</strong>：以字节为单位，记录了压缩列表中前一个节点的长度。该属性的长度可以是<strong>1字节或者5字节</strong><ul><li>如果前一个节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一个节点的长度就保存在这一个字节里面</li><li>如果前一个节点的长度大于等于254字节，那么属性的长度就为5字节；其中属性的第一字节会被设置为0xFE（十进制254，作为这种情况的一个标记），而之后的四个字节则用于真正保存前一节点的占用的字节数。</li></ul></li><li><strong>encoding：</strong>记录了节点的value（或者说content）属性所保存的类型以及长度。</li></ol><p>在压缩列表中，如果要查找定位第一个元素和最后一个元素，就可以通过表头三个字段直接定位，复杂度为O1。</p><p><strong>整数数组和压缩列表在查找时间复杂度上并没有很大的优势，那么Redis为什么还会将他们作为底层数据结构？】</strong></p><ol><li>内存利用率：数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是基于内存的数据库，因此要尽可能的提高内存的利用率。</li><li>数组对CPU高速缓存更加的友好。Redis在设计的过程中，集合数据元素在较少的情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，就会转为哈希和跳表数据结构存储，保证查询效率。</li><li>Redis底层使用数组和压缩链表对数据大小限制在64字节以下。当大于64字节会改变存储的数据结构。</li></ol><p><strong>总结】</strong></p><ol><li>压缩列表在空间利用率上极高，每个entry最多只有6字节的浪费</li><li>底层无链表结构，通过内存偏移量获取next或last节点的位置</li><li>在插入和删除的时候会有相当大的概率出现<strong>连锁更新</strong>，因此在使用的时候尽量保证所存的value位数相同。</li></ol><p><strong>连锁更新】</strong></p><p>由于表示长度的字节大小不一样，当新节点的插入可能会导致下一个节点原本存放表示上一个节点的长度的空间大小不够，导致需要扩容这一字段。相应的该字段会由一个字节扩容到五个字节，四个字节的长度变化，当发生变化的节点原本的长度在250-253之间的时候，将会导致下一个节点存储上一个节点长度的空间发生变化，引起一个连锁扩容的情况，这一情况会一直持续，直到到达一个不需要扩容的节点为止。</p><h3 id="2-3-紧凑列表（listpack）"><a href="#2-3-紧凑列表（listpack）" class="headerlink" title="2.3 紧凑列表（listpack）"></a>2.3 紧凑列表（listpack）</h3><p>我们知道的是，ziplist有着一个致命的缺陷，那就是<strong>连锁更新</strong>，而listpack是Redis5作为ziplist的替代品而引入的，在Redis6以后就已经作为哈希结构的基础底层结构了。</p><p>那么listpack相对于ziplist有什么优势呢？</p><p><img src="20210614200346588.png" alt="在这里插入图片描述"></p><p>首先listpack从<strong>结构上</strong>相对于ziplist，少了一个tail_offset（达到尾部的偏移量）字段，这个字段的作用是为了方便找到最后一个节点然后进行反方向的遍历。</p><p>新的listpack节点的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&lt;var&gt; encoding;<br>optional byte[] content;<br><span class="hljs-type">int</span>&lt;var&gt; length;<br></code></pre></td></tr></table></figure><p>相对于ziplist的定义，它记录的不再是前一个节点的长度，而是自己的长度。同时它将记录自己的长度放到了节点的尾部。</p><ol><li>不再需要zltail_offset属性也可以快速定位到最后一个节点。只需要使用listpack的总长度 - 最后一个节点的长度。</li><li><strong>每个节点记录自己的长度，当本节点的值发生了改变，只需要更改自己的长度即可，不再需要更改别的节点的属性，解决掉了连锁更新问题</strong></li><li>listpack的内存使用率上逊色于ziplist</li><li>代码的实现或复杂度上面，极简且高效</li></ol><h3 id="2-4-快速列表（quicklist）"><a href="#2-4-快速列表（quicklist）" class="headerlink" title="2.4 快速列表（quicklist）"></a>2.4 快速列表（quicklist）</h3><p>对于Redis中的双向链表来说，每个节点除了数据部分，都要额外的16字节的内存来表示prev和next（64bit系统的指针为8个字节），而且每个节点的内存都是单独分配的，容易加剧内存的碎片化，影响内存管理效率。</p><p>Redis3.2之后对于List类型的value来说，<strong>使用quicklist代替了ziplist和linkedlist。</strong></p><p>对于quicklist来说，它其实是ziplist和linkedlist的结合体，它将linkedlist按段切分，每一段使用ziplist来紧凑存储，多个ziplist之间使用双向指针连接起来。</p><p>它相对于linkedlist来说，<strong>进一步压缩了空间</strong></p><p><img src="QuickList.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    quicklistNode *head; <span class="hljs-comment">// 头节点</span><br>    quicklistNode *tail; <span class="hljs-comment">// 尾节点</span><br>    <span class="hljs-comment">// 所有的节点的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span><br>    <span class="hljs-comment">// quicklistNode的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span><br>    <span class="hljs-comment">// 16bit，ziplist大小设置，存放list-max-ziplist-size参数的值</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS;              <span class="hljs-comment">/* fill factor for individual nodes */</span><br>    <span class="hljs-comment">// 16bit，节点压缩深度设置，存放lits-compress-depth参数的值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress : QL_COMP_BITS; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS;<br>    quicklistBookmark bookmarks[];<br>&#125; quicklist;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl; <span class="hljs-comment">// 如果当前节点的数据没有压缩，那么它指向一个ziplist，否则指向一个quicklistLZF结构</span><br>    <span class="hljs-comment">// zl指向的ziplist总大小，包括bytes、zltail、zllen、zlend和各个数据项。</span><br>    <span class="hljs-comment">// 如果ziplist被压缩了，这个sz同样也是压缩前的ziplist大小。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <br>    <span class="hljs-comment">// ziplist里面包含的数据项个数，16bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span><br>    <span class="hljs-comment">// 1表示没有压缩，2表示被压缩了，而且用的是LZF压缩算法</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span><br>    <span class="hljs-comment">// 预留字段，本来的设计是用来表明一个quicklistNode下面是直接存数据还是使用ziplist存储数据，或者用其它的结构来存。</span><br>    <span class="hljs-comment">// 但是目前只是固定的值2，表示使用ziplist作为数据容器。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can&#x27;t compress; too small */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span><br>&#125; quicklistNode;<br><br><span class="hljs-comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span><br><span class="hljs-comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span><br><span class="hljs-comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span><br><span class="hljs-comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span><br><span class="hljs-comment">// 表示一个被压缩过的ziplist</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistLZF</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span><br>    <span class="hljs-type">char</span> compressed[]; <span class="hljs-comment">// 柔性数组，存放压缩后的ziplist字节数组。</span><br>&#125; quicklistLZF;<br></code></pre></td></tr></table></figure><p>对于quicklist的插入来说：</p><ol><li>如果是往头节点（尾节点）插入，<ol><li>如果此时对应的ziplist的容量足够，就直接插入到对应的ziplist中；</li><li>如果超出了容量限制，就会创建一个新的quicklistNode，这个新的node里面又会包含新的ziplist，而新数据就存储在这里面，并且这个新的quicklistNode就会插入到新的quicklist双向链表中。</li></ol></li><li>如果是指定位置插入数据：<ol><li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li><li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li><li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li><li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li></ol></li></ol><p>如果是quicklist的查询，因为每个quicklistNode其实记录了内部的ziplist的entry的个数，因此就可以通过index找到是哪个ziplist，然后进而找到对应的值。</p><h3 id="2-5-跳表（skiplist）"><a href="#2-5-跳表（skiplist）" class="headerlink" title="2.5 跳表（skiplist）"></a>2.5 跳表（skiplist）</h3><p>zset类型在数据量较多或者成员是比较长的字符串的时候，Redis会使用skiplist作为有序集合的底层实现。</p><p><strong>以空间换时间的方式提升了查找速度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    sds ele; <span class="hljs-comment">// </span><br>    <span class="hljs-type">double</span> score; <span class="hljs-comment">// 分数</span><br>    <span class="hljs-comment">// 后退指针，指向位于当前节点的前一个节点，从表尾向表头遍历使用</span><br>    <span class="hljs-comment">// 每次只能往后退一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span> <span class="hljs-comment">// </span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span> <span class="hljs-comment">// 分别指向skiplist的头、尾节点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length; <span class="hljs-comment">// skiplist的长度，也就是目前包含节点的数量</span><br>    <span class="hljs-type">int</span> level; <span class="hljs-comment">// 目前的skiplist中，层级最大的那个节点的层数</span><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p><img src="Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="Redis跳跃表"></p><p><a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)</a></p><p>我们的查找复杂度是O(logn)，空间复杂度O(n)。</p><p>对于查找过程，首先从最高层索引开始看，如果发现它的下一个比目标值要大，就会索引下沉，然后继续比较，直到到达最底层的链表。</p><p>对于插入过程，就有很大的讲究了：</p><ul><li>如果我们每次插入元素之后都不更新索引，那么时间久了之后，就可能会导致skiplist的效率退化至O(N)。</li><li>如果我们按照严格的索引要求，那么每次插入数据都得重构索引，效率大大降低。</li><li>在数据量大的时候，可以如此分析：有2&#x2F;n的数据会作为一级索引，有4&#x2F;n的数据作为二级索引，有8&#x2F;n的数据作为三级索引。因此就可以使用概率学，随机抽取2&#x2F;n的数据作为一级索引，依次内推。在数据量大的时候，趋向于稳定，这也是我们选择的方向。</li></ul><p>进一步说：在插入一个元素的时候，我们可以通过一个随机函数返回它的概率，也就是说，这个新插入的节点有1&#x2F;2的几率建立一级索引，1&#x2F;4的概率建立二级索引，1&#x2F;8的概率建立三级索引…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> threshold = ZSKIPLIST_P*RAND_MAX;<br>    <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (random() &lt; threshold)<br>        level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回1表示插入该元素不需要建立索引（1&#x2F;2）</li><li>返回2表示插入该元素需要建立一级索引（1&#x2F;4）</li><li>依次内推。。</li></ul><p>那么疑惑来了，之前不是说要让建立一级索引的概率为1&#x2F;2吗？怎么这里又说等到该方法以1&#x2F;4的概率返回2的时候才建立一级索引？首先我们得知道的是，<strong>建立二级索引的时候同时也会去创建一级索引</strong>，因此只要不建立索引的概率为1&#x2F;2，那么剩下的能建立一级索引的概率就为1&#x2F;2了，也就是建立一级索引的概率其实是将所有返回值大于等于2的值加起来，趋向于1&#x2F;2。</p><p>对于元素插入的时间复杂度来说，最坏的是元素x要插入到每层索引中，所以插入数据到各层索引，最坏的时间复杂度为O(logn)。</p><h3 id="2-6-整数集合（intset）"><a href="#2-6-整数集合（intset）" class="headerlink" title="2.6 整数集合（intset）"></a>2.6 整数集合（intset）</h3><p><strong>底层结构】</strong></p><p>当集合类型的元素都是整数并且元素个数不超过512个时，会使用intset作为底层数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">// 整数集合中的每个元素都是contents数组中的一个数组项</span><br>&#125; intset;<br><br><span class="hljs-comment">// encoding表示contents中存储的元素的类型：</span><br><span class="hljs-comment">/* Note that these encodings are ordered, so:</span><br><span class="hljs-comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span><br></code></pre></td></tr></table></figure><p>数组contents的类型为int8_t，但是不会保存任何int8_t类型的数据，它保存的是encoding属性对应的类型的数据。</p><p><strong>升级过程】</strong></p><p>为了解决内存，如果intset存储的是16位（-32768~32767）的整数，那么就可以使用int16_t的类型来存储数据。但是如果此时添加的数据超过了16位能表示的范围，于是int16_t就存储不下了，这个时候就得<strong>升级</strong>，将数据类型设置为int32_t。</p><ol><li>根据新元素的类型扩展数组的空间</li><li>将其他的数据类型转换为与新元素的数据类型相同</li><li>将新元素插入到数据的合适位置，并更新encoding属性的值。</li></ol><p><strong>intset提供的升级过程增加了数组操作的灵活性并且能够达到节约内存的效果，但是它并没有提供降级操作</strong></p><p><img src="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis.png" alt="深入理解Redis"></p><p><strong>优点】</strong></p><ol><li><strong>灵活性更高：</strong>intset可以自动升级底层数组来适应新元素，而不必担心出现类型错误。</li><li><strong>节约内存：</strong>如果想要同时保存int16、32、64位的整数，就可以直接使用64位类型的数组作为intset的底层实现，但是如果intset里面都是16位的数据，而暂时没有出现64位的数据，就会造成空间的浪费。</li></ol><h3 id="2-7-redisObject"><a href="#2-7-redisObject" class="headerlink" title="2.7 redisObject"></a>2.7 redisObject</h3><p>Redis采用redisObject结构来统一几种不同的数据类型，这样所有的数据类型就都可以通过相同的形式在函数间传递而不用使用特定的类型结构。同时为了识别不同的数据类型，redisObject中还定义了type和encoding来对不同的数据类型加以区分。简单来说，redisObject就相当于这些数据类型的父类，可以在函数间传递时隐藏具体的类型信息。</p><p><strong>前面说到的全局哈希表，在dictEntry中会有一个指针val指向数据对象的地址，而这个val指向的地址的内存空间其实就是一个redisObject！</strong></p><p>dictEntry 结构，表示哈希表节点的结构，结构里存放了 void * key 和 void * value 指针， *key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p><p>void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><p><img src="2355823-20211228161425350-2025781052.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 当前value对象的一个数据结构</span><br>   <span class="hljs-comment">// string、hash、set、list、zset、stream、bitmaps、typeloglogs、geo</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>; <br>    <span class="hljs-comment">// 当前值对象底层存储的编码格式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 记录对象最后一次访问时间</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">/* LRU time (relative to global lru_clock) or</span><br><span class="hljs-comment">                            * LFU data (least significant 8 bits frequency</span><br><span class="hljs-comment">                            * and most significant 16 bits access time). */</span><br>    <span class="hljs-comment">// 记录当前对象被引用的次数，为0表示可以安全回收当前对象</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 真实存储数据的指针。</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br><br><span class="hljs-comment">// 下面是Redis所拥有的编码格式</span><br><span class="hljs-comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span><br><span class="hljs-comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span><br><span class="hljs-comment"> * is set to one of this fields for this object. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="hljs-comment">/* Raw representation */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_INT 1     <span class="hljs-comment">/* Encoded as integer */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_HT 2      <span class="hljs-comment">/* Encoded as hash table */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="hljs-comment">/* Encoded as zipmap */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="hljs-comment">/* No longer used: old list encoding. */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="hljs-comment">/* Encoded as ziplist */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="hljs-comment">/* Encoded as intset */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="hljs-comment">/* Encoded as skiplist */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="hljs-comment">/* Embedded sds string encoding */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="hljs-comment">/* Encoded as linked list of ziplists */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="hljs-comment">/* Encoded as a radix tree of listpacks */</span></span><br></code></pre></td></tr></table></figure><h2 id="第三章-基本数据类型"><a href="#第三章-基本数据类型" class="headerlink" title="第三章 基本数据类型"></a>第三章 基本数据类型</h2><h3 id="3-0-String"><a href="#3-0-String" class="headerlink" title="3.0 String"></a>3.0 String</h3><p><strong>底层结构】</strong></p><p>字符串对象是Redis中最基本的数据类型，它的内部实现是通过<strong>int和SDS实现</strong></p><p><strong>String类型的内部编码有3种：int、raw、embstr</strong></p><ol><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换为long），并且将字符串对象的编码设置为int。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值大于44字节，那么字符串对象将使用一个SDS来保存这个字符串，并将对象的编码设置为raw。</li><li>如果字符串值大小小于或等于44字节，那么字符串对象将使用一个SDS保存这个字符串值，并将对象的编码格式设置为embstr，注意此时redisObject和SDS是连续存放的。</li></ol><p><strong>上述的44字节随着Redis版本的变化也同时变化着，最新的一般为44字节（redis3.2之后从39变为44）</strong></p><p>redisObject的type（4bits）、encoding（4bits）、lru（24bits）、refcount（4bytes）、ptr（8bytes，在64位系统中），于是redisObject就占用了16字节。</p><p>而SDS的capacity（1byte）、alloc（1byte）、flags（1byte），加上之前的就一共19字节了，因此就是64-16-3-1 &#x3D; 44字节，这个1字节是结束符”\0”。</p><p><strong>下面的图像对于redisObject部分有了简化</strong></p><p><img src="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-String%E5%AF%B9%E8%B1%A1.png" alt="深入理解Redis-String对象"></p><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，我们可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>。而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处。</p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数</li><li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能</li></ul><p><strong>应用场景】</strong></p><ol><li><strong>作为缓存层</strong></li><li>计数器、限速器、分布式ID</li><li>分布式系统共享session，例如SpringSession</li><li>二进制存储</li></ol><h3 id="3-1-List"><a href="#3-1-List" class="headerlink" title="3.1 List"></a>3.1 List</h3><p><strong>底层结构】</strong></p><p>在Redis3.2之前，List类型的底层结构有两种：</p><ul><li><strong>压缩列表：</strong>当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中的每个元素的值都小于list-max-ziplist-value配置（默认64字节），Redis会选用压缩列表作为内部的实现来减少内存的使用。</li><li><strong>链表：</strong>当列表类型无法满足压缩列表所需要的条件的时候，Redis就会使用链表作为内部实现。</li></ul><p><strong>在Redis3.2开始，List类型的底层使用快速列表（quicklist）代替了ziplist和linkedlist</strong></p><p><strong>应用场景】</strong></p><ol><li><p><strong>消息队列：</strong>列表类型可以相当于队列去使用，生产者使用lpush将消息添加到list中，然后消费者就可以使用brpop从list的头部去拿消息进行消费。</p></li><li><p><strong>用户订阅店铺：</strong>比如用户C订阅了店铺A和B，然后他们分别发送了两篇文章，为11和22。只要他们发送了文章，就会安装到C的list里面</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">lpush likearticle:CID <span class="hljs-number">11</span> <span class="hljs-number">22</span> // 文章推送<br><span class="hljs-keyword">lrange</span> likearticle:CID <span class="hljs-number">0</span> <span class="hljs-number">10</span> // 查看用户C订阅的全部推文，只显示<span class="hljs-number">10</span>条，类似分页<br></code></pre></td></tr></table></figure></li><li><p>lpush + lpop &#x3D; stack</p></li><li><p>lpush + rpop &#x3D; queue</p></li><li><p>lpush  + ltrim &#x3D; 有限集合</p></li><li><p>lpush + brpop &#x3D; 消息队列</p></li><li><p><strong>在电商网站的商品评论中，需要统计评论列表中的最新评论。</strong></p><p>既然要统计最新评论，那么就必须要考虑选择的数据类型是有序的，而我们的List就是有序的（插入顺序有序），因此我们可以维护一个List，然后将最新的评论插入到List的头部：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> List中当前的评论是&#123;A,B,C,D,E,F&#125;<br>LRANGE product1 <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> ABC<br>LRANGE product2 <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-regexp">//</span> DEF<br><span class="hljs-regexp">//</span> 如果在展示第二页之前，商品新增了一条评论G，List就变成了&#123;G,A,B,C,D,E,F&#125;<br><span class="hljs-regexp">//</span> 再次执行LRANGE product2 <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-regexp">//</span> CDE<br><span class="hljs-regexp">//</span> 发现评论C再次被展示出来了。<br></code></pre></td></tr></table></figure><p>关键在于List是通过元素在List中的位置来排序的，如果有新元素插入，就会导致原先的元素在List中的位置发生了变化，要是想解决这个问题，就可以去使用ZSet。</p></li></ol><h3 id="3-2-Hash"><a href="#3-2-Hash" class="headerlink" title="3.2 Hash"></a>3.2 Hash</h3><p><strong>底层结构】</strong></p><p>Redis中的Hash类型，内部同样也有两种编码格式：ziplist和hashtable，当然在redis6之后用listpack代替了ziplist。</p><p>和3.1说的List类型一样，当Hash中的数据不满足ziplist的要求的时候，就将转化为hashtable，因为此时<code>ziplist</code>的读写效率会下降，而<code>hashtable</code>的读写时间复杂度为O（1）。</p><p><strong>应用场景】</strong></p><ol><li><p>相当于Java里面的Map&lt;String, Map&lt;Object, Object&gt;&gt;，可以用来实现早期的<strong>购物车</strong>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">新增商品 hset shopcar:uid1024 <span class="hljs-number">334488</span> <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> 用户<span class="hljs-number">1024</span>添加一件<span class="hljs-number">334488</span>的商品到购物车<br>增加商品数量 hincrby shopcar:uid1024 <span class="hljs-number">334488</span> <span class="hljs-number">1</span><br>商品总数 hlen shopcar:uid1024<br>全部选择 hgetall shopcar:<span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置中心的配置项</strong></p></li><li><p><strong>计数器：</strong></p><p>用于记录网站每一天、一月、一年的访问量</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HINCRBY</span> MyBLOG <span class="hljs-number">202204</span> <span class="hljs-number">1</span> // 记录<span class="hljs-number">2022</span>年<span class="hljs-number">4</span>月份的访问量<br><span class="hljs-attribute">HINCRBY</span> MyBLOG <span class="hljs-number">202205</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 也可以用于记录商品的好评数量、差评数量等</p><p> 也可以实时记录当天的在线的人数。</p></li></ol><h3 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h3><p><strong>底层结构】</strong></p><p>Set类型是一个无序且唯一的键值对集合。它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储232-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p><p>集合类型的内部编码有两种：</p><ul><li><strong>intset（整数集合）</strong>：当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会采用intset来作为集合的内部实现，从而减少内存的使用</li><li><strong>hashtable</strong>：当集合类型无法满足intset的条件时，会使用hashtable作为集合的内部实现。</li></ul><p><strong>应用场景】</strong></p><p>集合的主要几个特性，<strong>无序、不可重复、支持并交差等操作</strong>。因此集合类型比较适合用来数据<strong>去重和保障数据的唯一性</strong>，还可以用来统计多个<strong>集合的交集、错集和并集</strong>等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p>Set的差集、并集和交集的计算复杂度较高，<strong>在数据量大的情况下，如果直接执行这些计算，会导致Redis实例阻塞</strong>。</p><p>因此可以<strong>从主从集群中选择一个从库，让它专门负责聚合计算；</strong>注意：SUNIONSTORE、SDIFFSTORE、SINTERSTORE做并集、差集、交集时，都会在Redis中生成一个新key，而从库默认是readonly不可写的，所以这些命令只能在主库使用。想在从库上操作，可以使用SUNION、SDIFF、SINTER，这些命令可以计算出结果，但不会生成新key。</p><p>如果是在集群模式使用多个key聚合计算的命令，一定要注意，因为这些key可能分布在不同的实例上，多个实例之间是无法做聚合运算的，这样操作可能会直接报错或者得到的结果是错误的！</p><p><strong>或者把数据读取到客户端，在客户端完成聚合计算。</strong>但是这个可能会造成大量的网络开销。</p><p>也可以将这些统计数据与在线业务数据拆分开，实例单独部署，防止在做统计操作时影响到在线业务。</p><ol><li><p><strong>店铺抽奖活动：</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">用户参加抽奖 sadd action UID1024<br>显示已经有多少人参与了 scard action<br>抽奖，从<span class="hljs-keyword">set</span>中选n个人 srandmember <span class="hljs-comment">key 2</span> 随机抽<span class="hljs-comment">2</span>人，不删除；<br>随机抽3人，删除 spop <span class="hljs-comment">key 3</span> // <span class="hljs-comment">spop</span>命令：随机移除并返回集合中一个或多个元素<br></code></pre></td></tr></table></figure></li><li><p><strong>给商品点赞</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">新增点赞 sadd productId <span class="hljs-built_in">UID1</span> <span class="hljs-built_in">UID2</span><br>取消点赞 srem productId <span class="hljs-built_in">UID1</span><br>展示所有点赞过的用户 smembers productId<br>点赞用户数统计 scard productId<br>判断某个人是否对该商品点过赞 sismember productId <span class="hljs-built_in">UID1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-ZSet"><a href="#3-4-ZSet" class="headerlink" title="3.4 ZSet"></a>3.4 ZSet</h3><p><strong>内部结构】</strong></p><p>相对于Set来说多了一个排序属性score（分值），ZSet同样不允许成员重复（score可以重复），但是它可以利用score对ZSet中的元素进行排序。</p><p>有序集合使用<strong>ziplist或skiplist</strong>组成</p><ul><li>当有序集合保存的元素个数小于128（Hash和List都是默认512）并且每个元素的长度都小于64字节，采用ziplist进行存储。</li><li>如果不能满足上序条件，采用skiplist进行存储。</li></ul><p><strong>应用场景】</strong></p><ol><li><p><strong>排行榜</strong>：比如文章点赞排行榜</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">zincrby user:ranking articleID <span class="hljs-number">10</span> <span class="hljs-regexp">//</span> 新增十个赞<br>zincrby user:ranking articleID -<span class="hljs-number">1</span> <span class="hljs-regexp">//</span> 取消点赞<br>zscore user:ranking articleID <span class="hljs-regexp">//</span> 查看指定文章的点赞数<br>zrevrangebyrank user:ranking <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-regexp">//</span> 点赞数最多的十篇文章<br></code></pre></td></tr></table></figure></li><li><p><strong>电话号码排序或者姓名排序：</strong>使用ZRANGEBYLEX和ZREVRANGEBYLEX指令（分数相同）</p></li><li><p><strong>在电商网站的商品评论中，需要统计评论列表中的最新评论</strong></p><p>我们可以假设越新的评论权重越大，相对于List会使数据下标发生改变，zset中的数据的score是不变的，分页时记录上一次的范围起始值就可以了。具体如下：</p><p>假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论，权重分别为 10，9，8，7，6，5）。 在展示第一页的 3 个评论时，按照权重排序，查出 ABC。 展示第二页的 3 个评论时，按照权重排序，查出 DEF。 如果在展示第二页前，又产生了一个新评论 G，权重为 11，排序为 {G, A, B, C, D, E, F}。 再次查询第二页数据时，权重还是会以 10 为准，逻辑上，第一页的权重还是 10，9，8。 查询第二页数据时，可以查询出权重等于 7，6，5 的数据，返回评论 DEF。 当想查询出最新评论时，需要以权重 11 为准，第一页数据的权重就是 11，10，9，返回评论 GAB。 再次查询第二页数据时，以权重 11 为准，查询出评论 CDE。</p></li></ol><h3 id="3-5-Bitmap"><a href="#3-5-Bitmap" class="headerlink" title="3.5 Bitmap"></a>3.5 Bitmap</h3><p>Bitmap本身是用String类型作为底层数据结构实现的一种统计二值状态的数据类型。String类型会保存为二进制的字节数组，所以Redis就是将字节数组的每个bit位利用起来，用来表示一个元素的二值状态。</p><p>Bitmap 提供了 GETBIT&#x2F;SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 SETBIT 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。</p><p><strong>应用场景】</strong></p><p>我们可以利用bitmap进行签到统计，比如我们要统计ID为3000的用户在2022年5月份的签到情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETBIT</span> uid:sign:<span class="hljs-number">3000</span>:<span class="hljs-number">202205</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> // 记录该用户<span class="hljs-number">2022</span>年<span class="hljs-number">5</span>月<span class="hljs-number">4</span>号签到<br><span class="hljs-attribute">GETBIT</span> uid:sign:<span class="hljs-number">3000</span>:<span class="hljs-number">202205</span> <span class="hljs-number">3</span> // 检查是否签到<br><span class="hljs-attribute">BITCOUNT</span> uid:sign:<span class="hljs-number">3000</span>:<span class="hljs-number">202205</span> // 统计该用户<span class="hljs-number">5</span>月份签到次数<br></code></pre></td></tr></table></figure><p>或者有这么一个需求，统计出1亿用户最近连续签到十天的用户个数？我们可以将每一天都作为一个key，然后每个key的value是一亿长度的bitmap。只需要将这10个bitmap做与操作，得到的结果是一个bitmap，然后就可以统计这个bitmap的1的个数，就是连续签到十天的用户总数了。总开销大概是10^8&#x2F;8&#x2F;1024&#x2F;1024*10 &#x3D; 120MB</p><h3 id="3-6-HyperLogLog"><a href="#3-6-HyperLogLog" class="headerlink" title="3.6 HyperLogLog"></a>3.6 HyperLogLog</h3><p>它是一种用于统计基数（不重复元素）的数据集合，当集合元素数量非常多的时候，它计算基数所需要的空间总是固定的，而且很小。</p><p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为它只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p><p>不过HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。伯努利实验</p><p><strong>应用场景】</strong></p><p><strong>在网页访问记录中，需要统计独立访客（Unique Visitor，UV）量。</strong>也就是对于一个网页，一个用户一天内的多次访问只能算作一次，我们可以使用set或者hash（HSET page1:uv  userID 1）去做，但是当数据量比较大的时候，消耗的内存是非常大的。</p><p>于是我们使用HyperLogLog来作为存储结构</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">PFADD page1:uv user1 user2 user3 user4 user5 <span class="hljs-regexp">//</span> 把访问页面的每个用户都添加到HyperLogLog中<br>PFCOUNT page1:uv <span class="hljs-regexp">//</span> 获取该uv值<br></code></pre></td></tr></table></figure><h2 id="第四章-持久化机制"><a href="#第四章-持久化机制" class="headerlink" title="第四章 持久化机制"></a>第四章 持久化机制</h2><p>Redis是基于内存的数据库，而服务器一旦宕机就会导致内存中的数据全部丢失，因此Redis的持久化机制是非常重要的。</p><h3 id="4-1-AOF"><a href="#4-1-AOF" class="headerlink" title="4.1 AOF"></a>4.1 AOF</h3><p>对于MySQL的日志来说，它是有一个WAL机制，也就是先将修改的数据记录到日志中，再去执行指令。但是对于Redis来说，恰好相反。先将数据写入内存之后再记录日志。</p><ol><li><strong>可以避免额外的检查开销：</strong>Redis在进行记录日志的时候，并不会去进行语法检查。所以如果采用日志先写的方式，万一这条语句是错误的，就会导致日志恢复数据的时候出错。而采用日志后写的方式，会让系统先执行命令，只有命令执行成功了才会去记录日志。</li><li><strong>写之后再记录日志，不会阻塞当前的写操作。</strong></li></ol><p>但是这样可能会导致我们记录写成功了，此时服务器宕机，还没来得及进行日志的持久化，就会导致<strong>数据的丢失。</strong></p><p>再者AOF日志也是在主线程中执行的，如果在日志写入磁盘时，磁盘写压力大，就会导致写盘很慢，<strong>进而导致后续的操作无法执行了</strong></p><p><strong>三种写回策略】</strong></p><table><thead><tr><th>配置项</th><th>写回时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步写回</td><td>可靠性高，数据基本不丢失</td><td>每个写命令都要落盘，性能影响大</td></tr><tr><td>Everysec</td><td>每秒写回</td><td>性能适中</td><td>宕机时丢失1秒内的数据</td></tr><tr><td>No</td><td>操作系统控制的写回</td><td>性能好</td><td>宕机时丢失数据较多</td></tr></tbody></table><p>对于Everysec来说，每个写命令执行完，只是先将日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。</p><p>对于No来说，每个写命令执行完，只是先把日志写入AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回磁盘。</p><p><strong>AOF重写机制】</strong></p><p>AOF日志过大的时候会造成性能问题：</p><ol><li>文件系统本身会对文件大小有限制</li><li>文件过大，往里面追加记录的时候，效率会降低</li><li>宕机之后恢复数据时，恢复过程非常缓慢</li></ol><p>AOF文件采用追加的方式，记录逐一接收到的写命令。因此一个键值对可能会进行多次的写，因此一个键值对可能会有很多的记录。而在重写的过程中，会根据这一条键值对的最新状态，为他生成对应的写入命令。这样一个键值对在日志中只需要用一条命令就可以了。</p><p>AOF的重写采用<strong>后台子进程bgrewriteaof</strong>来完成的，避免阻塞主线程导致性能下降。</p><p>每次执行重写的时候，主线程会fork出一个子进程。此时fork会把主线程的内存拷贝一份给子进程（其实并不是拷贝，详情见下面的注意事项），这里面就包含了数据库的最新数据。然后子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>但是此时主线程并未阻塞，因此还是会有新的操作执行。Redis对于新来的操作还是会将其添加到AOF缓冲中，这可以保证即使宕机了，整个AOF日志仍然是齐全的；同时也会添加到AOF重写缓冲中，等到子进程重写完成之后，会将AOF重写缓冲中的内容追加到新的日志文件中。</p><p>也就是说在AOF重写的过程中，主进程执行三个工作：执行client发送过来的命令请求；将写命令追加到现有的AOF文件中（根据三种策略决定）；将写命令追加到AOF重写缓存中。</p><p><strong>当子进程完成AOF重写之后</strong>，会向主线程发送一个完成信号，然后主线程接受到信号之后会调用一个信号处理函数</p><ul><li>将AOF重写缓冲中的内容全部写入新的AOF文件中，这时候新的AOF文件所保存的数据库状态和服务器当前的状态一致。</li><li>对新的AOF文件进行改名，原子的覆盖原有的AOF文件，完成新老文件的替换。</li></ul><p><img src="6b054eb1aed0734bd81ddab9a31d0be8.jpg" alt="img"></p><p><strong>触发时机】</strong></p><p>有两个配置项在控制AOF重写的触发时机： </p><ol><li>auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB </li><li>auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。默认100</li></ol><p>也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。 AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p><p>比如AOF文件体量超过64MB，并且比上次重写后的体量增加了百分百时自动触发重写。</p><p><strong>注意事项】</strong></p><p><strong>重写过程中的潜在阻塞风险？</strong></p><ol><li><strong>fork子进程</strong>：在fork这一瞬间一定会阻塞主线程的，但是在fork的时候并不会一次性拷贝所有内存数据给子进程，而是采用的写时复制机制，避免一次性拷贝大量内存数据给子进程造成的长时间阻塞，<strong>子进程会拷贝父进程的页表，即虚实映射关系，而不是拷贝物理内存</strong>，子进程复制父进程页表，就能共享访问父进程中的内存数据了，此时，类似于有了父进程的所有内存数据。而且这个拷贝的过程会消耗大量CPU资源，拷贝完成之前的整个过程是阻塞的。</li><li>fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以开始AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依然是可以进行写入的。如果父进程操作的是一个已经存在的key，那么此时就会真正拷贝的这个key对应的内存数据，申请新的内存空间，这样逐渐地父子进程内存数据开始分离，逐渐开始拥有各自独立的内存空间。而且内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时变长，可能会产生阻塞风险。</li></ol><p><strong>AOF重写也有一个重写日志，为什么它不共享使用AOF本身的日志呢？</strong></p><ol><li>父子进程之间使用共享的文件必然会产生竞争问题</li><li>如果重写失败了，原来的AOF文件就会被污染了，无法做恢复使用。如果重写失败后，只需要删除这个文件就好了，不会影响到原先的AOF文件。</li></ol><h3 id="4-2-RDB"><a href="#4-2-RDB" class="headerlink" title="4.2 RDB"></a>4.2 RDB</h3><p>AOF在进行故障恢复的时候，需要逐一将AOF日志中的指令都执行一遍。如果操作日志非常多，会导致恢复速度缓慢。</p><p>RDB：内存快照，记录的是某一时刻的数据，并不是操作。所以在执行故障恢复的时候可以直接将RDB文件读入内存，很快完成恢复。</p><p>RDB就像拍照，要考虑两个问题：</p><ol><li>给哪些场景（数据）拍照（持久化）？</li><li>拍照的时候不能动，不然会模糊（阻塞）</li></ol><p>Redis提供了两个命令来生成RDB文件：</p><ul><li><strong>save</strong>：在主线程中执行，会导致阻塞</li><li><strong>bgsave：</strong>fork一个子进程，专门用于写RDB文件，避免了主线程的阻塞，也是默认的配置。</li></ul><p>按照一般来说，利用bgsave的机制的确可以让主线程没有阻塞，可以正常接受请求。但是为了保证快照的完整性，主线程就只能进行读操作，因为不能修改正在执行快照的数据。这样为了快照而暂停主线程的写操作是非常不好的选择。为了解决这个问题，Redis使用了操作系统提供的写时复制技术，在执行快照的同时能够去正常处理写操作。</p><p>如果主线程接收到的是读请求，那么主线程和子进程相互不影响；如果是写请求，比如主线程要修改一块数据，那么这块数据将会被复制一份，生成该数据的副本，然后主线程就会在这个数据副本上进行修改。同时子进程可以继续将原来的快照数据写入RDB文件。<strong>这样就保证了快照的完整性，同时也允许主线程同时对数据进行修改，避免影响正常业务</strong></p><p>但是还得考虑下面的问题：</p><ol><li>如果频繁地执行快照，就会给磁盘带来很大的压力，多个快照竞争有限的磁盘带宽。而且在fork子进程的时候，主线程会有一定的阻塞，主线程内存越大，阻塞时间越长。</li><li>如果执行快照的时间间隔很长，就会导致服务宕机之后，丢失的数据变多。</li></ol><p><strong>增量快照】</strong></p><p>在我们做了一次全量快照之后，后续的快照只需要对修改的记录进行快照记录，只需记录哪些值被修改了，就可以避免每次全量快照的巨大开销。但是这也需要使用额外的元数据信息去记录哪些数据被修改了。</p><p>而且如果我们的记录的大小很小，而记录它的元数据信息就相对来说就比较大了，这样对于内存宝贵的Redis来说是得不偿失的，因此就有了下面的解决方案：</p><p><strong>混合使用AOF和RDB】</strong></p><p>在Redis4.0的时候提出了这个方法，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。这样一来快照就不用很频繁地被执行，也就避免了频繁fork造成的主线程阻塞。同时AOF日志也只需要记录两次快照之间的操作，也不会出现文件过大的情况，避免AOF重写带来的开销。</p><p>而当第二次快照的时候，就可以清空AOF日志了，因为此时的修改都已经被记录到了RDB快照文件中了，恢复的时候也无需AOF日志了。</p><p>官方：4.0之后，Redis的AOF重写就是把内存中的数据以RDB的格式写入AOF文件中，好处就是可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据。但是AOF里面的RDB部分是压缩格式不再是AOF格式，可读性差。</p><p><strong>2核CPU、4GB内存、500G磁盘，Redis实例占用2GB，写读比例为8:2，此时做RDB持久化，产生的风险？】</strong></p><ol><li><strong>内存资源风险：</strong>Redis fork子进程去处理RDB，由于此时写的比例为80%，因此在持久化过程中，写时复制会重新分配整个实例80%的内存副本，大约需要1.6GB，加上本来的2GB，这就使得整个系统的内存接近于饱和。如果机器开启了Swap机制，那么Redis会有一部分的数据被交换到磁盘上，当Redis访问这部分数据时，性能急剧下降。如果没有开启Swap机制，会直接触发OOM，父子进程会面临被系统kill掉的危险。</li><li><strong>CPU资源风险：</strong>生成RDB快照过程会消耗大量CPU资源，虽然Redis是单线程的，但是Redis服务还是会有其余的线程在后台工作，比如AOF在Everysec写回策略下的刷盘、异步关闭文件描述符等操作。此时只有2核CPU，父进程就占用了超过一半的CPU资源，而子进程在进行持久化的过程中，可能会产生CPU竞争，导致父进程处理请求延迟增大，子进程生成RDB快照的时间也会变长。</li></ol><h2 id="第五章-主从下的Redis"><a href="#第五章-主从下的Redis" class="headerlink" title="第五章 主从下的Redis"></a>第五章 主从下的Redis</h2><h3 id="5-1-主从同步"><a href="#5-1-主从同步" class="headerlink" title="5.1 主从同步"></a>5.1 主从同步</h3><p>单实例的Redis在实际生产环境中是切不可取的，万一唯一的Redis宕机了，在恢复过程中，是无法继续提供服务的。因此就需要多个Redis实例，但是这同样也会带来问题，怎么保证多个实例之间的数据一致性呢？</p><p><strong>在Redis中，采用主从库模式来保证数据副本之间的一致性，主从库之间采用的是读写分离的方式。</strong>主库可以接受读和写，但是从库只能接受读操作。同时在主库接受了写操作之后，还得将写操作同步给从库。<strong>如果不采用读写分离的方式，对多个实例之间通过加锁等操作保证数据一致性的维护需要巨额的开销。</strong></p><blockquote><p><strong>主从库之间如何进行第一次同步？</strong></p></blockquote><p>现在有两台Redis实例，分别为实例1和实例2，要想实例1变成实例2的master，就需要在实例2中执行如下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">slaveof</span> 实例<span class="hljs-number">1</span>的IP 实例<span class="hljs-number">1</span>的端口 // Redis5.<span class="hljs-number">0</span>之后使用replicaof代替slaveof<br></code></pre></td></tr></table></figure><p>执行完这个命令，实例1就是实例2的master了，此时就需要进行主从同步，将实例1中的数据同步给实例2。</p><p><img src="63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="img"></p><blockquote><p><strong>第一阶段】</strong></p></blockquote><p>主从库建立了连接，然后进行协商同步的过程。从机给主机发送<strong>psync命令</strong>表示从机想要跟主机进行同步，主机确认回复之后，主从库之间就可以开始同步了。</p><p>psync命令会携带两个参数：</p><ul><li><strong>主库的runID：</strong>所谓的runID是每个Redis实例在启动的时候都会自动生成一个随机ID用来唯一标识这个实例。但是当主从第一次开始同步的时候，从库并不知道主库的runID，因此一开始的时候，psync携带的runID为？</li><li><strong>复制进度offset：</strong>当第一次进行主从同步的时候，设置为-1。</li></ul><p>此时主库接受到了从库发来的请求，就会发送一个响应，也就是<strong>FULLRESYNC</strong>（只会在第一次同步的时候存在），它会携带两个参数给从库：<strong>主库的runID和主库目前的复制进度offset</strong>。从库在收到主库的响应之后，会将这些参数给记录下来。</p><p><strong>当主从第一次进行同步的时候，复制采用的是全量复制，将主库所有的数据都复制给从库</strong></p><blockquote><p><strong>第二阶段】</strong></p></blockquote><p>主库执行bgsave命令生成RDB文件，然后就会将这个文件发送给从库。从库接收到文件之后，会清空它现有的所有数据，然后加载RDB文件。</p><p>为什么要清空所有的数据？可能在同步之前，从库保存了其他数据，为了保证主从数据之间一致，应当清除。</p><p>注意主库将数据同步给从库的过程中，主库并不会被阻塞，但是这同样会引发一个问题，在同步过程中，新增的写请求该怎么办？<strong>主存中会在内存中用专门的replication buffer记录RDB文件生成后收到的所有写操作。</strong></p><blockquote><p><strong>第三阶段】</strong></p></blockquote><p>主库会将第二阶段执行过程中新收到的写命令（记录在replication buffer中）再发送给从库，从库再次重新执行这些操作，这样主从库之间就实现了数据同步了。</p><p><strong>一旦主从库完成了全量复制，他们之间就会一直维护着一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销</strong></p><p><strong>长连接复制是主从库正常运行后的常规同步阶段</strong>，在这个阶段，主从库之间通过命令传播实现同步，而不是文件。</p><blockquote><p><strong>如果主从之间的网络断连该怎么办？】</strong></p></blockquote><p>在Redis2.8之前，出现这种情况，从库会和主库之间重新进行一次全量复制。</p><p>在Redis2.8之后，主从库之间会采用<strong>增量复制的方式</strong>继续同步。它只会将主从库网络断连期间主库收到的命令同步给主从。而这部分命令在断连期间会一直写入<strong>repl_backlog_buffer</strong>这个缓冲区中。（断连期间并不存在replication buffer，而只要存在从库就会存在repl_backlog_buffer）</p><p>repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库会记录自己读到的位置，一开始主库和从库的写读位置在一起，也就是起始位置。随着Redis的正常运行，这两个指针都会进行偏移，他们的偏移量基本相等。但是在主从网络断连期间，主库会收到新的写操作命令，然后主库的偏移量会相对于从库来说更大。</p><p>在主从库的连接恢复之后，从库会给主库发送psync命令，它会携带主库的runID和自己的偏移量slave_repl_offset一起发送给主库，然后主库只需要将master_repl_offset和slave_repl_offset之间的命令操作同步给从库就行了。</p><p>如果repl_backlog_buffer的大小比较小，也就是repl_backlog_size配置的过小，在增量复制阶段可能导致从库的复制进度赶不上主库，进而导致从库重新进行全量复制。<strong>调大repl_backlog_size可以减少从库在网络断连期间全量复制的风险。</strong>一般而言这个大小的公式如下：（主库写入命令速度*操作大小 - 主从库之间网络传输命令速度 * 操作大小） * 2。</p><p>每个从库都会记录自己的slave_repl_offset，每个从库的复制进度也不一样。在和主库重新进行恢复的时候，从库会通过psync命令发送自己的offset，主库会根据从库各自的复制进度来决定这个从库是执行增量复制还是全量复制。</p><p><strong>master-repl-offset：</strong>master处理完写入命令之后，会把命令的字节长度做累加记录，统计在该字段。</p><p><strong>slave-replf-offset：</strong>slave收到master发送的命令后，累加自身的偏移量。</p><blockquote><p><strong>repl_backlog_buffer和replication buffer的区别】</strong></p></blockquote><ol><li><strong>repl_backlog_buffer</strong>：为了从库断开之后，如果找到主从库数据差异而设计的环形缓冲区，从而避免全量复制带来的巨额开销。如果主从之间断开时间太久，就可能导致主从重新连接之后进行全量复制。断连恢复之后，在该buffer中找到主从差异的数据之后，会通过replication buffer发送给从库。</li><li><strong>replication buffer</strong>：主从库在进行增量同步期间，从库作为一个client，会分配一个buffer，所有的数据交互都是通过这个buffer进行的，Redis会先把数据写入到这个buffer中，然后再把buffer中的数据发送到client socket中，再通过网络发送出去，这就完成了数据交互。只不过在主从库增量同步期间，这个buffer专门用来传播用户的写命令到从库，保证主从数据一致性，因此这个buffer通常叫做replication buffer。</li><li>如果主从在传播命令的时候，从库处理得非常慢，就会导致replication buffer持续增长，消耗大量的内存资源，甚至OOM。因此Redis提供了client-output-buffer-limit参数限制buffer的大小。如果超过了限制，主库将会强制断开这个client的连接，此时主从复制会中断。然后中断之后如果主从再次发起复制请求，就可能会导致恶性循环，引起复制风暴。</li><li><strong>当主从之间断开了连接，此时replication buffer将会不存在，但是此时主库还是会接受写操作，因此会将所有的写操作在repl-backlog-buffer中记录一份缓存起来，等到主从恢复之后再通过replication buffer继续进行同步</strong></li></ol><blockquote><p><strong>全量复制为什么不使用AOF？】</strong></p></blockquote><p>RDB文件内容是压缩后的二进制数据，文件很小。一是文件小，传输快；二是二进制数据，从库直接按照RDB协议解析还原速度即可，速度会非常快。</p><p>如果使用AOF将会开启AOF功能，如果刷盘策略选择不当会影响性能。很多丢失数据不敏感的业务场景其实是不需要开启AOF的。</p><p><strong>总结】</strong></p><ol><li>建立主从关系，从库向主库发送同步请求，建立连接。</li><li>主库生成RDB发送给从库，全量同步，完成后主从之间会维护一个网络连接</li><li>第二步中主库仍会添加新数据，这些数据会通过网络长连接以命令的方式发送给从库，完成第一次同步。</li><li>之后的每次同步，都只会执行增量同步（特殊情况即repl-backlog-buffer后续的问题除外）</li></ol><h3 id="5-2-哨兵机制"><a href="#5-2-哨兵机制" class="headerlink" title="5.2 哨兵机制"></a>5.2 哨兵机制</h3><h4 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1. 基本流程"></a>1. 基本流程</h4><p>如果我们的从库宕机了，那么其实还好，因为从库只处理读请求，但是如果我们的主库宕机了呢？这就很难受了，因为此时就没有服务能接受写请求了，这是非常严重的事情了。</p><p>在Redis主从集群中，可以利用<strong>哨兵机制</strong>解决上述问题，哨兵机制是实现主从库自动切换的关键机制，它有效解决了主从复制模式下故障转移的问题。</p><ol><li><strong>监控：</strong>哨兵进程在运行过程中，周期性地给所有的主从库发送PING命令，检测他们是否仍在运行。如果从库没有在规定的时间响应哨兵的PING命令，哨兵就会将其标记为“下线状态”。如果主库没有在规定的时间响应哨兵的PING命令，哨兵就会判定主库下线，然后就会进入<strong>自动切换主库</strong>的流程。</li><li><strong>选主：</strong>在哨兵认为主库挂了之后，就会从剩下的从库中，按照<strong>一定规则</strong>选出一个从库作为新的主库。</li><li><strong>通知：</strong>①、哨兵会将新主库的连接信息发送给其他从库，让他们执行replicaof命令和新主库建立连接，并进行数据复制过程。②、同时，哨兵还会将新主库的连接信息通知给客户端，让他们把请求操作发送到主库上。</li></ol><p>但是其实还有几个问题：</p><h4 id="2-哨兵误判怎么办"><a href="#2-哨兵误判怎么办" class="headerlink" title="2. 哨兵误判怎么办"></a>2. 哨兵误判怎么办</h4><p>有这么一个场景，当哨兵在给主库发送PING命令的时候，由于他们之间的网络波动、主库压力很大导致响应慢等一系列原因，导致哨兵进行了“误判”，其实主库并没有出现故障。可是这时候一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。而这些额外的开销其实是完全没有任何意义的。</p><p><strong>因此实际中我们的哨兵也会采用多实例组成的集群模式进行部署，也就是哨兵集群</strong>。</p><p>引入多个哨兵实例一起来判断，就可以避免单个哨兵的误判，同时也能大大减少误判率。</p><p>我们配置哨兵的时候：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>mymaster 192.168.118.128 6379 2<br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="hljs-comment"># sentinel monitor代表监控，mymaster代表服务器的名称，可自定义。IP代表监控的主服务器</span><br><span class="hljs-comment"># 2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br></code></pre></td></tr></table></figure><p>但是可以看到，在配置哨兵信息的时候，并没有配置其它哨兵的连接信息，那么他们是如何组成哨兵集群的呢？</p><p>哨兵只要和主库建立了连接，就可以在主库上发布消息了，比如发布自己的连接信息。同时它也可以从主库上订阅消息，获得其他哨兵节点发布的连接信息。这样他们就可以感知到各个节点的信息了，从此组成了集群。每个哨兵都订阅了同一个频道，即<code>__sentinel__:hello</code>，只有这样才能通过发布的消息进行信息交换。</p><p>但是哨兵还得需要和所有的从库建立连接，因为哨兵还得监控所有的从库，而且在主从库切换之后，还得通知从库让他们和新的主库进行同步。<strong>哨兵如何知道从库的IP地址和端口号的呢？</strong></p><p><strong>哨兵向主库发送INFO命令，主库将从库列表发送给哨兵，哨兵跟从库列表中的从库建立连接，以便监控从库。</strong></p><p>现在哨兵组成了集群，并且也和主从库之间建立好了连接，但是此时还得和客户端建立连接，因为主从切换之后，客户端也还得需要知道新主库的连接信息，而且客户端还得获取到哨兵集群在监控、选主、切换这个过程中发生的各种事件。</p><p>这个过程是基于pub&#x2F;sub机制的客户端事件通知。哨兵提供的消息订阅频道有很多种，不同频道包含了主从库切换过程中不同关键事件。而客户端读取哨兵的配置文件之后（事先在客户端配置好的文件），就可以获得哨兵的地址和端口，和哨兵建立网络连接。然后就可以让客户端执行订阅命令来获取不同的事件消息。</p><p>当哨兵把新主库筛选出来以后，客户端就会看到switch-master事件，表示主库已经被切换了，新主库的IP地址和端口信息已经有了。</p><p><strong>小总结】</strong>：通过发布订阅机制，哨兵之间可以组成集群；通过INFO命令，哨兵和从库之间建立连接进行监控。通过基于发布订阅机制的客户端事件通知，实现客户端和哨兵之间的事件通知。</p><p><strong>由哪个哨兵执行主从切换】</strong></p><p>在主库发生故障之后，哨兵集群中会有很多的实例，不可能让他们都去进行实际的主从切换，而是只能选取出一个<strong>Leader</strong>出来，让它来完成整个过程。</p><p>我们继续来补充之前学过的知识，在本小节开头的时候，我们说单个哨兵节点可能由于网络等原因导致误判了主库发生故障，因此需要引入哨兵集群，那么这个哨兵集群又是如何判断主库是否发生了故障呢？</p><ul><li>任何一个实例只要自身判断主库主观下线之后，就会给其他的实例发送is-master-down-by-addr命令，接着其他的实例会根据自己和主库的连接情况做出N或Y的响应。只要那个哨兵获得了仲裁所需的赞成票之后（在配置文件中的quorum指定），就可以标记主库客观下线了，此时就得进行主从切换了。</li><li>然后这个哨兵就会再给其他的哨兵节点发送命令，表明希望自己来执行主从切换，并让所有其他哨兵进行投票，即<strong>Leader选举过程</strong>。</li><li>在投票过程中，任何一个想成为Leader的哨兵，都必须拿到半数以上的赞成票，同时拿到的票数还得大于等于配置文件中的quorum值。</li></ul><table><thead><tr><th>时间</th><th>哨兵1（S1）</th><th>哨兵2（S2）</th><th>哨兵3（S3）</th></tr></thead><tbody><tr><td>T1</td><td>给自己投一票<br />向S2、S3发起投票请求<br />表示要成为Leader</td><td></td><td></td></tr><tr><td>T2</td><td></td><td></td><td>给自己投一票<br />向S1、S2发起投票请求<br />表示要成为Leader</td></tr><tr><td>T3</td><td>收到S3请求，恢复N</td><td>收到S3请求，回复Y</td><td></td></tr><tr><td>T4</td><td></td><td>收到S1请求，回复N</td><td></td></tr><tr><td>T5</td><td>1票Y，1票N</td><td></td><td>2票Y，1票N</td></tr></tbody></table><p><strong>每个哨兵会给自己投一票，然后未发起选举的哨兵就会给自己接受到的第一个请求投赞成票，否则投否定票。</strong></p><p>于此同时，如果这一轮投票完成了，但是没有一个哨兵达到成为Leader的要求，哨兵集群就会等待一段事件（哨兵故障转移超时事件的2倍），再重新选举。这是因为哨兵集群能够进行成功投票很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或者有短时堵塞，就可能导致没有一个哨兵拿到半数以上的票，所以等网络拥塞好转之后再进行投票选举，成功的概率就会增加。</p><p><strong>一般而言，所有的哨兵实例的配置都是一样的，尤其是主观下线的判断值down-after-milliseconds</strong>。同时如果哨兵集群只有两个实例，此时一个哨兵想要成为leader就必须获得2票而不是1票。那么此时集群无法进行主从切换。</p><p><strong>如果哨兵集群中所有哨兵都给自己投票岂不是死循环了？</strong></p><p>文章中的例子里，要发生S1、S2和S3同时同自己投票的情况，这需要这三个哨兵基本同时判定了主库客观下线。但是，不同哨兵的网络连接、系统压力不完全一样，接收到下线协商消息的时间也可能不同，所以，它们同时做出主库客观下线判定的概率较小，一般都有个先后关系。文章中的例子，就是S1、S3先判定，S2一直没有判定。</p><p> 其次，哨兵对主从库进行的在线状态检查等操作，是属于一种时间事件，用一个定时器来完成，一般来说每100ms执行一次这些事件。每个哨兵的定时器执行周期都会加上一个小小的随机时间偏移，目的是让每个哨兵执行上述操作的时间能稍微错开些，也是为了避免它们都同时判定主库下线，同时选举Leader。 </p><p>最后，即使出现了都投给自己一票的情况，导致无法选出Leader，哨兵会停一段时间（一般是故障转移超时时间failover_timeout的2倍），然后再可以进行下一轮投票。</p><p>让我们再细化流程：</p><p>假如此时只有两个哨兵，然后当哨兵A判定了主库主观下线了之后，就会马上询问哨兵B（此时哨兵B是被动接受询问，并没有去询问A，也就是说B并没有进入判定客观下线的流程），哨兵B回复给哨兵A主库已经主观下线，然后达到了quorum &#x3D; 2之后哨兵A就可以判定主库客观下线了，然后就会进入选举Leader环节，并给自己投一票，然后给哨兵B发起投票，哨兵B此时并没有进入判定客观下线流程，也就是它无法主动发起投票，因此哨兵B是可以给哨兵A投票的。如果稍后哨兵B也判定主观下线之后并通知A然后得到了两票之后，也会试着想成为领导者，但是它已经给哨兵A投过票了，所以这一轮自己就不能再成为Leader了。</p><p>当然，如果两个哨兵同时判定主库主观下线，然后同时询问对方后都可以同时得到主库客观下线了，然后同时都可以发起成为Leader的选举，然后同时给自己投上一票，由于都给自己投票了，因此每个哨兵各持一票。但是这种场景的概率非常低。</p><p>同时，<strong>哨兵并不是越多越好</strong>，哨兵在搭建集群的时候需要消耗资源，同时在判定客观下线和选举Leader的时候都需要和其他的节点进行通信，交换信息。而且部署多个哨兵需要分布在不同的机器上，无论是风险还是花费都比较高，这些问题都会影响到哨兵的通信和选举，出问题的时候也会意味着主从切换的时间更久，会引发一系列问题。</p><h4 id="3-如何选定新主库"><a href="#3-如何选定新主库" class="headerlink" title="3. 如何选定新主库"></a>3. 如何选定新主库</h4><ol><li><strong>筛选：</strong>将不符合条件的从库去掉。<ul><li>此时从库肯定是要在线的，下线状态的从库肯定无法作为新主库的候选者。</li><li>此时从库在线但是不代表它就可以使用。因为如果我们选择从库A作为新的主库，但是它的网络连接状态其实非常差，经常和主库断连，因此从库A就不可以作为新的主库，不然又得重新选主。</li><li>配置<strong>down-after-milliseconds</strong>，它是我们认为主从库断连的最大超时时间，如果一个实例失去联系超过了这个时间，哨兵就开始认为这个实例挂掉了。如果发生断连的次数超过了十次，就说明这个从库网络状况不好，不适合作为新主库。</li></ul></li><li><strong>打分：</strong>按照一定的规则，选出分数最高的从库作为新的主库。<ul><li><strong>优先级最高的从库得分最高：</strong>通过slave-priority配置项，给不同的从库设置不同优先级。如果剩下的从库优先级都一样，进入下一流程。</li><li><strong>和旧主库同步程度最接近的从库得分最高：</strong>通过从库的slave-repl-offset值，看哪个值离主库的master-repl-offset值最近。如果都一样，进入最后一个流程。注意主库挂了是没有master-repl-offset值的，只能比较各从库之间的slave-repl-offset大小。</li><li><strong>ID号小的从库得分高：</strong>我们在之前说到，每个Redis实例都会分配一个runID，这是较为常见的默认做法，因为源码中runID只是40个字节长度的随机十六进制字符而已。</li></ul></li><li><strong>总结：</strong>哨兵会按照网络状况、在线状况过滤掉不符合的从库，然后让这些从库依次按照优先级、复制进度、ID号大小进行打分对比，只要出现得分最高的从库，就将其作为新主库。</li></ol><p>在Redis4.0之前，主从切换后，从库需要和主库做全量同步。但是4.0之后Redis做了优化，从库可以只和新主库做增量同步就行，具体详情查看psync2。</p><h4 id="4-主从切换期间，客户端能否正常操作"><a href="#4-主从切换期间，客户端能否正常操作" class="headerlink" title="4. 主从切换期间，客户端能否正常操作"></a>4. 主从切换期间，客户端能否正常操作</h4><p>如果客户端使用了读写分离，那么读请求可以在从库上正常执行。但是由于此时主库已经挂了，在哨兵切换主从时间 + 客户端感知新主库的时间，这部分时间内，会导致写请求失败。</p><p>如果不想让业务感知到异常，就可以让客户端把写失败的请求给缓存起来或者写入到MQ消息队列中间件中，等完成主从切换之后再将这些请求发送给新主库。但是这种场景只适合对写入请求返回值不敏感的业务，而且要在业务层做适配。同时如果主从切换时间过长，可能会导致客户端或MQ中缓存的写请求过多，切换完成之后重放这些写请求需要的时间也会越多。</p><p>同时之前提高了<strong>down-after-milliseconds</strong>参数，<strong>如果该参数配置的过小</strong>，就会导致哨兵非常敏感，可能会因为网络波动导致误判率变高，从而产生不必要的主从切换；如果<strong>该参数配置的过大</strong>，这虽然可以减少哨兵误判的概率，但是主库发生故障时，业务写失败的时间也会比较久，缓存写请求的数据量就会比较多。</p><p>同时还得注意，在哨兵完成主从切换之后，客户端得及时感知到主库发送了变更。采用的是Redis中的发布订阅模式，客户端要订阅哨兵pubsub，感知主库的变更。同时客户端还得主动去获取新主从的地址进行访问。</p><h3 id="5-3-数据的切片"><a href="#5-3-数据的切片" class="headerlink" title="5.3 数据的切片"></a>5.3 数据的切片</h3><p>主从同步是为了解决单实例Redis的可用性不高的问题，但是如果我们的Redis实例中的数据过多，导致单个实例的容量不够了，就得寻找新的解决办法。</p><ol><li><strong>纵向扩展：</strong>其实就是对单个Redis实例进行升级，比如之前的实例内存只有40G，我们直接买一个100G的服务器作为Redis的实例。这种方法实现起来非常简单，但是仍然会有缺陷。首先是Redis实例中的数据量过大，导致每次进行RDB持久化的时候，都会fork子进程来完成，但是实例数据越多，fork造成的主线程阻塞就越长。而且这种纵向扩展，会受到硬件和成本的限制。</li><li><strong>横向扩展：</strong>我们可以增加Redis实例的个数，用多个Redis实例来存储数据。</li></ol><p>我们在规模非常大的Redis使用场景中，会选择使用横向扩展，但是它同样也会带来新的问题，那就是数据切片之后，在多个实例之间该如何分布？客户端怎么确定想要访问的数据在哪个实例当中？</p><p>切片集群是一种保存大量数据的通用机制，这种机制可以有很多不同的实现方案。在Redis3.0之前，官方并没有针对切片集群提供具体的方案。从3.0开始，官方提供了一个名为<strong>Redis Cluster</strong>的方案，用于实现切片集群。</p><p>Redis Cluster采用Hash Slot的方式来处理数据和实例之间的映射关系。在该方案中，一个切片集群共有<strong>16384</strong>个哈希槽（2的14次方）。在具体的映射过程中：</p><ol><li>根据键值对的key，按照CRC16算法计算出一个16bit的值，然后用这个值对16384进行取模，得到0-16383之间的整数，每个模数就代表一个相应编号的哈希槽。</li><li>每一个哈希槽都会被对应到相应的Redis实例中。</li><li>这些哈希槽和Redis实例关联的过程：<ul><li>使用cluster create命令创建分片集群，然后Redis会自动将这些槽位平均分布在集群实例上。如果集群中有N个实例，那么每个实例都会对应16384&#x2F;N个哈希槽。</li><li>使用cluster meet命令手动建立实例间的连接构成集群，再使用cluster addslots命令指定每个实例上的哈希槽的个数，但是<strong>在手动分配哈希槽的过程中，需要将所有的哈希槽全部分配完毕，否则Redis集群无法正常工作</strong></li></ul></li></ol><p>哈希槽的信息：槽索引（key）–&gt;Redis实例（value），<strong>当哈希槽分配完之后，集群中的每个Redis实例都会把自己的哈希槽信息发送给集群中的其他实例，为的是当该Redis实例中不能处理的时候，能够快速知道槽在哪个实例下。</strong>当实例之间相互连接之后，每个实例就都有多有哈希槽的映射关系了。哈希槽和全局哈希表是不一样的。我们先通过key映射到对应的slot，然后在该slot所对应的实例中通过全局哈希表查找key对应的value值。</p><p>一般而言，客户端和集群实例建立连接之后，实例就会把哈希槽的分配信息发给客户端，然后客户端在收到哈希槽信息之后，就会把哈希槽信息缓存在本地。当客户端请求键值对的时候，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p><ul><li>但是如果在集群中实例有新增或者删除，Redis还需要重新分配哈希槽。</li><li>而且为了负载均衡，也就是由于热点key的原因导致部分槽位的访问频繁，且可能这些槽位都对应在某一个或几个实例上，导致所有实例之间压力不均衡，因此需要重新分配。</li><li>不是自动，运维手动触发</li></ul><p>Redis Cluster提供了<strong>重定向机制</strong>，就是客户端给一个实例发送数据读写操作时，如果这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">GET</span> hello:key<br>(<span class="hljs-literal">error</span>) MOVED <span class="hljs-number">13320</span> <span class="hljs-number">172.16.19.5:6379</span><br></code></pre></td></tr></table></figure><p>MOVEN表示，客户端请求的键值对所在的哈希槽13320实际上是在172.16.19.5这个实例上。通过该命令就相当于将哈希槽所在的新实例的信息告诉给了客户端，这样一来客户端就可以直接和172.16.19.5连接，并且更新客户端的本地缓存。</p><p>如果有一个哈希槽x原本指向实例A，经过重新指派之后指派给了实例B，但是客户端并不知道，还是会向实例A发送请求，实例A收到之后就去查找本地的哈希槽数组中的第x项，发现第x项的值指向了节点B的节点信息，节点A就会将节点B的信息返回给客户端。客户端收到MOVED重定向命令之后会将本地缓存的哈希槽映射信息进行修改，再向实例B发送请求。</p><p>实际上还存在一种情况，那就是哈希槽在重新分配过程中收到了来自客户端的请求。还是上面的例子，哈希槽x原本指派给实例A，重新指派之后给了实例B，在迁移槽过程中收到了客户端命令。节点A会先在数据库中寻找key，如果没找到再判断哈希槽x是否正在迁移，如果正在迁移，那么key有可能被迁移到了实例B，于是实例A会向客户端发送ASK错误，ASK错误并不会导致客户端修改本地缓存的哈希槽信息，因为哈希槽x对应的key可能有很多，迁移完成之前还会有部分key还在节点A中，如果此时客户端修改了哈希槽信息，那么下次发送欧冠其他哈希槽x相关命令时会发送到了节点B，但是因为该数据还在节点A中，因此B无法处理命令。</p><p>实例A在发送了ASK错误之后，客户端就会收到该ASK错误，该错误会告诉客户端请求的键值对所在的哈希槽x在B这个实例上，但是这个哈希槽正在迁移。此时客户端会先给实例B发送一个ASKING命令（让这个实例允许执行客户端接下来发送的命令），然后客户端再向这个实例发送GET命令以读取数据。</p><p><strong>再补充，将哈希槽x从实例A迁移到实例B，如何知道要迁移哪些key？】</strong></p><ol><li>有一个slots_to_keys跳跃表保存了槽和键之间的关系。</li><li>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到跳跃表中。</li><li>每当节点删除数据库中的某个键值对时，节点就会在跳跃表中解除被删除键和槽号的联系。</li></ol><p><strong>为什么要引入哈希槽？】</strong></p><ol><li>整个集群的key数量是非常庞大的，当key数量非常多的时候，直接记录每个key对应的实例映射关系会导致映射表非常庞大。</li><li>集群在扩容、缩容、数据均衡过程中，节点之间会发生数据转移，迁移时需要修改每个key的映射关系，维护成本高。而在中间加一层哈希槽，可以将数据和节点解耦，key通过hash计算只需要关心映射到了哪个哈希槽，然后再通过哈希槽和节点之间的映射表找到节点，相当于消耗了很少的CPU资源，不但让数据分布更均匀，还可以让这个映射表变得更小，利于客户端和服务端保存，节点之间交换信息时也变得轻量。</li><li>节点之间的操作如数据迁移，都以哈希槽为基本单位进行操作，简化了节点扩容、缩容的难度，便于集群的维护和管理。</li></ol><h2 id="第六章-深入体会底层-实战篇"><a href="#第六章-深入体会底层-实战篇" class="headerlink" title="第六章 深入体会底层-实战篇"></a>第六章 深入体会底层-实战篇</h2><h3 id="6-1-利用Hash解决String空间浪费问题"><a href="#6-1-利用Hash解决String空间浪费问题" class="headerlink" title="6.1 利用Hash解决String空间浪费问题"></a>6.1 利用Hash解决String空间浪费问题</h3><p>对于这样一个需求：有两个系统，资源在系统A的ID和在系统B的ID一一对应，且各自需要10位数来表示他们的ID，这样的数据如何存储在Redis中？</p><p>一想到一一对应，我们就首先会想到利用String对象进行存储，因为String对象的key-value一一对应关系不就正好完美符合我们的需求吗？但是别着急，我们首先来算算使用String对象需要消耗的内存空间。</p><p>我们的10位数的ID，利用二进制来存的话， 8字节的Long类型相信是远远足够的了。因此对于key-value来说，一共只需要16字节就够了，但是远远不止这些。</p><p>在我们的Redis中，每个String对象其实都被一个redisObject对象所封装，由于我们存储的数据是Long类型，Redis就会有一个优化，那就是直接将redisObject的void *类型的ptr（8字节）指针转换为long类型，就不需要额外的SDS空间了。然后redisObject中，type+encoding+lru+refcount+ptr一共占用16字节，而我们Redis是使用一个全局哈希表来保存每个redisObject。dictentry中的key指针、value指针、next指针分别占用8字节，然后key、value指向的redisObject分别占用16字节，那么就一共占用8+8+8+16+16，同时jemalloc在分配内存的时候，会申请2的幂次方大小的内存，因此我们存储一个对应关系，虽然实际数据只需要16字节，但是我们却消耗了64字节的空间！</p><p><img src="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E5%AE%9E%E6%88%98-%E5%88%A9%E7%94%A8Hash%E8%A7%A3%E5%86%B3String%E7%A9%BA%E9%97%B4%E6%B5%AA%E8%B4%B9%E9%97%AE%E9%A2%98.png" alt="深入理解Redis-实战-利用Hash解决String空间浪费问题"></p><p>可以看到，我们对空间的浪费其实是非常严重，那么该如何解决呢？</p><p>在Redis中的Hash对象中，当数据量小于512并且每一个数据的大小不超过64字节的时候，使用ziplist进行存储。而ziplist中可以存放很多个entry而并不需要指针之类的额外消耗！因此我们可以通过修改参数的方式，将数量小于512改成数量小于1000，然后去系统A中的ID的前7位作为dictEntry中的key，然后后三位配合上系统B中的ID作为key和value。这样其实每个记录所需要的空间就大幅度减少了。Hash对象是多个值一个key，而String对象是一个值一个key。</p><h3 id="6-2-如何使用Redis实现消息队列"><a href="#6-2-如何使用Redis实现消息队列" class="headerlink" title="6.2 如何使用Redis实现消息队列"></a>6.2 如何使用Redis实现消息队列</h3><p>对于消息队列来说，必须满足三个要求：<strong>消息保序、处理重复的消息、保证消息可靠性</strong></p><p>一般来说，消息队列都是使用kafka、RabbitMQ等专业的消息队列中间件。但是，关于Redis能否做消息队列不能一概而论，我们需要考虑业务层面的数据体量，以及对性能、可靠性、可拓展性的需求。如果分布式系统中的组件消息通信量不大，那么Redis只需要使用有限的内存空间就能满足消息存储的需求，而且，Redis 的高性能特性能支持快速的消息读写，不失为消息队列的一个好的解决方案。</p><p>Redis可以用作队列，而且性能很高，部署维护也很轻量，但缺点是<strong>无法严格保数据的完整性（比如主从同步时候的延迟）</strong>（个人认为这就是业界有争议要不要使用Redis当作队列的地方）。而使用专业的队列中间件，可以严格保证数据的完整性，但缺点是，部署维护成本高，用起来比较重。</p><p><strong>1、使用List作为消息队列</strong></p><p>Redis也可以使用List数据类型当做队列使用，一个客户端使用rpush生产数据到Redis中，另一个客户端使用lpop取出数据进行消费，非常方便。但要注意的是，使用List当做队列，缺点是没有ack机制和不支持多个消费者。没有ack机制会导致从Redis中取出的数据后，如果客户端处理失败了，取出的这个数据相当于丢失了，无法重新消费。所以使用List用作队列适合于对于丢失数据不敏感的业务场景，但它的优点是，因为都是内存操作，所以非常快和轻量。 </p><p>List解决重复的消息：可以在生产者端发送消息的时候，顺带生成一个全局的id然后和消息包装在一起，一起发送到List中，然后消费者可以去记录这个全局ID。同时也需要在业务层面去保证幂等性。</p><p><strong>2、使用PubSub作为消息队列</strong></p><p>而Redis提供的PubSub，可以支持多个消费者进行消费，生产者发布一条消息，多个消费者同时订阅消费。但是它的缺点是，如果任意一个消费者挂了，等恢复过来后，在这期间的生产者的数据就丢失了。PubSub只把数据发给在线的消费者，消费者一旦下线，就会丢弃数据。另一个缺点是，PubSub中的数据<strong>不支持数据持久化</strong>，当Redis宕机恢复后，其他类型的数据都可以从RDB和AOF中恢复回来，但PubSub不行，<strong>它就是简单的基于内存的多播机制</strong>。</p><p><strong>3、使用Stream作为消息队列</strong></p><p>之后Redis 5.0推出了Stream数据结构，它借鉴了Kafka的设计思想，弥补了List和PubSub的不足。Stream类型数据可以持久化、支持ack机制、支持多个消费者、支持回溯消费，基本上实现了队列中间件大部分功能，比List和PubSub更可靠。 </p><p>使用Streams数据类型，创建多个消费者组，就可以实现同时消费生产者的数据。每个消费者组内可以再挂多个消费者分担读取消息进行消费，消费完成后，各自向Redis发送XACK，标记自己的消费组已经消费到了哪个位置，而且消费组之间互不影响。</p><p><img src="640.jpeg" alt="图片"></p><h3 id="6-3-Redis中的事务"><a href="#6-3-Redis中的事务" class="headerlink" title="6.3 Redis中的事务"></a>6.3 Redis中的事务</h3><p>对于Redis的事务来说：</p><ol><li>使用<strong>MULTI</strong>显示的开启事务</li><li>客户端将事务中要执行的具体操作发送至服务端，比如增删改查等。这些操作是Redis本身提供的数据读写命令。不过这些命令虽然被客户端发送至了服务器端，但是Redis实例只是会将其<strong>暂存到一个命令队列中，并不会立即执行。</strong></li><li>客户端向服务端发送提交事务的命令，<strong>EXEC命令</strong>。当服务端收到这个命令之后，才会实际执行命令队列中的所有命令。</li></ol><p><strong>原子性】</strong></p><p>第一种情况：如果在<strong>Redis执行EXEC命令之前，客户端发送的命令本身就有错误</strong>，比如语法错误或者使用到了不存在的命令，在入队的时候就会被Redis实例给检测出来，然后它会报错并记录下这个错误。此时我们还可以继续提交命令操作。但是等到了执行EXEC命令之后，Redis就会<strong>拒绝执行所有提交的命令操作，返回事务失败的结果</strong>。这时可以保证原子性。 </p><p>第二种情况：如果<strong>事务操作入队的时候，命令和操作的数据类型不匹配，但是Redis实例并没有检查出错误</strong>。在实际执行的时候，Redis虽然会对错误命令报错，但是还是会将正确的命令执行下去，无法保证原子性。</p><p>Redis中并没有提供回滚机制，虽然提供了DISCARD命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p><p>第三种情况：<strong>在执行事务的EXEC命令时，Redis实例发生了故障，导致事务失败</strong>。如果Redis开启了AOF日志，那么只会有部分的事务操作被记录在AOF日志中，我们可以使用redis-check-aof工具检查AOF日志文件，将未完成的事务中已经完成的命令删除掉，就好像没有这个事务一样。这样一来当使用AOF恢复实例之后，事务操作不会再被执行，保证了原子性。</p><p>如果没有开启AOF日志，那么实例重启之后数据也无法恢复了，这就谈不上什么原子性了。由于RDB不会在事务执行的时候执行，所以RDB文件中不会记录只执行了一部分的结果数据。之后用RDB恢复实例数据，恢复的还是事务之前的数据。</p><p><strong>隔离性】</strong></p><p>并发操作在EXEC命令前执行，此时隔离性的保证要使用WATCH机制来实现，否则隔离性无法保证。如果并发操作在EXEC命令之后执行，此时隔离性可以保证。</p><p>WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。</p><p>当EXEC命令执行之后，由于Redis单线程执行命令，因此它会等到命令队列中的所有命令操作都执行完毕才会去执行其余的命令。</p><p><strong>持久性】</strong></p><p>取决于使用什么持久化策略，但是无论采用什么模式，Redis事务的持久性都得不到保证。 </p><h3 id="6-4-缓存问题"><a href="#6-4-缓存问题" class="headerlink" title="6.4 缓存问题"></a>6.4 缓存问题</h3><blockquote><p><strong>缓存雪崩</strong></p></blockquote><p>在高并发场景下，<strong>瞬间过期数据量（不同的数据）太大或者缓存服务宕机</strong>，导致对数据库服务器造成的压力过大。</p><p>白话文：如果缓存中有1000个商品，他们都设置了相同的过期时间，当时间到了的时候，所有的redis中的数据都过期了，这个时候，有很多个请求同时发送过来，就会全部去访问数据库，就会导致数据库宕机。</p><p>解决方法：</p><ol><li>可以设置缓存数据永不失效</li><li>可以对每个数据都加一个随机的过期时间，防止同一时间大量数据过期现象发生</li><li>使用集群来提高缓存可用性。 </li><li>进行熔断降级，为了防止整个系统出现雪崩，可以暂时停止业务服务访问缓存系统。或者暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback错误处理信息。</li></ol><blockquote><p><strong>缓存击穿</strong></p></blockquote><p>对于某些设置了过期时间的key，如果这个key会在某个时间点被超高并发的访问，也就是存在高并发的场景，如果该key值过期了，大量的请求将会同一时间对该数据进行查询，都会落到数据库中</p><p><strong>注意：缓存击穿指的是并发查询同一条数据，缓存雪崩指的是不同数据都过期了，很多数据都查不到从而查询数据库。</strong></p><p>解决方法：对查询数据库的方法加锁，大量的并发只让一个人查，其他人等待，当唯一的线程查到数据后就放入缓存中，其余的线程等锁释放后先查询缓存。</p><p>单体应用下解决缓存击穿问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="hljs-title function_">getCatalogJsonFromDbWithLocalLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">//1、先查询缓存中有没有数据，如果有数据就返回</span><br>        <span class="hljs-comment">//2、没有数据就进行数据的查询</span><br>        <span class="hljs-comment">//3、将查询到的数据存入缓存中（值得注意的是，这个步骤一定也要放入锁中，</span><br>        <span class="hljs-comment">//         不然当第一个线程查询到了数据释放锁之后，还没来得及将数据放入redis中，</span><br>        <span class="hljs-comment">//          第二个线程就进来先判断缓存中没有数据，就会再查询一次数据库</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集群下可以使用分布式锁解决问题</p><blockquote><p><strong>缓存穿透</strong></p></blockquote><p>查询一个一定不存在的数据。由于缓存不命中，将去查询数据库，但是数据库也没有该记录，我们没有将这次查询到的null值写入缓存，这将导致这个不存在的数据每次请求都到存储层去查询，失去了缓存的意义，也对数据库服务器造成压力。</p><p>解决方法：null结果缓存，并且加入短暂的过期时间，可以通过springcache来解决</p><p>也可以使用布隆过滤器对一定不存在的数据进行过滤。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机</title>
    <link href="/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-类加载子系统"><a href="#第一章-类加载子系统" class="headerlink" title="第一章 类加载子系统"></a>第一章 类加载子系统</h1><p><img src="image-20220504183302402.png" alt="image-20220504183302402"></p><ol><li>Class Loader SubSystem（类加载子系统）负责从文件系统或网络中加载Class Files，Class Files在文件开头有特定的文件标识</li><li>ClassLoader只负责class文件的加载，至于它是否可以允许，则有Execution Engine（执行引擎）决定。（可以理解为媒婆负责介绍对象，能不能成就得看自己的努力了）</li><li>加载的类信息存放于一块称为方法区（Method Area）的内存空间。除了类的信息外，方法区（Method Area）中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分信息是Class文件中常量池部分的内存映射）</li></ol><h2 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h2><p><img src="image-20220504183404624.png" alt="image-20220504183404624"></p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="image-20220504183421452.png" alt="image-20220504183421452"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class文件</strong>，作为方法区这个类的各种数据的访问入口</li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>1、验证</strong></p><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li></ul><p><strong>2、准备</strong></p><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值（引用类型为null、布尔值为false等）</li><li><strong>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</strong></li><li><strong>这里不会为实例变量分配初始化</strong>（因为还没有初始化），类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ul><p><strong>3、解析</strong></p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中，直接引用和就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li><li>符号引用就是一个字符串，它给出了被引用的内容的名字并且可能会包含一些其他关于这个被引用项的信息–这些信息必须足以唯一的识别一个类、字段、方法。这样对于其他类的符号引用必须给出类的全名。对于其他类的字段必须给出类名、字段名以及字段描述符。对于其他类的方法的引用必须给出类名、方法名以及方法的描述符。这样我们就能根据符号引用锁定唯一的类，方法或者字段了。</li><li>符号引用主要包含下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p>初始化阶段就是执行类构造器方法&lt; clinit&gt;()的过程。</p></li><li><p>这个方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说如果一个类没有类变量和静态代码块，那么该类在初始化的时候是不会有&lt; Clinit&gt;()方法的。</p></li><li><p>构造器方法中指定按语句在源文件中出现的顺序执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        number = <span class="hljs-number">20</span>;<br>        System.out.println(num);<br>        <span class="hljs-comment">//System.out.println(number);//报错：非法的前向引用。可以赋值，但是不能调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num);<span class="hljs-comment">//2</span><br>        System.out.println(ClassInitTest.number);<span class="hljs-comment">//10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&lt; clinit&gt;()不同于类的构造器。（构造器是虚拟机视角下的&lt; init&gt;()）</p></li><li><p>若该类具有父类，JVM会保证子类的&lt; clinit&gt;()执行前，父类的&lt; clinit&gt;()已经执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClinitTest1</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">static</span>&#123;<br>            A = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> A;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//加载Father类，其次加载Son类。</span><br>        System.out.println(Son.B);<span class="hljs-comment">//2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要加载Son类的时候，首先去初始化Father类，初始化的时候会自动的执行类中的类变量和静态代码块，因此B的值为2</p></li><li><p>虚拟机必须保证一个类的&lt; clinit&gt;()方法在多线程下被同步加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-type">DeadThread</span> <span class="hljs-variable">dead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在对DeadThread进行初始化的时候，由于静态代码块里面是死循环，因此会一直初始化。此时另一个线程也要初始化DeadThread，但是由于第一个DeadThread并未完成初始化，因此它无法初始化成功。</p></li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><ul><li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义加载器</strong>。</li><li>无论类加载器的类型如何分类，我们在程序中最常见的类加载器始终只有三个</li></ul><p><img src="image-20220504184253091.png" alt="image-20220504184253091"></p><p>也就是说，JVM将Bootstarp Class Loader 分为一类，将扩展类加载器（Extension ClassLoader）、系统类加载器（SystemClassLoader）、还有其余的用户自定义的类加载器同一称为自定义类加载器</p><p><strong>1、BootstrapClassLoader</strong></p><ul><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身所需要的类</li><li>并不继承自java.lang.ClassLoader，因此没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，<strong>Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</strong>，比如java.lang.String。</li></ul><p><strong>2、ExtensionClassLoader</strong></p><ul><li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ul><p><strong>3、AppClassLoader</strong></p><ul><li>java语言编写，由sun.misc.Launcher&amp;AppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li><strong>该类加载器是程序中默认的类加载器</strong>，一般来说，java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul><p><strong>4、用户自定义类加载器</strong></p><ul><li>为什么要自定义类加载器？<ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li><li>自定义类加载器实现步骤<ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载器，但在JDK1.2之后，已不再建议用户去覆盖loadClass方法，而是建议把自定义的类加载逻辑写在findClass方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass方法级其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol></li></ul><h2 id="ClassLoader的使用说明"><a href="#ClassLoader的使用说明" class="headerlink" title="ClassLoader的使用说明"></a>ClassLoader的使用说明</h2><p>ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader，不包括BootstrapClassLoader</p><p><img src="image-20210821122951746.png" alt="image-20210821122951746"></p><p><strong>获取ClassLoader的途径</strong></p><p><img src="image-20210821123048947.png" alt="tupu"></p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>java虚拟机对class文件采用的是<strong>按需加载</strong>方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，<strong>即把请求交由父类处理</strong>，它是一种任务委派模式</p><p><strong>工作原理</strong></p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去加载</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求，最终到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li></ol><p><strong>优势</strong></p><ul><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意串改</p><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.MyString</li></ul><p>这两个类都无法被加载，就是因为双亲委派机制</p></li></ul><p><strong>沙箱安全机制</strong></p><p>自定义String类，但是在加载自定义String类时会率先使用引导类加载器加载，而引导类加载器在加载过程中会加载jdk自带的文件（rt.jar包中的java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护，这就是沙箱安全机制</p><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.java1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String();<br>        System.out.println(<span class="hljs-string">&quot;hello,atguigu.com&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义java.lang包下的String类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//错误: 在类 java.lang.String 中找不到 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,String&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行StringTest的main方法，只会打印hello,atguigu.com ，不会打印自定义的String类中的静态代码块中的内容，说明我们自定义的String类没有进行初始化</p><p>运行自定义String类中的main方法，会报错：</p><p><img src="image-20210821124341862.png" alt="image-20210821124341862"></p><p>这就是上面说的沙箱安全机制</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>在JVM中表示两个class对象是否为同一类存在两个必要条件：<ul><li>类的完整包名必须一致，包括包名</li><li>加载这个类的ClassLoader（指ClassLaoder实例对象）必须相同</li></ul></li><li>换句话说，在JVM中，即使这两个类对象来源同一个Class文件，被同一个虚拟机所加载，只要加载它们的ClassLoader实例对象不是同一个，那么这两个类对象也不是相等的</li></ul><p>比如说我们自定义的String类和系统的String类，都是定义在java.lang下的，但是他们两个的ClassLoader不一样，因此就不是同一个类</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用时，JVM需要保证这两个类型的类加载器是相同的</p><p><strong>Java程序对类的使用方式：类的主动使用和被动使用</strong></p><p><strong>主动使用</strong>，有7种情况：</p><ul><li>创建类的实例</li><li>访问某个类的接口或静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如Class.forName（“com.tomasCarry.Test”））</li><li>初始化一个类的子类</li><li>Java虛拟机启动时被标明为启动类的类</li><li>JDK 7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上7种情况，其他的使用都是<strong>被动使用</strong>，都不会导致类的初始化</p><h1 id="第二章-运行时数据区"><a href="#第二章-运行时数据区" class="headerlink" title="第二章 运行时数据区"></a>第二章 运行时数据区</h1><p>内存是非常重要的资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程种内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在部分差异</strong>。</p><p><img src="image-20210821190828499.png" alt="image-20210821190828499"></p><p>在Java8的时候，方法区变成了元空间。</p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束创建和销毁</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。</p><ul><li>每个线程：独立包括程序计数器（ProgramCounterRegister）、本地方法栈（NativeMethodStack）、虚拟机栈（VirtualMachineStack）</li><li>线程间共享：堆（Heap）、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="IMG/03、运行时数据区概述及线程.assets/第03章_线程共享和私有的结构.jpg"></p><p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框“运行时环境。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射：当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程种的run方法。</li><li>如果使用jconsole或者其他的调式工具，能看到后台有许多线程在运行，这些后台线程不包括调用psvm的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台线程在HotspotJVM里面主要是以下几个：<ul><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world“的垃圾收集、线程栈收集、线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：在运行时将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接受信号并发送给JVM，它在内部通过调用适当的方法进行处理</li></ul></li></ul><h2 id="PC计数器"><a href="#PC计数器" class="headerlink" title="PC计数器"></a>PC计数器</h2><h3 id="PC寄存器的介绍"><a href="#PC寄存器的介绍" class="headerlink" title="PC寄存器的介绍"></a>PC寄存器的介绍</h3><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><h3 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h3><p>PC寄存器用来存储指向下一条指令的地址，也即将 要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="image-20210821200606763.png" alt="IMG/04、程序计数器.assets/image-20210821200606763.png"></p><p>测试代码如下，通过字节码文件层次进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(i);<br>        System.out.println(k);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</p><p><img src="0009.png" alt="img"></p><h3 id="两个常见面试题"><a href="#两个常见面试题" class="headerlink" title="两个常见面试题"></a>两个常见面试题</h3><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用PC寄存器来记录当前线程的执行地址</strong></p><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><strong>PC寄存器为什么被设定为私有的</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><p><img src="0011.png" alt="img"></p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>虚拟机栈出现的背景</strong></p><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><p><strong>内存中的栈与堆</strong></p><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><strong>虚拟机栈基本内容</strong></p><ul><li>Java虚拟机栈是什么？<ul><li>Java虚拟机栈（Java Virtual Machine Stack）早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（StackFrame），对应着一次次的Java方法调用，栈是线程私有的</li></ul></li><li>虚拟机栈的生命周期<ul><li>和线程一致，也就是线程结束了，该虚拟机栈也就被销毁了</li></ul></li><li>作用<ul><li>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。<ul><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型 VS 引用类型变量（类、数组、接口）</li></ul></li></ul></li></ul><p><strong>虚拟机栈的特点</strong></p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>方法执行结束后出栈工作</li></ul></li><li><strong>对于栈来说不存在垃圾回收问题，但是可能存在OOM</strong></li></ul><p><strong>虚拟机栈种的异常</strong></p><p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的</p><ul><li>如果采用固定大小的Java虚拟机栈，那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong>的异常</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong> 异常</li></ul><p><strong>设置栈内存大小</strong></p><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><h4 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h4><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应着一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ol><h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><ol><li>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（即栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令都针对当前栈帧进行操作。</li><li>如果该方法调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧</li></ol><p><img src="image-20210825093704619.png" alt="image-20210825093704619"></p><ol><li><strong>不同的线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，在方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式<ul><li>一种是正常的函数返回，使用return指令</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束</li><li>但是不管是哪种方式，都会导致栈帧被弹出</li></ul></li></ol><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（Operand Stack）（或表达式栈）</strong></li><li>动态链接（Dynamic Linking）或指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）或方法正常退出或者异常退出的定义</li><li>一些附加信息</li></ul><p><img src="image-20210825095220429.png" alt="image-20210825095220429"></p><h3 id="局部变量表（有疑问）"><a href="#局部变量表（有疑问）" class="headerlink" title="局部变量表（有疑问）"></a>局部变量表（有疑问）</h3><ul><li><p>局部变量表也被称为局部变量数组或本地变量表</p></li><li><p><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</p><blockquote><p><img src="image-20210825183353317.png" alt="image-20210825183353317"></p></blockquote><blockquote><p>注意这里说的，在Java8中，通过jclasslib我并没有看到局部变量表中有关于returnAddress返回值类型的影子，通过在尚硅谷群内询问，这位老哥告诉我returnAddress已经由异常表代替了，但是现在我还没有学到异常表相关信息（好像后序的章节会说明，暂时标注一下）</p></blockquote></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</p><ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li><p>局部变量表中的变量只在当前方法调用中有效。</p><ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ul><h4 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h4><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localVar2</span><span class="hljs-params">()</span> &#123;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(a);<br>    &#125;<br>    <span class="hljs-comment">//此时的b就会复用a的槽位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过jclasslib可以看到b复用了a所处的slot</p><p><img src="image-20210825184400287.png" alt="IMG/05、虚拟机栈.assets/image-20210825184400287.png"></p><h4 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">变量的分类：<br><span class="hljs-number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型<br><span class="hljs-number">2</span>、按照在类中声明的位置分：<br>  <span class="hljs-number">2</span>-<span class="hljs-number">1</span>、成员变量：在使用前，都经历过默认初始化赋值<br>       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值<br>              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值<br>       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>  <span class="hljs-number">2</span>-<span class="hljs-number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。<br></code></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ol><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ol><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><h4 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h4><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</p></li><li><p>比如：执行复制、交换、求和等操作</p><p><img src="image-20210825185025622.png" alt="image-20210825185025622"></p></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>Top Of Stack Cashing</p><ol><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li><li>也就是说为了效率更高</li></ol><h3 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h3><ol><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br><br>        methodA();<br><br>        num++;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">10</span>; size <span class="hljs-number">712</span> bytes<br>  MD5 checksum e56913c945f897c7ee6c0a608629bca8<br>  Compiled from <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.DynamicLinkingTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">9.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">8.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// methodA()....</span><br>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">30</span>            <span class="hljs-comment">// methodB()....</span><br>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">8.</span>#<span class="hljs-number">31</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br>   #<span class="hljs-number">8</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest</span><br>   #<span class="hljs-number">9</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>  #<span class="hljs-number">10</span> = Utf8               num<br>  #<span class="hljs-number">11</span> = Utf8               I<br>  #<span class="hljs-number">12</span> = Utf8               &lt;init&gt;<br>  #<span class="hljs-number">13</span> = Utf8               ()V<br>  #<span class="hljs-number">14</span> = Utf8               Code<br>  #<span class="hljs-number">15</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">16</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">17</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;<br>  #<span class="hljs-number">19</span> = Utf8               methodA<br>  #<span class="hljs-number">20</span> = Utf8               methodB<br>  #<span class="hljs-number">21</span> = Utf8               SourceFile<br>  #<span class="hljs-number">22</span> = Utf8               DynamicLinkingTest.java<br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">12</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">10</span>:#<span class="hljs-number">11</span>        <span class="hljs-comment">// num:I</span><br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">27</span> = Utf8               <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">19</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// methodA:()V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.atguigu.java1.DynamicLinkingTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String methodA()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String methodB()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: aload_0<br>         <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method methodA:()V</span><br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        <span class="hljs-number">14</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>所谓的<strong>将这些符号引用转换为调用方法的直接引用</strong>，可以看到代码我们是方法B中调用了方法A，然后在方法B的字节码文件中，可以看到通过invokevirtual指令调用了方法A，而#7所代表的东西，我们可以去看Constant Pool。也就是我们可以将这些符号引用转化为调用方法的直接引用</p><p><img src="image-20210825195923604.png" alt="image-20210825195923604"></p><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h4 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h4><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h4><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><h4 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h4><ol><li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li><li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<strong>非虚方法</strong>。</li><li><strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong>。</li><li>其他方法称为虚方法。</li></ol><hr><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li><p>invokestatic：调用静态方法，解析阶段确定唯一方法版本</p></li><li><p>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</p></li><li><p>invokevirtual：调用所有虚方法</p></li><li><p>invokeinterface：调用接口方法</p></li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong>。</p><h4 id="关于invokedynamic指令"><a href="#关于invokedynamic指令" class="headerlink" title="关于invokedynamic指令"></a>关于invokedynamic指令</h4><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol><hr><p><strong>动态语言和静态语言</strong></p><ol><li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Java：String info=<span class="hljs-string">&quot;atguigu&quot;</span>; <span class="hljs-regexp">//</span>静态类型语言，编译期间就会进行类型检查<br>JS：var name=<span class="hljs-string">&quot;test&quot;</span>;  <span class="hljs-regexp">//</span>运行时才检查，动态语言<br>Python：info=<span class="hljs-number">120.3</span> <span class="hljs-regexp">//</span>运行时才会检查<br></code></pre></td></tr></table></figure><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息也叫做帧数据区</p></blockquote><ol><li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ol><hr><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li><li>lreturn：Long类型</li><li>freturn：Float类型</li><li>dreturn：Double类型</li><li>areturn：引用类型</li><li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li></ol><p><img src="0040.png" alt="img"></p><p>异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul><p>所谓的异常处理表，包含的内容其实就是Java代码层次的try catch，上面说的，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，也就是方法执行过程中抛出的异常没有被catch到，就会终止该方法</p><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><img src="0012.png" alt="img"></p><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>，一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li></ol><p>需要注意的是：<strong>标识符native可以与其它java标识符连用，但是abstract除外</strong></p><p><strong>为什么要使用Native Method</strong></p><ol><li>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</li><li><strong>与Java环境外交互</strong>：<ol><li><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li></ol></li><li><strong>与操作系统的交互</strong>：<ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol></li><li><strong>Sun’s Java</strong><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol></li></ol><p><strong>本地方法的现状</strong>：</p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="image-20210828183928535.png" alt="image-20210828183928535"></p><p><strong>注意事项</strong></p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h3><ol><li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</li><li>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）<ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleHeap</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//属性、成员变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="0002.png" alt="IMG/07、堆.assets/0002.png"></p><h3 id="堆的内存细分"><a href="#堆的内存细分" class="headerlink" title="堆的内存细分"></a>堆的内存细分</h3><p><img src="image-20210827185554979.png" alt="IMG/07、堆.assets/image-20210827185554979.png"></p><p>如图所示，在Java7及之前堆内存逻辑上分为三部分：新生代+老年代+永久代，而在Java8以及之后，永久代被替换成了元空间。</p><h4 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h4><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p><ul><li><strong>-Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li><li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p></li></ol><ul><li><p>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</p></li><li><p>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</p></li></ul><ol><li>默认情况下:<ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul></li></ol><p>如果我们给我们的程序设置xms和xmx都是600m，但是通过Java代码：</p><p><code> Runtime.getRuntime().totalMemory()/1024/1024</code></p><p>得到Java虚拟机中的堆内存总量发现，只有575m，比预计的少了25m，那是因为我们堆的S0和S1区只有一个能用，这是由于垃圾回收的需要导致的。</p><h4 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h4><p><img src="image-20210827190632387.png" alt="IMG/07、堆.assets/image-20210827190632387.png"></p><ol><li>一般来说，新生代和老年代的大小比例为1：2，而新生代里面的Eden：S0：S1&#x3D;8：1：1<ul><li><strong>-XX:NewRatio</strong>&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</li><li><strong>-XX:SurvivorRatio&#x3D;8</strong>，调整新生代内部结构空间比例</li></ul></li><li><strong>几乎所有的Java对象都是在Eden区被new出来的</strong></li><li>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li><li>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</li></ol><h4 id="一般情况下的对象分配"><a href="#一般情况下的对象分配" class="headerlink" title="一般情况下的对象分配"></a>一般情况下的对象分配</h4><ol><li>我们创建的对象，一般都是放在Eden区的，<strong>当我们Eden区满了之后，就会触发GC操作</strong>，此时的GC操作一般称为YGC&#x2F;Minor GC</li><li>当YGC开始的时候，在Eden区过期的对象会被回收，然后没有过期的话就会存放在S0区。同时我们会给每一个对象都设置了一个年龄计数器，如果经过一次YGC之后还没有被回收，就会加1。</li><li>如果年龄计数器到达了15次，就可以进入老年代，可以通过JVM参数设置：**-XX:MaxTenuringThreshold**&#x3D;N。</li><li>同时Eden继续存放对象，当Eden再次满的时候，就会触发YGC操作，此时YGC会将Eden和S0都进行一次垃圾回收，并且将存活的对象放入S1区，然后年龄计数器+1。此时S0区是空的，再下一次垃圾回收的时候，会将存活的对象放入S0区，然后清空S1，以此循环</li><li>如果经过不停的对象生成和垃圾回收，当新生代中的对象的年龄计数器到达15次之后，会触发一次Promotion晋升的操作，将该对象晋升到老年代里面。</li></ol><h4 id="特殊情况下的对象分配"><a href="#特殊情况下的对象分配" class="headerlink" title="特殊情况下的对象分配"></a>特殊情况下的对象分配</h4><ol><li>如果来了一个新对象，要先看Eden区是否放得下<ul><li>如果放得下，就直接放到Eden区</li><li>如果放不下，就触发YGC，执行垃圾回收，再看能否放进去</li></ul></li><li>如果Eden执行了YGC后还是放不到Eden区，就只能看老年代能否放进去，如果老年代也放不进就 进行一次FGC。如果这个时候还是放不下，就只能报OOM错误了</li><li>如果Eden区满了之后触发YGC，将对象放入S0或者S1，但是发现也放不下，就只能晋升至老年代了</li></ol><p><img src="0019.png" alt="IMG/07、堆.assets/0019.png"></p><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><ol><li>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></li><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</li></ol><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h4 id="YoungGC"><a href="#YoungGC" class="headerlink" title="YoungGC"></a>YoungGC</h4><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</li><li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ol><h4 id="Major-x2F-Full-GC"><a href="#Major-x2F-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h4><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li><li>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）<ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li></ul></li><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li><li>如果Major GC后，内存还不足，就报OOM了</li></ol><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><p><strong>分代的原因和作用</strong></p><ol><li>优化GC性能</li><li>如果没有分代的话，就相当于将一个学校的人都关在一个教室里面，不方便管理。GC的时候如果要找到哪些对象没用，这样就会对堆内所有区域进行扫描，导致性能低下</li><li>据研究表明，很多对象都是朝生夕死的，如果分代的话，将新创建的对象放到某一个地方，当GC的时候优先将这块区域进行回收，就会腾出很大的空间来。（多回收新生代，少回收老年代，这样能提升很多性能)。</li></ol><h3 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h3><ol><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ol><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li></ol><h3 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h3><ol><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li></ol><p><img src="image-20210828175838380.png" alt="IMG/07、堆.assets/image-20210828175838380.png"></p><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><blockquote><p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。</p></blockquote><p><strong>TLAB再说明</strong></p><ol><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li><li>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</li><li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</li></ol><p><img src="image-20210828180331700.png" alt="image-20210828180331700"></p><h3 id="堆空间常用参数设置"><a href="#堆空间常用参数设置" class="headerlink" title="堆空间常用参数设置"></a>堆空间常用参数设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试堆空间常用的jvm参数：</span><br><span class="hljs-comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span><br><span class="hljs-comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span><br><span class="hljs-comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span><br><span class="hljs-comment"> *                             jinfo -flag SurvivorRatio 进程id</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span><br><span class="hljs-comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span><br><span class="hljs-comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span><br><span class="hljs-comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span><br><span class="hljs-comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span><br><span class="hljs-comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span><br><span class="hljs-comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span><br><span class="hljs-comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span><br><span class="hljs-comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li>在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li></ol><h3 id="堆是分配对象的唯一选择吗"><a href="#堆是分配对象的唯一选择吗" class="headerlink" title="堆是分配对象的唯一选择吗"></a>堆是分配对象的唯一选择吗</h3><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ol><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><p><strong>逃逸分析举例</strong></p><p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span>? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>() : obj;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br>    <span class="hljs-comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();<br>        <span class="hljs-comment">//getInstance().xxx()同样会发生逃逸</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逃逸分析参数设置</strong></p><ol><li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</li><li>如果使用的是较早的版本，开发人员则可以通过：<ul><li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol><p><strong>总结</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><ol><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol><h4 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h4><ol><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</li><li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</li></ol><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hollis) &#123;<br>        System.out.println(hollis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p><strong>分离对象或标量替换</strong></p><ol><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li></ol><p><strong>标量替换举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li>标量替换为栈上分配提供了很好的基础。</li></ol><p><strong>标量替换参数设置</strong></p><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><h4 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h4><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h3><p><img src="0002-16516620314131.png" alt="img"></p><h4 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h4><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li></ol><h4 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h4><p><strong>方法区中主要存放的是Class，而堆中主要存放的是实例化对象</strong></p><ol><li><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</p></li><li><p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</p></li><li><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p></li><li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutofMemoryError</span>:PermGen space<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>:Metaspace<br></code></pre></td></tr></table></figure><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li><p>关闭JVM就会释放这个区域的内存。</p></li></ol><h4 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h4><ol><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li></ul></li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ol><h4 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h4><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h5 id="JDK7及以前（永久代）"><a href="#JDK7及以前（永久代）" class="headerlink" title="JDK7及以前（永久代）"></a>JDK7及以前（永久代）</h5><ol><li>通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><h5 id="JDK8及以后（元空间）"><a href="#JDK8及以后（元空间）" class="headerlink" title="JDK8及以后（元空间）"></a>JDK8及以后（元空间）</h5><ol><li>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</li><li>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</li></ol><h5 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h5><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><h4 id="方法区存储什么"><a href="#方法区存储什么" class="headerlink" title="方法区存储什么"></a>方法区存储什么</h4><p><img src="image-20210830104459102.png" alt="image-20210830104459102"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><p><img src="image-20210830104538625.png" alt="image-20210830104538625"></p><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ol><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h4 id="non-final类型的类变量"><a href="#non-final类型的类变量" class="headerlink" title="non-final类型的类变量"></a>non-final类型的类变量</h4><ol><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ol><p><strong>举例</strong></p><ol><li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        order.hello();<br>        System.out.println(order.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">hello!<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h5><ol><li>全局常量就是使用 static final 进行修饰</li><li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li></ol><p>查看上面代码，这部分的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    ...<br>&#125;    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br>    descriptor: I<br>    flags: ACC_PUBLIC, ACC_STATIC<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> number;<br>    descriptor: I<br>    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>    ConstantValue: <span class="hljs-type">int</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><h5 id="运行时常量池VS常量池"><a href="#运行时常量池VS常量池" class="headerlink" title="运行时常量池VS常量池"></a>运行时常量池VS常量池</h5><ol><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><ol><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li><li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li></ol><p><img src="image-20210830105414117.png" alt="image-20210830105414117"></p><p><strong>为什么需要常量池？</strong></p><ol><li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</li></ol><p>比如：如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol><p><strong>常量池中有啥？</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p><strong>常量池总结</strong></p><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ol><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li></ol><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul><ol><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><h4 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h4><ol><li>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</li><li>Hotspot中方法区的变化：</li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><p><img src="image-20210830110159922.png" alt="image-20210830110159922"></p><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><p><img src="image-20210830110221095.png" alt="image-20210830110221095"></p><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><p><img src="image-20210830110251768.png" alt="image-20210830110251768"></p><h4 id="永久代为什么要被元空间替代"><a href="#永久代为什么要被元空间替代" class="headerlink" title="永久代为什么要被元空间替代"></a>永久代为什么要被元空间替代</h4><ol><li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li><li><p>这项改动是很有必要的，原因有：</p><ol><li><p>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p></li><li><p>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低Full GC</p><ol><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li></ol></li></ol></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li></ol><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</li><li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</li></ul><h4 id="静态变量放在哪"><a href="#静态变量放在哪" class="headerlink" title="静态变量放在哪"></a>静态变量放在哪</h4><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>。</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><ol><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol><p>下面也称作<strong>类卸载</strong></p><p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><p><img src="image-20210830124820775.png" alt="image-20210830124820775"></p><h1 id="第三章-对象的实例化内存布局与访问定位"><a href="#第三章-对象的实例化内存布局与访问定位" class="headerlink" title="第三章 对象的实例化内存布局与访问定位"></a>第三章 对象的实例化内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><p><img src="image-20210830125356389.png" alt="image-20210830125356389"></p><h2 id="对象创建的方式和步骤"><a href="#对象创建的方式和步骤" class="headerlink" title="对象创建的方式和步骤"></a>对象创建的方式和步骤</h2><p><img src="image-20210830125950217.png" alt="image-20210830125950217"></p><ol><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li><li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li><li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ol><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Object</span><br>         <span class="hljs-number">3</span>: dup           <br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">7</span>: astore_1<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">8</span>       <span class="hljs-number">1</span>     <span class="hljs-number">1</span>   obj   Ljava/lang/Object;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><ol><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ol><p><strong>2、为对象分配内存</strong></p><ol><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ol><p><strong>3、处理并发问题</strong></p><ol><li>采用CAS+失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ol><p><strong>4、初始化分配到的空间</strong></p><ul><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li><li>给对象属性赋值的顺序：</li></ul><ol><li>属性的默认值初始化</li><li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li>构造器初始化</li></ol><p><strong>5、设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p><strong>6、执行init方法进行初始化</strong></p><ol><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li><li>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</li></ol><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="image-20210830130203892.png" alt="image-20210830130203892"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    String name;<br>    Account acct;<br><br>    &#123;<br>        name = <span class="hljs-string">&quot;匿名客户&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;<br>        acct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">cust</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20210830130225530.png" alt="image-20210830130225530"></p><h2 id="对象的访问内存"><a href="#对象的访问内存" class="headerlink" title="对象的访问内存"></a>对象的访问内存</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><p>定位，通过栈上reference访问</p><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><p><strong>1、句柄访问</strong></p><ol><li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><p><img src="image-20210830130431500.png" alt="image-20210830130431500"></p><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><p><img src="image-20210830130447943.png" alt="image-20210830130447943"></p><h1 id="第四章-直接内存"><a href="#第四章-直接内存" class="headerlink" title="第四章 直接内存"></a>第四章 直接内存</h1><h2 id="直接内存概述（了解）"><a href="#直接内存概述（了解）" class="headerlink" title="直接内存概述（了解）"></a>直接内存概述（了解）</h2><ol><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高。</li><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ol><h2 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h2><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><p><img src="0038.png" alt="img"></p><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程</p><p><img src="0039.png" alt="img"></p><h2 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h2><ol><li>直接内存也可能导致OutofMemoryError异常</li><li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li><li>直接内存的缺点为：<ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li>直接内存大小可以通过MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值-Xmx参数值一致</li></ol><h1 id="第五章-执行引擎"><a href="#第五章-执行引擎" class="headerlink" title="第五章 执行引擎"></a>第五章 执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p><img src="image-20210904154047916.png" alt="image-20210904154047916"></p><ol><li>执行引擎是Java虚拟机核心的组成部分之一</li><li>“虚拟机”是要给相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的。而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ol><h3 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h3><p><img src="0003.png" alt="img"></p><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ol><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="image-20210905112032806.png" alt="image-20210905112032806"></p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</p><ol><li>前面橙色部分是编译生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系</li><li>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程。</li></ol><p>Java代码编译是由Java源码编译器来完成，也就是上图橙色所属，流程图如下所示：</p><p><img src="image-20210905112236173.png" alt="image-20210905112236173"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下图所示：</p><p><img src="image-20210905112340252.png" alt="image-20210905112340252"></p><h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><ol><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>JIT编译器：也叫即时编译器，就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ol><p><strong>为什么Java是半编译半解释型语言？</strong></p><ol><li>JDK1.0时代，将Java语言定位为“解释执行”开始比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ol><p><img src="image-20210905113306187.png" alt="image-20210905113306187"></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol><li>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）</li><li>解释器真正的意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ol><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ol><h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ol><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java代码执行的分类"><a href="#Java代码执行的分类" class="headerlink" title="Java代码执行的分类"></a>Java代码执行的分类</h3><ol><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p></li></ol><h3 id="为什么我们还需要解释器"><a href="#为什么我们还需要解释器" class="headerlink" title="为什么我们还需要解释器"></a>为什么我们还需要解释器</h3><ol><li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ol><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li></ul><ol><li>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</li><li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></li></ol><h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><p><strong>典型的编译器：</strong></p><ol><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ol><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol><li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li><li>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</li><li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本<ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ol><p><img src="0013.png" alt="img"></p><h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="image-20210905140917696.png" alt="image-20210905140917696"></p><h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ol><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><p><img src="0015.png" alt="img"></p><p><strong>HotSpotVM JIT 分类</strong></p><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol><h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p></blockquote><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ol><li><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p></li><li><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p></li><li><p>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</p></li><li><p>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p></li></ol><h4 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h4><ul><li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><p>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p></li></ul><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><ol><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p><strong>缺点：</strong></p><ol><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ol><h1 id="第六章-StringTable"><a href="#第六章-StringTable" class="headerlink" title="第六章 StringTable"></a>第六章 StringTable</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ol><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8以及以前内部定义了<code>final char value[]</code> 用于存储字符串数据。JDK9时改为<code>byte[]</code></p></li></ol><h2 id="为什么JDK9改变了String的结构"><a href="#为什么JDK9改变了String的结构" class="headerlink" title="为什么JDK9改变了String的结构"></a>为什么JDK9改变了String的结构</h2><p><strong>为什么改为byte[]存储</strong></p><ol><li>String类的当前实现将字符串存储在char数组中，每个字符使用两个字节（16位）</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费</li><li>之前String类使用UTF-16的char[] 数组存储，现在改为byte[]数组外加 一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是使用其它字符集，比如UTF-8，你仍然用两个字节存。</li><li>结论：<strong>String再也不用char来存储，改为了byte加上编码标记</strong>，节约了 一些空间</li><li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ol><h3 id="String的基本特性-1"><a href="#String的基本特性-1" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul><li>String：代表不可变的字符序列。简称：不可变性<ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li><li>当调用String的replace方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li></ol></li><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><h3 id="String的底层结构"><a href="#String的底层结构" class="headerlink" title="String的底层结构"></a>String的底层结构</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><ol><li>String的StringPool是一个固定大小的HashTable，默认大小为1009。如果放进StringPool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了之后会造成当前调用String.intern()方法是性能会大幅度下降</li><li>使用-XX:StringTablesize可以设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值都是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ol><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><ol><li>在Java语言中有八种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据结构类型的常量池都是系统协调的，String类型的常量池比较特殊。他的主要使用方法有两种。<ol><li>直接使用双引号声明出来的String对象会直接存储在常量池中</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern方法。</li></ol></li><li>Java6以及之前，字符串常量池存放在永久代</li><li>Java7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<ul><li>所有的字符串都保存在堆中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()</li></ul></li><li>Java8元空间，字符串常量在堆</li></ol><h3 id="StringTable为什么要调整？"><a href="#StringTable为什么要调整？" class="headerlink" title="StringTable为什么要调整？"></a>StringTable为什么要调整？</h3><blockquote><p>In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the method will see more significant differences.<code>String.intern()</code></p></blockquote><ol><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li></ul></li><li>在JDK7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和老年代）中分配，与应用程序创建的其他对象一起分配</li><li>此更改导致驻留在主Java堆中的数据更多，驻留在永久代中的数据更少，因此可能需要调整堆大小。</li></ol><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ol><li>常量与常量的拼接结果在常量池中，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern方法，根据该字符串是否在常量池中存在，分为：<ol><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop&quot;</span>;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;<span class="hljs-comment">//编译期优化</span><br>    <span class="hljs-comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + s2;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s7</span> <span class="hljs-operator">=</span> s1 + s2;<br><br>    System.out.println(s3 == s4);<span class="hljs-comment">//true</span><br>    System.out.println(s3 == s5);<span class="hljs-comment">//false</span><br>    System.out.println(s3 == s6);<span class="hljs-comment">//false</span><br>    System.out.println(s3 == s7);<span class="hljs-comment">//false</span><br>    System.out.println(s5 == s6);<span class="hljs-comment">//false</span><br>    System.out.println(s5 == s7);<span class="hljs-comment">//false</span><br>    System.out.println(s6 == s7);<span class="hljs-comment">//false</span><br>    <span class="hljs-comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span><br>    <span class="hljs-comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> s6.intern();<br>    System.out.println(s3 == s8);<span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span><br><span class="hljs-comment">        ① StringBuilder s = new StringBuilder();</span><br><span class="hljs-comment">        ② s.append(&quot;a&quot;)</span><br><span class="hljs-comment">        ③ s.append(&quot;b&quot;)</span><br><span class="hljs-comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<span class="hljs-comment">//</span><br>    System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span><br><span class="hljs-comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span><br><span class="hljs-comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<br>    System.out.println(s3 == s4);<span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拼接操作与append操作的效率对比"><a href="#拼接操作与append操作的效率对比" class="headerlink" title="拼接操作与append操作的效率对比"></a>拼接操作与append操作的效率对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//        method1(100000);//4014</span><br>    method2(<span class="hljs-number">100000</span>);<span class="hljs-comment">//7</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; highLevel;i++)&#123;<br>        src = src + <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//每次循环都会创建一个StringBuilder、String</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;<br>    <span class="hljs-comment">//只需要创建一个StringBuilder</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;<br>        src.append(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过StringBuilder的append()方式添加字符串的效率要远高于使用String的字符串拼接方式</li><li>原因：<ol><li>StringBuilder的append方式自始自终只创建过一个StringBuilder的对象</li><li>使用String的字符串拼接方式创建过多个StringBuilder和String（调的toString方法）的对象，内存占用要更大；如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）</li></ol></li><li>改进的空间：<ol><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li><li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li><li>这样可以避免频繁扩容</li></ol></li></ol><h2 id="intern的使用"><a href="#intern的使用" class="headerlink" title="intern的使用"></a>intern的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern()方法的说明"></a>intern()方法的说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol><li>intern是一个native方法，调用的是底层C的方法</li><li>字符串常量池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则该字符串对象将被添加到常量池中，并返回对该字符串对象的地址。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li><li>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</li><li>通俗点讲，interned String就是确保字符串在内存中只有一份拷贝，这样就可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被放到字符串内部池（Stirng intern Pool）</li></ol><h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String()的说明"></a>new String()的说明</h3><p><strong>new String(“ab”)会创建几个对象？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">两个：</span><br><span class="hljs-comment">    一个是new关键字在堆空间创建的</span><br><span class="hljs-comment">    另一个对象是：字符串常量池中的对象“ab”。字节码指令：ldc</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new String(“a”) + new String(“b”) 会创建几个对象？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 思考：</span><br><span class="hljs-comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span><br><span class="hljs-comment"> *  对象1：new StringBuilder()</span><br><span class="hljs-comment"> *  对象2： new String(&quot;a&quot;)</span><br><span class="hljs-comment"> *  对象3： 常量池中的&quot;a&quot;</span><br><span class="hljs-comment"> *  对象4： new String(&quot;b&quot;)</span><br><span class="hljs-comment"> *  对象5： 常量池中的&quot;b&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  深入剖析： StringBuilder的toString():</span><br><span class="hljs-comment"> *      对象6 ：new String(&quot;ab&quot;)</span><br><span class="hljs-comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h3><p><strong>执行s3.intern()，而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（”11”）了，出于节省空间的目的，直接将堆中的字符串的引用地址储存在字符串常量池中。没错，字符串常量池中存的是new String（”11”）在堆中的地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span><br><span class="hljs-comment"> * 有两种方式：</span><br><span class="hljs-comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span><br><span class="hljs-comment"> * 方式二： 调用intern()</span><br><span class="hljs-comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span><br><span class="hljs-comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        s.intern();<span class="hljs-comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        System.out.println(s == s2);<span class="hljs-comment">//jdk6：false   jdk7/8：false</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span><br><span class="hljs-comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，</span><br><span class="hljs-comment">             在堆中有了一个new String(&quot;11&quot;)</span><br><span class="hljs-comment">             这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span><br><span class="hljs-comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span><br><span class="hljs-comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，</span><br><span class="hljs-comment">                   所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span><br><span class="hljs-comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，</span><br><span class="hljs-comment">                   此时堆里已经有new String（&quot;11&quot;）了</span><br><span class="hljs-comment">                   出于节省空间的目的，直接将堆中的字符串的引用地址储存在字符串常量池中。</span><br><span class="hljs-comment">                   没错，字符串常量池中存的是new String（&quot;11&quot;）在堆中的地址</span><br><span class="hljs-comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//pos_1</span><br>        s3.intern();<br><br>        <span class="hljs-comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<br>        System.out.println(s3 == s4);<span class="hljs-comment">//jdk6：false  jdk7/8：true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存分析</strong></p><p>JDK6：</p><p><img src="0013-16516626421232.png" alt="img"></p><p>JDK7以及以后：</p><p><img src="0014.png" alt="img"></p><h3 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">// 执行完上一行代码后，字符串常量池中并没有出现“11”</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s3.intern();<br><br>        <span class="hljs-comment">// s3是堆中的&quot;11&quot;，s4是字符串常量池中的&quot;11&quot;</span><br>        System.out.println(s3 == s4); <span class="hljs-comment">//false</span><br><br>        System.out.println(s5 == s4);<span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果将s5和s4的语句交换位置，就会导致两个都输出true</p><h3 id="intern方法的练习题"><a href="#intern方法的练习题" class="headerlink" title="intern方法的练习题"></a>intern方法的练习题</h3><p><img src="0017.png" alt="img"></p><h3 id="intern的效率测试（空间角度）"><a href="#intern的效率测试（空间角度）" class="headerlink" title="intern的效率测试（空间角度）"></a>intern的效率测试（空间角度）</h3><p>结论：</p><p>1、<strong>对于程序中大量存在的字符串，尤其其中存在很多重复的字符串时，使用intern</strong></p><p>2、大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p><strong>String去重操作的背景</strong></p><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><p><strong>String 去重的的实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><ol><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol><h1 id="第七章-垃圾回收"><a href="#第七章-垃圾回收" class="headerlink" title="第七章 垃圾回收"></a>第七章 垃圾回收</h1><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><ol><li>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</li><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li></ol><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><ol><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>如果不及时堆内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间就会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ol><h3 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h3><ol><li>对于高级语言来说，一个基本认知就是如果不进行垃圾回收，<strong>内存迟早会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不进行打扫一样。</li><li>除了释放没有用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂、用户越来越多，<strong>没有GC就不能保证应用程序的正常运行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试堆GC进行优化。</li></ol><h3 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h3><ol><li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。</li><li>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担。</strong>倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗费的内存可能持续上升，知道出现内存溢出并造成<strong>应用程序崩溃</strong>。</li><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和垃圾回收方式已经成为了现代开发语言必备的标准。</li></ol><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><h4 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h4><p><strong>自动内存管理的优点</strong></p><ol><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ol><p><strong>关于自动内存管理的担忧</strong></p><ol><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ol><h4 id="应该关系哪些区域的回收"><a href="#应该关系哪些区域的回收" class="headerlink" title="应该关系哪些区域的回收"></a>应该关系哪些区域的回收</h4><ol><li>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</li><li>其中，<strong>Java堆是垃圾收集器的工作重点</strong></li><li>从次数上讲：<ol><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ol></li></ol><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h3><h4 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h4><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ol><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC才会在执行垃圾回收的时候，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></li></ol><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ol><li><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p></li><li><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p></li><li><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</p></li><li><p>缺点：</p><ol><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法，这增加了<strong>时间开销</strong></li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用的问题</strong>，这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</li></ol></li></ol><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p><img src="0004.png" alt="img"></p><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏。</p><p>这里的内存泄露并不是Java中的内存泄露。面试中不可以用这个例子进行举例</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业务有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系</li><li>Python如何解决循环引用？<ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用</li></ul></li></ol><h3 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h3><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ol><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，最重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ol><h4 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h4><ul><li>所谓“GCRoots”根集合就是一组必须活跃的引用</li><li>其基本思路如下：<ol><li>可达性分析算法是以跟对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象。</li></ol></li></ul><p><img src="image-20210909162516777.png" alt="IMG/13、垃圾回收概述和垃圾回收算法.assets/image-20210909162516777.png"></p><h4 id="GCRoots可以是哪些元素？"><a href="#GCRoots可以是哪些元素？" class="headerlink" title="GCRoots可以是哪些元素？"></a>GCRoots可以是哪些元素？</h4><ol><li>虚拟机栈中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等。</li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象：Java类的引用类型静态变量</li><li>方法区中常量引用的对象：字符串常量池里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器</li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ol><hr><ol><li>总结一句话就是，除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</li><li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“<strong>临时性</strong>”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。<ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul></li></ol><p><strong>小技巧</strong></p><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ol><h3 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><h4 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h4><p><strong>对象销毁前的回调函数：finalize()</strong></p><ol><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ol><p>Object 类中 finalize() 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待被重写</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><ol><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ol></li><li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ol><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ol><li><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。</p><p>一个无法触及的对象有可能在某一个条件下“复活”自己</p><p>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：</p><ol><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol></li><li><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></li></ol><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ol><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ol></li></ol><h3 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h3><p><strong>垃圾清除阶段</strong></p><ul><li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li></ul><ol><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ol><p><strong>背景</strong></p><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><p><strong>执行过程</strong></p><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ol><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ol><p><img src="0029.png" alt="IMG/13、垃圾回收概述和垃圾回收算法.assets/0029.png"></p><p><strong>标记-清除算法的缺点</strong></p><ol><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ol><p><strong>注意：何为清除？</strong></p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ol><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个空闲列表</li><li>采用空闲列表分配内存</li></ul></li></ol><h3 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h3><p><strong>背景</strong></p><ol><li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ol><p><strong>核心思想</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="0030.png" alt="IMG/13、垃圾回收概述和垃圾回收算法.assets/0030.png"></p><p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p><p><strong>复制算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ol><p><strong>缺点</strong></p><ol><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ol><p><strong>复制算法的应用场景</strong></p><ol><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ol><h3 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h3><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><p><strong>背景</strong></p><ol><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></li><li>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</li><li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ol><p><strong>执行过程</strong></p><ol><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li></ol><p><img src="0032.png" alt="IMG/13、垃圾回收概述和垃圾回收算法.assets/0032.png"></p><p><strong>标记-压缩算法与标记-清除算法的比较</strong></p><ol><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ol><p><strong>标记-压缩算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ol><p><strong>缺点</strong></p><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ol><h3 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h3><blockquote><p><strong>对比三种清除阶段的算法</strong></p></blockquote><ol><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</li><li>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</li></ol><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ol><li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li><li>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li><li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:<ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ol><p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ol><li>年轻代（Young Gen）<ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li><li>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li><li>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</li></ol><h3 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h3><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p><strong>增量收集算法基本思想</strong></p><ol><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li><li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li></ol><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><blockquote><p>主要针对G1收集器来说的</p></blockquote><ol><li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ol><p><img src="0033.png" alt="IMG/13、垃圾回收概述和垃圾回收算法.assets/0033.png"></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p><h1 id="第八章-垃圾回收相关概念"><a href="#第八章-垃圾回收相关概念" class="headerlink" title="第八章 垃圾回收相关概念"></a>第八章 垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><ol><li>默认情况下，通过System.gc()者Runtime.getRuntime().gc()的调用，<strong>会显示触发FullGC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li><li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用（不能确保立即生效）</li><li>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无法手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()；</li></ol><h3 id="手动GC理解不可达对象的回收行为"><a href="#手动GC理解不可达对象的回收行为" class="headerlink" title="手动GC理解不可达对象的回收行为"></a>手动GC理解不可达对象的回收行为</h3><p>运行时的JVM参数设置</p><p><code>-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</code></p><p>第四个参数设置大对象直接进行老年代的阈值</p><p>1、buffer数组对象仅仅将年轻代的buffer数组对象放到了老年代，buffer对象仍然没有回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 10MB</span><br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><p>2、buffer对象没有引用指向它，可能会被gc回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>    buffer = <span class="hljs-literal">null</span>;<br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><p>3、虽然出了代码块的作用域，但是buffer数组对象并没有被回收</p><p>这就需要局部变量表的插槽机制了，虽然buffer超出了作用域范围，但是仍然占据了第1个插槽的位置（第0个是this），只是没有显示出来，执行gc的时候，实际上栈中还有buffer变量指向堆中的字节数组，所以没有gc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC3</span><span class="hljs-params">()</span> &#123;<br>    &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>    &#125;<br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><p>4、这里的buffer会被回收，因为buffer的索引位置会被value所占用，因此就没有引用指向buffe所指的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC4</span><span class="hljs-params">()</span> &#123;<br>    &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><p>5、局部变量出了方法范围就是失效了，堆中的字节数组被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC5</span><span class="hljs-params">()</span> &#123;<br>    localvarGC1();<br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经更不上内存消耗的速度，否则不太容易出现OOM的情况</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的FullGC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ol><p><strong>内存溢出的原因分析</strong></p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够</p><ol><li><p>Java虚拟机的堆内存设置不够。</p><ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较客观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整</li></ul></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出现和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息变成了：”java.lang.OutOfMemoryError:Metaspace”。直接内存不足，也会导致OOM</li></ul></li><li><p>这里隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ol><li>例如：在引用机制分析中，涉及到JVM去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在java.nio.Bits.reserveMemory()方法中，我们能清除看到，System.gc()会被调用，以清理空间。</li></ol></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的：比如我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集器并不能解决这个问题，所以直接抛出OOM</p></li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li>也称作”存储渗漏“，严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</li><li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</li><li>尽管内存泄漏并不会立即引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是值物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ol><p><strong>内存泄漏官方例子</strong></p><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><p><img src="0006.png" alt="IMG/14、垃圾回收相关概念.assets/0006.png"></p><p><strong>常见例子</strong></p><ol><li>单例模式<ul><li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>数据库连接dataSource.getConnection()，网络连接socker和io连接必须手动close，否则是不能被回收的。</li></ul></li></ol><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><ol><li><p>简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉。</p></li><li><p>可达性分析算法中枚举根节点（GCRoots）会导致所有Java执行线程停顿，为什么需要停顿所有Java执行线程呢？</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果准确性无法保证</strong></li></ul></li><li><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生</p></li><li><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p></li><li><p>哪怕是G1也不能完全避免STW情况的发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间</p></li><li><p>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p></li><li><p>开发中不要用System.gc()，这会导致STW的发生</p></li></ol><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol><li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</li><li>并发不是真正意义上的同时进行，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时进行</li></ol><p><img src="image-20210910101637422.png" alt="IMG/14、垃圾回收相关概念.assets/image-20210910101637422.png"></p><h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><ol><li>当系统有一个以上的CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互相不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ol><p><img src="image-20210910101832115.png" alt="IMG/14、垃圾回收相关概念.assets/image-20210910101832115.png"></p><blockquote><p>并行与并发的对比</p></blockquote><ol><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态<ul><li>如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ol><p><img src="image-20210910102113842.png" alt="IMG/14、垃圾回收相关概念.assets/image-20210910102113842.png"></p><p>并行和并发，在谈论垃圾收集器的上下文语境中，他们可以解释如下：</p><ol><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul><li>比如用户程序在继续运行，而垃圾收集器程序线程运行于另一个CPU上；</li></ul></li><li>典型垃圾回收器：CMS、G1</li></ol><p><img src="image-20210910102356847.png" alt="IMG/14、垃圾回收相关概念.assets/image-20210910102356847.png"></p><h2 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><ol><li><p>固定可作为GCRoots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。</p></li><li><p>迄今为止，<strong>所有垃圾收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的STW的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p><p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p><blockquote><p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p></blockquote></li></ol><h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点（Safepoint）</strong></p><ol><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</li><li>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</li></ol><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ol><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ol><p><strong>安全区域（Safe Region）</strong></p><ol><li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ol><p><strong>安全区域的执行流程</strong></p><ol><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h4><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><p><img src="image-20210910104835512.png" alt="IMG/14、垃圾回收相关概念.assets/image-20210910104835512.png"></p><p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p><p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p><p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></p><h4 id="记忆集与卡集"><a href="#记忆集与卡集" class="headerlink" title="记忆集与卡集"></a>记忆集与卡集</h4><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p><p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><blockquote><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></blockquote><p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p><blockquote><p>读者只需要知道有这个东西，面试的时候能说出来，再细致一点的就需要看周志明老师的第三版书了</p></blockquote><h2 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h2><ol><li>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li><li>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</li><li>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：<ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul></li><li>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</li></ol><p><img src="0012-16516627146513.png" alt="img"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ol><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><ol><li>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</li><li>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</li><li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ol><p><strong>总结</strong></p><ol><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ol><h2 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h2><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ol><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li><li>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</li></ol><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 声明强引用</span><br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用</span><br></code></pre></td></tr></table></figure><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p><strong>弱引用（Weak Reference）发现即回收</strong></p></blockquote><ol><li>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ol><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用Copy to clipboardErrorCopied</span><br></code></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ol><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></li><li><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ol><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 声明引用队列</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span><br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>; <br></code></pre></td></tr></table></figure><h2 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h2><ol><li>它用于实现对象的finalize() 方法，也可以称为终结器引用</li><li>无需手动编码，其内部配合引用队列使用</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</li></ol><h1 id="第九章-垃圾回收器"><a href="#第九章-垃圾回收器" class="headerlink" title="第九章 垃圾回收器"></a>第九章 垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><ol><li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同的版本JVM来实现</li><li>由于JDK版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本</li><li>从不同角度分析垃圾收集器，可以将GC分为不同的类型</li></ol><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器</strong></p><ol><li>串行回收指的是在同一时间段只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束<ol><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li></ol></li><li>和串行回收器相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提高了应用的吞吐量，不过并行回收依然与串行回收器一样，采用独占式，使用了STW机制</li></ol><p><strong>按工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器</strong></p><ol><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（STW）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程结束</li></ol><p><img src="image-20210910185741502.png" alt="img"></p><p><strong>按碎片处理方式分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器</strong></p><ol><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间。使用指针碰撞。</li><li>非压缩式的垃圾回收器不会进行这步操作，分配对象空间。使用空闲列表</li></ol><p><strong>按工作的内存区间分，可分为年轻代垃圾回收和老年代垃圾回收</strong></p><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ol><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率</li><li><strong>内存占用</strong>：Java堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ol><ul><li>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li><li>这三项里，暂停时间的重要性日益凸显。因为随着硬件的发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大对延迟反而带来负面效果。</li><li>简单来说抓住两点：吞吐量、暂停时间</li></ul><h4 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h4><ol><li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F; （运行用户代码时间+垃圾收集时间）</li><li>这种情况下，应用程序能容忍较高的暂停时间，因此，吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</li><li>吞吐量优先意味着在单位时间内，STW时间最短</li></ol><p><img src="image-20210910191705132.png" alt="image-20210910191705132"></p><h4 id="暂停时间（paus-time）"><a href="#暂停时间（paus-time）" class="headerlink" title="暂停时间（paus time）"></a>暂停时间（paus time）</h4><ol><li>暂停时间是值一个时间段内应用程序线程暂停，让GC线程执行的状态。</li><li>暂停时间优先意味着尽可能让单次STW的时间最短，但是总的GC时间可能会长</li></ol><p><img src="0004-16516627404644.png" alt="img"></p><h4 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h4><ol><li><strong>高吞吐量较好</strong>：因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快</li><li>低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）</li><li>不幸的是高吞吐量和低暂停时间是一对相互竞争的目标<ul><li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长时间的暂停时间来执行内存回收</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</li></ul></li><li>在设计或使用GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一、或者尝试找到有一个二者的折中</li><li>现在的标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></li></ol><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><ol><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率</li><li>那么Java常见的垃圾收集器有哪些？</li></ol><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector</p><ol><li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li><strong>Parallel GC在JDK6之后成为HotSpot默认GC</strong>。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li><strong>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS</strong>。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，<strong>JDK14发布。删除CMS垃圾回收器</strong>。扩展ZGC在macOS和Windows上的应用</li></ol><h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li></ol><p><strong>7款经典回收器与垃圾分代之间的关系</strong></p><p><img src="0007.png" alt="img"></p><ol><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial old、Parallel old、CMS；</li><li>整堆收集器：G1；</li></ol><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="0008.png" alt="img"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：<ul><li>Serial&#x2F;Serial old</li><li>Serial&#x2F;CMS （JDK9废弃）</li><li>ParNew&#x2F;Serial Old （JDK9废弃）</li><li>ParNew&#x2F;CMS</li><li>Parallel Scavenge&#x2F;Serial Old （预计废弃）</li><li>Parallel Scavenge&#x2F;Parallel Old</li><li>G1</li></ul></li><li>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol><ul><li>为什么要有很多收集器，一个不够用吗？因为Java的使用场景很多，移动端、服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能</li><li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海而皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong></li></ul><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ol><li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li></ol><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><ol><li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择</li><li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器</li><li>Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收。</li><li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法</li><li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel Scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</li></ol><p>这个收集器是一个单线程的收集器，单线程的意义：他只会使用一个CPU（串行）或者一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><img src="0011-16516627404645.png" alt="img"></p><p><strong>Serial 回收器的优势</strong></p><ol><li>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，运行在Client模式下的虚拟机是个不错的选择</li><li>在用户的桌面应用场景中，可用内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li><li>在HotSpot虚拟机中，使用-XX:UseSerialGC参数可以指定年轻代和老年代都是用串行收集器，等价于新生代用SerialGC，且老年代使用SerialOldGC</li></ol><p><strong>总结</strong></p><ol><li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在JavaWeb应用程序中是不会采用串行垃圾收集器的。</li></ol><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><ol><li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器则是Serial收集器的多线程版本<ul><li>Par是Parallel的缩写，New：只能处理新生代</li></ul></li><li>ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别，ParNew收集器在年轻代中同样也是采用复制算法、STW机制</li><li>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</li></ol><p><img src="0012-16516627404646.png" alt="img"></p><ol><li>对于新生代，回收次数频繁，使用并行方式高效</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ol><p><strong>ParNew回收器与Serial回收器比较</strong></p><p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><p>A：<strong>不能</strong></p><ol><li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li><li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ol><p><strong>设置ParNew垃圾回收器</strong></p><ol><li>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</li><li>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</li></ol><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，ParallelScavenge收集器同样也采用了复制算法、并行回收和STW机制</p><p>那么Parallel收集器的出现是否多次一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>，它也被称为吞吐量优先的垃圾收集器</li><li>自适应调节策略也是ParallelScavenge与ParNew一个重要的区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）</li></ul><p>高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Paraller收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的SerialOld收集器。</p><p>ParallelOld收集器采用了标记压缩算法，但同样也是基于并行回收和STW机制</p><p><img src="0013-16516627404647.png" alt="img"></p><ol><li>在程序吞吐量优先的应用场景中，Parallel收集器和ParallelOld收集器的组合，在Server模式下的内存回收性能很不错</li><li><strong>在Java8中，默认是此垃圾收集器</strong></li></ol><p><strong>Parallel Scavenge 回收参数设置</strong></p><ol><li><p>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li><li><p>-XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代</li><li>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><ol><li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</li><li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</li></ol></li><li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p><ol><li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li><li>该参数使用需谨慎。</li></ol></li><li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 &#x2F; (N+1) ，用于衡量吞吐量的大小。</p><ol><li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</li><li>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</li></ol></li><li><p>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><ol><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li></ol></li></ol><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><h3 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h3><ol><li>在JDK1.5时期，HotSpot推出了一款在<strong>强交互应用中（就是和用户打交道的应用）</strong>，几乎可以认为具有划时代意义的垃圾收集器：CMS（ConcurrentMarkSweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong></li><li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul><li>目前很大一部分的Java应用集中在互联网站或者BS系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul></li><li>CMS的垃圾收集算法采用标记清除算法，并且也会STW</li><li>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4中已经存在的新生代收集器ParallelScavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</li><li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然还有很多系统使用CMSGC</li></ol><h3 id="CMS工作原理（过程）"><a href="#CMS工作原理（过程）" class="headerlink" title="CMS工作原理（过程）"></a>CMS工作原理（过程）</h3><p><img src="0014-16516627404648.png" alt="img"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段（涉及STW的阶段主要是：初始标记和重新标记）</p><ol><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联的对象比较小，所以这里的<strong>速度非常快</strong></li><li>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li></ol><h3 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h3><ol><li>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li><li><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li><li>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<strong>而是当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<strong>“Concurrent Mode Failure”</strong> 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li></ol><p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用</p><h3 id="CMS的优点与弊端"><a href="#CMS的优点与弊端" class="headerlink" title="CMS的优点与弊端"></a>CMS的优点与弊端</h3><p><strong>优点</strong></p><ol><li>并发收集</li><li>低延迟</li></ol><p><strong>弊端</strong></p><ol><li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提案触发FullGC</li><li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，他虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</li><li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现”Concurrent Mode Failure“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ol><h3 id="CMS参数配置"><a href="#CMS参数配置" class="headerlink" title="CMS参数配置"></a>CMS参数配置</h3><ul><li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。</p><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</p></li><li><p>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p></li></ul><ol><li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p></li><li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</p></li></ol><ul><li><p>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads：设置CMS的线程数量。</p></li></ul><ol><li>CMS默认启动的线程数是 (ParallelGCThreads + 3) &#x2F; 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><ol><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ol><h3 id="JDK后续版本中的CMS变化"><a href="#JDK后续版本中的CMS变化" class="headerlink" title="JDK后续版本中的CMS变化"></a>JDK后续版本中的CMS变化</h3><ol><li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul><li>如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul></li></ol><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h3><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p><ol><li>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li><li>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li><li>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li><li>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li></ol><h3 id="为什么名字叫Garbage-First呢？"><a href="#为什么名字叫Garbage-First呢？" class="headerlink" title="为什么名字叫Garbage First呢？"></a>为什么名字叫Garbage First呢？</h3><ol><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li><li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong>。</li><li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用-XX:+UseG1GC来启用。</li></ol><h3 id="G1回收器的优势"><a href="#G1回收器的优势" class="headerlink" title="G1回收器的优势"></a>G1回收器的优势</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><ol><li>并行与并发兼备<ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li>分代收集<ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul></li></ol><p>G1的分代，已经不是下面这样的了</p><p><img src="0016.png" alt="img"></p><p>G1的分区是这样的一个区域</p><p><img src="0017-16516627404649.png" alt="img"></p><p><strong>空间整合</strong></p><ol><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ol><h3 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h3><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ol><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ol><h3 id="G1回收器的缺点"><a href="#G1回收器的缺点" class="headerlink" title="G1回收器的缺点"></a>G1回收器的缺点</h3><ol><li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ol><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</li><li>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms</li><li>-XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右。</li><li>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ol><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p><h3 id="G1的适用场景"><a href="#G1的适用场景" class="headerlink" title="G1的适用场景"></a>G1的适用场景</h3><ol><li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul><li>超过50%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于0.5至1秒）</li></ul></li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ol><h3 id="分区Region"><a href="#分区Region" class="headerlink" title="分区Region"></a>分区Region</h3><p><strong>分区 Region：化整为零</strong></p><ol><li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p></li><li><p>XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p></li><li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p><blockquote><p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>: <strong>The G1 Garbage Collector Step by Step</strong></p><p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p><p>翻译：</p><p>如图所示，可以将区域分配到Eden，幸存者和旧时代区域。 此外，还有第四种类型的物体被称为巨大区域。 这些区域旨在容纳标准区域大小的50％或更大的对象。 它们存储为一组连续区域。 最后，最后一种区域类型是堆的未使用区域。</p></blockquote><p><img src="0018.png" alt="img"></p></li></ol><p><strong>设置 H 的原因</strong></p><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果<strong>它是一个短期存在的大对象</strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如<strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>Regio的细节</strong></p><p><img src="0019-165166274046510.png" alt="img"></p><ol><li>每个Region都是通过指针碰撞来分配空间</li><li>G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li>TLAB还是用来保证并发性</li></ol><h3 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a>G1垃圾回收流程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><p><img src="0020.png" alt="img"></p><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p><p><strong>回收流程</strong></p><ol><li>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</li><li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li><li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li><li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li></ol><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><ol><li>一个对象被不同区域引用的问题</li><li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</li><li>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</li></ol><p><strong>解决方法：</strong></p><ol><li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；</li><li>每个Region都有一个对应的Remembered Set</li><li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li><li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li></ol><p><img src="0021.png" alt="img"></p><ol><li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li><li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li><li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li><li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li></ol><h3 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a>G1回收过程一：年轻代GC</h3><ol><li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li><li>年轻代回收只回收Eden区和Survivor区</li><li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li></ol><p><img src="0022.png" alt="img"></p><p>图的大致意思就是：</p><p>1、回收完E和S区，剩余存活的对象会复制到新的S区</p><p>2、S区达到一定的阈值可以晋升为O区</p><p><strong>细致过程：</strong></p><p><strong>然后开始如下回收过程：</strong></p><ol><li><p>第一阶段，扫描根</p><p>根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p></li><li><p>第二阶段，更新RSet</p></li><li><p>第三阶段，处理RSet</p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p></li><li><p>第四阶段，复制对象。</p><ul><li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li><li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul></li><li><p>第五阶段，处理引用</p><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ol><p><strong>备注：</strong></p><ol><li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）&#x3D;object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li><li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li></ol><h3 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h3><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li><li>并发标记（Concurrent Marking）：<ol><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li><li><strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong></li><li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li></ol></li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h3><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="0023.png" alt="img"></p><p><strong>混合回收的细节</strong></p><ol><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ol><h3 id="G1回收可选的过程四：Full-GC"><a href="#G1回收可选的过程四：Full-GC" class="headerlink" title="G1回收可选的过程四：Full GC"></a>G1回收可选的过程四：Full GC</h3><ol><li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li><li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li></ol><p>导致G1 Full GC的原因可能有两个：</p><ol><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ol><h3 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h3><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。</strong>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p><strong>G1 回收器的优化建议</strong></p><ol><li>年轻代大小<ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7种垃圾回收器的比较"><a href="#7种垃圾回收器的比较" class="headerlink" title="7种垃圾回收器的比较"></a>7种垃圾回收器的比较</h3><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><img src="0034.jpg" alt="img"> <img src="0024.png" alt="img"></p><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集算法</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><ol><li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li><li>这里较通用、基础性的部分如下：<ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><blockquote><p><strong>GC 日志参数设置</strong></p></blockquote><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGCDetails ：输出GC的详细日志</li><li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li>-Xloggc:…&#x2F;logs&#x2F;gc.log ：日志文件的输出路径</li></ol><blockquote><p><strong>verbose:gc</strong></p></blockquote><p>1、JVM 参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-verbose:gc</span><br></code></pre></td></tr></table></figure><p>2、这个只会显示总的GC堆的变化，如下：</p><p><img src="0025.png" alt="img"></p><p>3、参数解析</p><p><img src="0026.png" alt="img"></p><blockquote><p><strong>PrintGCDetails</strong></p></blockquote><p>1、JVM 参数</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span><br></code></pre></td></tr></table></figure><p>2、输入信息如下</p><p><img src="0027.png" alt="img"></p><p>3、参数解析</p><p><img src="0028.png" alt="img"></p><blockquote><p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p></blockquote><p>1、JVM 参数</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCTimeStamps</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDateStamps</span><br></code></pre></td></tr></table></figure><p>2、输出信息如下</p><p><img src="0029-165166274046511.png" alt="img"></p><p>3、说明：日志带上了日期和时间</p><h3 id="GC日志补充说明"><a href="#GC日志补充说明" class="headerlink" title="GC日志补充说明"></a>GC日志补充说明</h3><ol><li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li><li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li><li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</li></ol><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p><img src="0030-165166274046612.png" alt="img"></p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p><img src="0031.png" alt="img"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在jdk7 和 jdk8中分别执行</span><br><span class="hljs-comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCLogTest1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAllocation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] allocation1, allocation2, allocation3, allocation4;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * _1MB];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] agrs)</span> &#123;<br>        testAllocation();<br>    &#125;<br>&#125;Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><strong>JDK7 中的情况</strong></p><p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><p><img src="0032-165166274046613.png" alt="img"></p><p>2、然后我们将4M对象存入到Eden区中</p><p><img src="0033-165166274046614.png" alt="img"></p><p>老年代图画的有问题，free应该是4M</p><p><strong>JDK8 中的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">com.atguigu.java.GCLogTest1<br>[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="hljs-number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="hljs-number">0.0035169</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>Heap<br> def <span class="hljs-keyword">new</span> <span class="hljs-title class_">generation</span>   total 9216K, used 7050K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">77</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff23b668</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,  <span class="hljs-number">65</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff5a71d8</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br> tenured generation   total 10240K, used 4096K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,  <span class="hljs-number">40</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffa00020</span>, <span class="hljs-number">0x00000000ffa00200</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K<br><br>Process finished with exit code <span class="hljs-number">0</span><br>Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p><img src="0035.jpg" alt="img"></p><p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p><h3 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h3><p><strong>保存日志文件</strong></p><p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>， .&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p><p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>推荐：GCeasy</strong></p><p>在线分析网址：gceasy.io</p><p><img src="0036.jpg" alt="img"> <img src="0037.png" alt="img"> <img src="0038-165166274046615.png" alt="img"></p><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><ol><li>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li><li>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</li><li>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li><li>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</li></ol><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><ol><li>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</li><li>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</li><li>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</li></ol><p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p><ol><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><p><img src="0039-165166274046616.png" alt="img"></p><p>总结</p><ol><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项：低延迟时间。</li></ol><h3 id="令人震惊、革命性的ZGC"><a href="#令人震惊、革命性的ZGC" class="headerlink" title="令人震惊、革命性的ZGC"></a>令人震惊、革命性的ZGC</h3><ol><li>官方文档：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></li><li>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</li><li>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</li><li>ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。</li><li>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li></ol><p><strong>吞吐量</strong></p><p><img src="0040-165166274046617.png" alt="img"></p><p>max-JOPS：以低延迟为首要前提下的数据</p><p>critical-JOPS：不考虑低延迟下的数据</p><p><strong>低延迟</strong></p><p><img src="0041.png" alt="img"></p><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><p><img src="0042.png" alt="img"></p><ol><li><p>JDK14之前，ZGC仅Linux才支持。</p></li><li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p></li><li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p><p>-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p></li></ol><h3 id="面向大堆的AliGC"><a href="#面向大堆的AliGC" class="headerlink" title="面向大堆的AliGC"></a>面向大堆的AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="image-20230406233123757.png" alt="image-20230406233123757"></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ常见面试题</title>
    <link href="/RabbitMQ/RabbitMQ%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/RabbitMQ/RabbitMQ%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-1-springboot整合"><a href="#1-1-springboot整合" class="headerlink" title="1.1 springboot整合"></a>1.1 springboot整合</h3><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、配置文件中进行相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.118</span><span class="hljs-number">.128</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启发送端消息抵达队列的确认</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">mandatory:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#只要抵达队列，以异步发送优先回调我们这个returnconfirm</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span> <span class="hljs-comment">#手动ack消息</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment">#开启发送端确认</span><br></code></pre></td></tr></table></figure><p>3、添加注解@EnableRabbit</p><h2 id="二、面试题"><a href="#二、面试题" class="headerlink" title="二、面试题"></a>二、面试题</h2><h3 id="2-1-为什么你的项目要使用RabbitMQ？"><a href="#2-1-为什么你的项目要使用RabbitMQ？" class="headerlink" title="2.1 为什么你的项目要使用RabbitMQ？"></a>2.1 为什么你的项目要使用RabbitMQ？</h3><p>商品支付之后，要创建订单，要物流信息，要发送通知等，需要异步</p><h3 id="2-2-MQ的优点"><a href="#2-2-MQ的优点" class="headerlink" title="2.2 MQ的优点"></a>2.2 MQ的优点</h3><ol><li><p><strong>异步处理：</strong>相比于传统的串行、并行方式，提高了系统的吞吐量。（<strong>异步就是你可以不用等到你要执行的任务执行完，而是直接执行下一个任务，最后再执行它的回调函数</strong>）</p><p>从业务上来说，A发送一个请求，需要将数据写入BCD三个系统进行保存，如果不是异步的话，就得等待它们都执行完才返回结果，这无疑是非常耗时的，因此就可以使用MQ的异步，在A处理了请求之后，可以发送三个消息分别发给BCD，去异步的处理它们接下来的业务，这样无疑快得多。</p></li><li><p><strong>应用解耦</strong>：A系统发送数据给BCD三个系统，如果是通过接口调用的方式也不是不可以，但是如果另一个系统E也想要A的这些数据，或者BCD其中有系统不想要这个数据了，那么负责A系统的团队就得忙活死了，以后如果还要有变更，就得继续修改代码。这就是所谓的<strong>耦合严重</strong>。如果采用MQ的话，就可以让A系统将数据发送到MQ中，其余的系统只需要去消费这些消息就行。</p></li><li><p><strong>流量削峰：</strong>如果A系统会有一段时间突然产生大量的流量，那么可能会造成MySQL服务器扛不住这么大的请求。就可以接入MQ的方式，将请求发到MQ中，然后A系统会根据自己的承受能力去MQ中处理请求，一般而言，这种大流量持续的时间不会很久，等到系统稳定之后，就可以让积压在MQ中的请求逐步被处理。</p></li><li><p>作为发布&#x2F;订阅系统实现一个微服务级别系统间的观察者模式</p></li><li><p>连接流计算任务和数据</p></li><li><p>用于将消息广播给大量接收者。</p></li></ol><p><strong>应用场景】</strong>：秒杀、发邮件、高并发订单。但是不适合银行转账、电信开户，因为这些场景的数据一致性要求极高。</p><h3 id="2-3-MQ的缺点"><a href="#2-3-MQ的缺点" class="headerlink" title="2.3 MQ的缺点"></a>2.3 MQ的缺点</h3><p>虽然系统中引入了MQ能带来一定的好处，但是同样也会带来坏处：</p><ol><li>首先引入了新的中间件，会造成<strong>系统的可用性降低</strong>，因为本来系统运行的好好的，突然加了个中间件过来，还得去考虑MQ，如果MQ挂了怎么办？如果消息丢失了怎么办？</li><li><strong>系统复杂性降低</strong>：比如加入了MQ，你应该如何去处理<strong>消息是否重复消费？</strong>，<strong>怎么处理消息丢失的情况？消息的顺序性该如何保证？</strong></li><li><strong>一致性问题：</strong>比如系统A请求成功了，将消息发送到MQ之后就返回成功。但是此时BCD系统去消费这个消息，如果其中有一个系统消费失败了，那么该怎么办？<strong>这就造成了数据的一致性问题</strong></li><li>引入MQ，会增加系统调用链环节，导致总体的响应时延变长。</li></ol><p><strong>衍生：RabbitMQ的缺点】</strong></p><ol><li>RabbitMQ对消息堆积的支持并不好，在他的设计理念中，消息队列是一个管道，大量的消息积压是一种不正常的现象。当大量消息积压的时候，会导致RabbitMQ的性能急剧下降。</li><li>RabbitMQ相对于Kafka、RocketMQ来说，性能是他们之中最差的</li><li>底层用的Erlang，非常小众。非常难扩展和二次开发。</li></ol><h3 id="2-4-各种MQ的区别（为什么选择RabbitMQ？）"><a href="#2-4-各种MQ的区别（为什么选择RabbitMQ？）" class="headerlink" title="2.4 各种MQ的区别（为什么选择RabbitMQ？）"></a>2.4 各种MQ的区别（为什么选择RabbitMQ？）</h3><p>相对于其余的几种MQ来说，RabbitMQ拥有开源的活跃社区，它的时效性很高，延迟最低，拥有良好的消息可靠性。并且基于erlang语言开发，并发能力强，性能极好。</p><ul><li>如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那么RocketMQ的低延迟和金融级别的稳定性。</li><li>如果需要处理海量的消息，比如收集日志、监控信息，或者应用场景大量使用了大数据、流计算相关的开源产品，选择Kafka</li></ul><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>十万级，支持高吞吐</td><td>十万级，高吞吐</td></tr><tr><td>topic数量对吞吐量的影响</td><td></td><td></td><td>topic可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，在同等机器下，可以支撑大量的topic</td><td>topic从几十到几百个时候，吞吐量会有较大的下降。Kafka尽量保证topic数量不要太多</td></tr><tr><td>时效性</td><td>ms</td><td>微秒级，延迟最低</td><td>ms</td><td>ms以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同Active</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>较低的概率丢失</td><td>基本不丢</td><td>经过参数优化配置，可以做到0丢失</td><td>同rocketmq</td></tr><tr><td>功能支持</td><td>MQ领域的功能及其完备</td><td>基于erlang开发，并发能力强，性能极好，延时很低</td><td>MQ功能较为完善，分布式，扩展性好</td><td>功能简单，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><h3 id="2-5-如何防止消息的重复提交"><a href="#2-5-如何防止消息的重复提交" class="headerlink" title="2.5 如何防止消息的重复提交"></a>2.5 如何防止消息的重复提交</h3><p>如果MQ由于某种因素导致消费端收到了两条一模一样的消息，该如何处理？其实就是保证<strong>幂等性</strong></p><p>就以固定的业务来说，比如我们有一种商品它只能每个用户购买一次。</p><ol><li>在每次插入订单的时候，就可以查看MySQL中是否有该用户关于该商品Id的订单，如果有了， 就不让它插入。但是这样无疑效率会很低，这时候也可以选择使用Redis来进行这种判重，当我们创建订单时，可以同时将该用户购买了哪个商品记录在redis中，每次插入的时候可以先判断redis是否存在该记录。</li><li>也可以使用唯一性约束，如果插入了相同的数据，就会报错。</li></ol><h3 id="2-6-如何保证消息的消费顺序（不懂）"><a href="#2-6-如何保证消息的消费顺序（不懂）" class="headerlink" title="2.6 如何保证消息的消费顺序（不懂）"></a>2.6 如何保证消息的消费顺序（不懂）</h3><p>比如系统A发送了两个消息，M1和M2，并且必须要M1先于M2执行。如果这两个数据被不同的消费者消费掉了，就可能会M2先执行，M1后执行。</p><p>对于有顺序要求的消息，可以将其都发送到同一个Queue中，然后依次消费。</p><ul><li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue(消息队列)而已，确实是麻烦点；</li><li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li></ul><h2 id="2-7-如何保证消息的可靠传输"><a href="#2-7-如何保证消息的可靠传输" class="headerlink" title="2.7 如何保证消息的可靠传输"></a>2.7 如何保证消息的可靠传输</h2><p><strong>什么情况会导致消费的传输不可靠呢？</strong></p><ol><li>生产者在向MQ传送消息的过程中，消息丢失。</li><li>MQ收到消息，暂时存在内存中，还没消费，但是此时MQ宕机了，内存中的消息就丢失了。</li><li>消费者还没来得及去消费这个消息，就宕机了，而MQ会以为该消息被消费了。</li></ol><p><strong>怎么去解决这些不可靠的传输呢？</strong></p><ol><li>对于生产者，开启RabbitMQ事务（同步，不推荐）或者开启confirm模式（异步，推荐）</li><li>对MQ，开启RabbitMQ持久化</li><li>对于消费者：关闭RabbitMQ自动ACK</li></ol><p><strong>针对于生产者来说：</strong></p><ul><li>将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。</li><li>一旦消息被投递到目的队列之后，或者消息被写入磁盘之后，信道会发送一个确认给生产者。 （包含唯一的ID），就可以知道消息正确到达目的队列了。</li><li>如果MQ发生内部错误而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。这时你可以进行重试等操作。</li><li>发送方确认模式是<strong>异步的</strong>，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ul><p><strong>针对MQ来说：</strong></p><ul><li>一般而言都是开启持久化磁盘的配置。</li><li>这个可以配合生产者的confirm模式使用，可以在消息持久化到磁盘之后再给生产者发送一个ACK信号。这样，如果MQ宕机了，而消息此时未被持久化， 那么生产者就收不到ACK信号，生产者就会自动重发。</li><li>将Queue的持久化标识设置为true，表示持久化该队列。然后设置消息的<code>deliveryMode</code>为2，就表示将消息设置为可持久化的，此时MQ就会自动的将消息持久化到磁盘上。</li></ul><p><strong>针对于消费者来说：</strong></p><ul><li>将自动确认消息改为手动确认消息即可。不过这样有可能消费者ACK的时机慢了导致消息重复发送，不过这时候只要保证幂等性就可以了。</li></ul><h3 id="2-8-消息基于什么传输？"><a href="#2-8-消息基于什么传输？" class="headerlink" title="2.8 消息基于什么传输？"></a>2.8 消息基于什么传输？</h3><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ采用<strong>信道</strong>的方式来传输数据。<strong>信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制</strong>。</p><h3 id="2-9-如何解决MQ消息积压问题"><a href="#2-9-如何解决MQ消息积压问题" class="headerlink" title="2.9 如何解决MQ消息积压问题"></a>2.9 如何解决MQ消息积压问题</h3><p><strong>先定位消费者消息慢的原因</strong>：看看是不是有bug，或者优化一下消费逻辑，批量处理等等。</p><p>如果消费者宕机了，就会导致消息大量的积压。这时候只能进行<strong>紧急扩容</strong>了。</p><ul><li>首先得看消费者为什么宕机，并且修复好它。</li><li>新建一个topic，然后临时建立好原先十倍的Queue数量。</li><li>写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，<strong>但是消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的十倍数量的Queue中。</li><li>临时征用十倍的机器来部署consumer，每一批consumer去消费一个临时Queue中的数据。</li><li>等快速消费完积压的消息之后，<strong>恢复到原先的架构</strong>，重新用修复好的原先的consumer机器来消费消息。</li></ul><p>但是上述治标不治本，还是得找到为什么消息会积压。</p><ol><li>临时扩容，增加消费端，用硬件提升消费速度</li><li>可能硬件不够了，就可以进行服务降级，关闭一些非核心业务，减少消息生产。</li><li>通过日志分析、监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢就能确定哪个环节出了问题。</li><li>根据排查解决异常部分</li><li>等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器。</li></ol><h3 id="2-10-如何解决数据一致性问题"><a href="#2-10-如何解决数据一致性问题" class="headerlink" title="2.10 如何解决数据一致性问题"></a>2.10 如何解决数据一致性问题</h3><p>比如系统A发送了两个消息分别给订单服务和库存服务。然后订单服务成功了，库存服务失败了这时候该怎么办？</p><p>如果库存服务失败了，就给MQ返回处理失败的ACK，然后MQ会进行重试，当重试达到一定次数的时候就可以投入到死信队列中，进行人工处理或者定时任务进行相应的补偿。</p><p>当然也可以放弃MQ架构，采用分布式事务。</p><h2 id="2-11-说一说死信队列"><a href="#2-11-说一说死信队列" class="headerlink" title="2.11 说一说死信队列"></a>2.11 说一说死信队列</h2><p>所谓的死信就是无法被消费的消息。</p><ol><li>消息设置的TTL过期了。</li><li>队列达到了最大长度，无法再添加消息到MQ中（声明队列的时候可以设置队列长度）</li><li>消费者拒绝消费该消息并且设置了requeue &#x3D; false（表示拒绝重新入队）</li></ol><p>上述三种就是消息成为死信的情况。</p><p><strong>应用场景：</strong>为了保证订单业务的数据不丢失，就可以使用到死信队列机制，当消费发生异常，或者指定时间未支付等，就会将消息发送到对应的死信队列中，然后由消费者去监听这个死信队列去处理这些死信。</p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
      <category>面试话术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>面试话术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo源码分析</title>
    <link href="/Dubbo/Dubbo%E4%B8%80%E5%A5%97%E8%A7%A3%E5%86%B3/"/>
    <url>/Dubbo/Dubbo%E4%B8%80%E5%A5%97%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="待做事项"><a href="#待做事项" class="headerlink" title="待做事项"></a>待做事项</h1><ul><li><input disabled="" type="checkbox"> 自适应SPI</li><li><input disabled="" type="checkbox"> 消费者MockClusterInvoker，服务降级、集群管理、多个invoker合并成一个的过程</li><li><input disabled="" type="checkbox"> 服务端的ServerNetty、</li><li><input disabled="" type="checkbox"> 客户端的ClientNetty</li><li><input disabled="" type="checkbox"> 同步转异步</li><li><input disabled="" type="checkbox"> 服务降级</li><li><input disabled="" type="checkbox"> 服务路由</li><li><input disabled="" type="checkbox"> 负载均衡</li><li><input disabled="" type="checkbox"> 集群容错</li></ul><h1 id="第一章-基本使用"><a href="#第一章-基本使用" class="headerlink" title="第一章 基本使用"></a>第一章 基本使用</h1><p><strong>版本：2.7.7</strong></p><p>对于dubbo，一般采用zookeeper作为注册中心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- dubbo起步依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- zookeeper客户端实现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--zookeeper客户端实现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="2ad1eacb-12a8-390f-9e09-8e48f4323bf7.png" alt="img"></p><blockquote><p>什么是RPC</p></blockquote><blockquote><p>有了HTTP为什么还需要RPC</p></blockquote><h1 id="第二章-Dubbo-SPI"><a href="#第二章-Dubbo-SPI" class="headerlink" title="第二章 Dubbo SPI"></a>第二章 Dubbo SPI</h1><p>SPI全称<code>Service Provider Interface</code>，是一种服务发现机制。它的本质是将接口的实现类的全限定名称配置在文件中，并且由服务加载器读取配置文件，加载实现类。这样在运行的时候就可以动态的为接口替换实现类。比如我们实现RPC的时候需要序列化机制，不同的数据需要不同的序列化机制，就可以通过SPI机制来更换，从而不需要修改源代码，有点类似于IOC思想，目的是为了解耦。</p><p>但是如果一个接口配置了多个实现类，SPI机制会将这些实现类统一进行加载，使用遍历的方式。对于不想用的类，也会被加载并实例化，造成浪费。</p><p>Dubbo的SPI对Java的SPI进行了加强，详情见后续分析。</p><ul><li>解决了JavaSPI初始化时加载全部扩展类的缺陷，采取按需加载机制。</li><li>增加对扩展点的IOC和AOP支持。</li><li>增加缓存存储实例，提高读取性能</li></ul><h2 id="2-1-测试样例"><a href="#2-1-测试样例" class="headerlink" title="2.1 测试样例"></a>2.1 测试样例</h2><p>项目结构如图所示：</p><p><img src="image-20220719092116369.png" alt="image-20220719092116369"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.noaharno.dubbo.spi;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.SPI;<br><br><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chicken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, I am Chicken&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, I am Duck&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SPI配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">chicken</span> = top.noahar<span class="hljs-literal">no</span>.dubbo.spi.Chicken<br><span class="hljs-attr">duck</span> = top.noahar<span class="hljs-literal">no</span>.dubbo.spi.Duck<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">chicken</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;chicken&quot;</span>);<br>    chicken.sayHello();<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">duck</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;duck&quot;</span>);<br>    duck.sayHello();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="image-20220719092344378.png" alt="image-20220719092344378"></p><h2 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h2><h3 id="getExtensionLoader"><a href="#getExtensionLoader" class="headerlink" title="getExtensionLoader"></a>getExtensionLoader</h3><p>首先是<code>ExtensionLoader.getExtensionLoader(Animal.class)</code>，这个总体来说就是从一个ConcurrentHashMap缓存中找到Animal类对应的ExtensionLoader，如果不存在，就创建一个并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于存放ExtensionLoader和Class的联系</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="hljs-title function_">getExtensionLoader</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!type.isInterface()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type (&quot;</span> + type + <span class="hljs-string">&quot;) is not an interface!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!withExtensionAnnotation(type)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type (&quot;</span> + type +<br>                                           <span class="hljs-string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br><br>    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);<br>    <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>) &#123;<br>        EXTENSION_LOADERS.putIfAbsent(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExtensionLoader</span>&lt;T&gt;(type));<br>        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);<br>    &#125;<br>    <span class="hljs-keyword">return</span> loader;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><p>那如何使用指定类对应的ExtensionLoader获取到指定的实例呢？我们深入分析代码<code>extensionLoader.getExtension(&quot;chicken&quot;)</code></p><p>ExtensionLoader.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getExtension</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> getExtension(name, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getExtension</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> wrap)</span> &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension name == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) &#123;<br>        <span class="hljs-comment">// 用于获取默认的拓展实现类</span><br>        <span class="hljs-keyword">return</span> getDefaultExtension();<br>    &#125;<br>    <span class="hljs-comment">// Holder：用于持有目标对象</span><br>    <span class="hljs-comment">// 所有的Holder实际上使用一个map存取</span><br>    <span class="hljs-comment">// private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = </span><br>       <span class="hljs-comment">//                          new ConcurrentHashMap&lt;&gt;();</span><br>    <span class="hljs-comment">// 如果不存在相关的holder，就创建并返回</span><br>    <span class="hljs-comment">// dubbo实际上将扩展类封装在Holder类中。</span><br>    <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> holder.get();<br>    <span class="hljs-comment">// 双端检锁机制确保线程安全</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (holder) &#123;<br>            instance = holder.get();<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 创建扩展，核心逻辑</span><br>                instance = createExtension(name, wrap);<br>                holder.set(instance);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getDefaultExtension"><a href="#getDefaultExtension" class="headerlink" title="getDefaultExtension"></a>getDefaultExtension</h3><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheDefaultExtensionName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 拿到Aminal接口上的SPI注解</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SPI</span> <span class="hljs-variable">defaultAnnotation</span> <span class="hljs-operator">=</span> type.getAnnotation(SPI.class);<br>    <span class="hljs-keyword">if</span> (defaultAnnotation == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 看SPI注解有没有使用value值来标注默认扩展点</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> defaultAnnotation.value();<br>    <span class="hljs-comment">// 只能允许value值配置一个，超过一个则报错</span><br>    <span class="hljs-keyword">if</span> ((value = value.trim()).length() &gt; <span class="hljs-number">0</span>) &#123;<br>        String[] names = NAME_SEPARATOR.split(value);<br>        <span class="hljs-keyword">if</span> (names.length &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;More than 1 default extension name on extension &quot;</span> + type.getName()<br>                    + <span class="hljs-string">&quot;: &quot;</span> + Arrays.toString(names));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (names.length == <span class="hljs-number">1</span>) &#123;<br>            cachedDefaultName = names[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：如果我们使用<code>extensionLoader.getExtension</code>的时候，传入的参数是true，则会使用默认的扩展，但是需要在@SPI注解中指明默认的扩展是哪个。</p><h3 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h3><p>创建扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createExtension</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> wrap)</span> &#123;<br>    <span class="hljs-comment">// 从配置文件中加载所有的扩展类，得到配置项名称和配置类的映射关系</span><br>    Class&lt;?&gt; clazz = getExtensionClasses().get(name);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span> || unacceptableExceptions.contains(name)) &#123;<br>        <span class="hljs-keyword">throw</span> findException(name);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 从缓存中查看有没有对应的实例</span><br>        <span class="hljs-comment">// private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;&gt;(64);</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 使用反射创建实例</span><br>            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.getDeclaredConstructor().newInstance());<br>            instance = (T) EXTENSION_INSTANCES.get(clazz);<br>        &#125;<br>        <span class="hljs-comment">// 向实例中注入依赖  Dubbo的IOC容器部分</span><br>        injectExtension(instance);<br><br><br>        <span class="hljs-keyword">if</span> (wrap) &#123;<br><br>            <span class="hljs-comment">// 包装类修饰</span><br>            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// cachedWrapperClasses 用来存放包装类扩展类的实例缓存</span><br>            <span class="hljs-keyword">if</span> (cachedWrapperClasses != <span class="hljs-literal">null</span>) &#123;<br>                wrapperClassesList.addAll(cachedWrapperClasses);<br>                wrapperClassesList.sort(WrapperComparator.COMPARATOR);<br>                Collections.reverse(wrapperClassesList);<br>            &#125;<br>            <span class="hljs-comment">// 如果是包装类，那么该list就不会为null</span><br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;<br>                <span class="hljs-comment">// 循环创建Wrapper实例</span><br>                <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;<br>                    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> wrapperClass.getAnnotation(Wrapper.class);<br>                    <span class="hljs-keyword">if</span> (wrapper == <span class="hljs-literal">null</span><br>                        || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;<br>                        <span class="hljs-comment">// 这里是包装逻辑</span><br>                        <span class="hljs-comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span><br>                        <span class="hljs-comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span><br>                        <span class="hljs-comment">// 理解为装饰器模式，在原有的普通扩展点上进行增强，在RPC服务发现与调用的时候可以体现</span><br>                        <span class="hljs-comment">// 有点类似于AOP思想</span><br>                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        initExtension(instance);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Extension instance (name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +<br>                                        type + <span class="hljs-string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过getExtensionClasses获取该接口所有的扩展类，并获取name对应的扩展类clazz</li><li>通过反射创建clazz的实例对象</li><li>向拓展对象中注入依赖（IOC）</li><li>将拓展对象包裹在相应的Wrapper对象中（AOP）</li></ol><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><p>获取所有的扩展类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;<br>    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();<br>    <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (cachedClasses) &#123;<br>            classes = cachedClasses.get();<br>            <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;<br>                classes = loadExtensionClasses();<br>                cachedClasses.set(classes);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> classes;<br>&#125;<br></code></pre></td></tr></table></figure><p>从缓存中查找，如果没有就进行创建</p><h3 id="loadExtensionClasses"><a href="#loadExtensionClasses" class="headerlink" title="loadExtensionClasses"></a>loadExtensionClasses</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;<br>    <span class="hljs-comment">// 这个就是getDefaultExtension的核心逻辑，查看SPI注解上的value值</span><br>    cacheDefaultExtensionName();<br><br>    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 策略模式</span><br>    <span class="hljs-comment">// DubboInternalLoadingStrategy =&gt; META-INF/dubbo/internal/</span><br>    <span class="hljs-comment">//DubboLoadingStrategy =&gt; META-INF/dubbo/</span><br>    <span class="hljs-comment">//ServicesLoadingStrategy =&gt; META-INF/services/</span><br>    <span class="hljs-keyword">for</span> (LoadingStrategy strategy : strategies) &#123;<br>        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(),<br>                      strategy.overridden(), strategy.excludedPackages());<br>        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="hljs-string">&quot;org.apache&quot;</span>, <span class="hljs-string">&quot;com.alibaba&quot;</span>),<br>                      strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> extensionClasses;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220719104902140.png" alt="image-20220719104902140"></p><p>每种加载策略都指定了不同的加载路径</p><h3 id="loadDirectory"><a href="#loadDirectory" class="headerlink" title="loadDirectory"></a>loadDirectory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadDirectory</span><span class="hljs-params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> extensionLoaderClassLoaderFirst, <span class="hljs-type">boolean</span> overridden, String... excludedPackages)</span> &#123;<br>    <span class="hljs-comment">// 将相对路径和全限定类名作为文件路径</span><br>    <span class="hljs-comment">// META-INF\dubbo\ + top.noaharno.dubbo.spi.Animal</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> dir + type;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Enumeration&lt;java.net.URL&gt; urls = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> findClassLoader();<br><br>        <span class="hljs-comment">// try to load from ExtensionLoader&#x27;s ClassLoader first</span><br>        <span class="hljs-comment">// 尝试从ExtensionLoader的类加载器加载，默认为false</span><br>        <span class="hljs-keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extensionLoaderClassLoader</span> <span class="hljs-operator">=</span> ExtensionLoader.class.getClassLoader();<br>            <span class="hljs-keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;<br>                urls = extensionLoaderClassLoader.getResources(fileName);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (urls == <span class="hljs-literal">null</span> || !urls.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 根据文件路径获取文件</span><br>                urls = classLoader.getResources(fileName);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                urls = ClassLoader.getSystemResources(fileName);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (urls != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>                <span class="hljs-comment">// 对文件中的内容进行逐条加载资源</span><br>                java.net.<span class="hljs-type">URL</span> <span class="hljs-variable">resourceURL</span> <span class="hljs-operator">=</span> urls.nextElement();<br>                loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.error(<span class="hljs-string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +<br>                type + <span class="hljs-string">&quot;, description file: &quot;</span> + fileName + <span class="hljs-string">&quot;).&quot;</span>, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：该方法主要是拼接好需要加载的文件的文件路径，然后根据文件路径获取到文件之后，调用loadResource进行逐条加载</p><h3 id="loadResource"><a href="#loadResource" class="headerlink" title="loadResource"></a>loadResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadResource</span><span class="hljs-params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span><br><span class="hljs-params">                          java.net.URL resourceURL, <span class="hljs-type">boolean</span> overridden, String... excludedPackages)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建流，读取文件中的内容</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;<br>            String line;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> line.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (ci &gt;= <span class="hljs-number">0</span>) &#123;<br>                    line = line.substring(<span class="hljs-number">0</span>, ci);<br>                &#125;<br>                line = line.trim();<br>                <span class="hljs-keyword">if</span> (line.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                        <span class="hljs-comment">// 以 = 进行分割</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> line.indexOf(<span class="hljs-string">&#x27;=&#x27;</span>);<br>                        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                            name = line.substring(<span class="hljs-number">0</span>, i).trim();<br>                            clazz = line.substring(i + <span class="hljs-number">1</span>).trim();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            clazz = line;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !isExcluded(clazz, excludedPackages)) &#123;<br>                            <span class="hljs-comment">// 加载类，利用反射预加载上面读取到的全限定类名</span><br>                            loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="hljs-literal">true</span>, classLoader), name, overridden);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                        <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                            <span class="hljs-string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="hljs-string">&quot;, class line: &quot;</span> + line + <span class="hljs-string">&quot;) in &quot;</span> + resourceURL +<br>                            <span class="hljs-string">&quot;, cause: &quot;</span> + t.getMessage(), t);<br>                        exceptions.put(line, e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.error(<span class="hljs-string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +<br>                     type + <span class="hljs-string">&quot;, class file: &quot;</span> + resourceURL + <span class="hljs-string">&quot;) in &quot;</span> + resourceURL, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadClass</span><span class="hljs-params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span><br><span class="hljs-params">                       <span class="hljs-type">boolean</span> overridden)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>    <span class="hljs-comment">// 扩展类对象必须是扩展点接口的子类</span><br>    <span class="hljs-keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Error occurred when loading extension class (interface: &quot;</span> +<br>                type + <span class="hljs-string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="hljs-string">&quot;), class &quot;</span><br>                + clazz.getName() + <span class="hljs-string">&quot; is not subtype of interface.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果是自适应扩展点</span><br>    <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;<br>        cacheAdaptiveClass(clazz, overridden);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWrapperClass(clazz)) &#123;<br>           <span class="hljs-comment">// 判断扩展点构造函数中是否有参数是当前扩展接口类型</span><br>        <span class="hljs-comment">// 如果有，则为包装装饰类，将cachedWrapperClasses变量添加到当前clazz</span><br>        cacheWrapperClass(clazz);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 普通的扩展点逻辑</span><br>        <span class="hljs-comment">// 使用默认的构造函数</span><br>        clazz.getConstructor();<br>        <span class="hljs-comment">// 如果写配置文件的时候name为空，就判断类上是否有@Extension注解</span><br>        <span class="hljs-comment">// 并且解析注解的value属性</span><br>        <span class="hljs-comment">// 如果没有该注解就用类的小写名称作为name</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>            name = findAnnotationName(clazz);<br>            <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        <span class="hljs-string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="hljs-string">&quot; in the config &quot;</span> + resourceURL);<br>            &#125;<br>        &#125;<br><br>        String[] names = NAME_SEPARATOR.split(name);<br>        <span class="hljs-keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;<br>            <span class="hljs-comment">// 如果类中有@Activate注解</span><br>            <span class="hljs-comment">// 将name和注解对象缓存在cacheActivateClass变量中</span><br>            cacheActivateClass(clazz, names[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (String n : names) &#123;<br>                <span class="hljs-comment">// 缓存</span><br>                cacheName(clazz, n);<br>                <span class="hljs-comment">// 将最后拿到得到扩展类放入map中</span><br>                saveInExtensionClass(extensionClasses, clazz, n, overridden);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果类中有<code>@Adaptive</code>注解，则将clazz放入<code>cachedAdaptiveClass</code>变量中，表示此类为自适应扩展类</li><li>如果类的函数参数是扩展点接口类型的，将其将入<code>cachedWrapperClasses</code>变量，表示此类为包装装饰类</li><li>如果上述两点都不满足，代表此类为普通扩展类，将其放入<code>extensionClasses</code>中，后续从该Map中获取</li></ul><p>一般而言，扩展点都是普通的扩展点，可以从extensionClasses中获取，最终放入cachedClasses中。</p><h3 id="injectExtension（Dubbo-IOC）"><a href="#injectExtension（Dubbo-IOC）" class="headerlink" title="injectExtension（Dubbo IOC）"></a>injectExtension（Dubbo IOC）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">injectExtension</span><span class="hljs-params">(T instance)</span> &#123;<br><br>    <span class="hljs-comment">// ExtensionFactory，</span><br>    <span class="hljs-comment">// 实现的有SpiExtensionFactory、SpringExtensionFactory、AdaptiveExtensionFactory</span><br>    <span class="hljs-keyword">if</span> (objectFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 反射获得该类的所有的方法，并进行遍历</span><br>        <span class="hljs-comment">// 以chicken为例</span><br>        <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;<br>            <span class="hljs-keyword">if</span> (!isSetter(method)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 比如时setter方法才能往下走</span><br>            <span class="hljs-comment">// 判断逻辑：</span><br>            <span class="hljs-comment">// - startWith(&quot;set&quot;)</span><br>            <span class="hljs-comment">// - 方法参数只有一个 getParameterTypes.length() == 1</span><br>            <span class="hljs-comment">// - Modifier.isPublic 必须是public方法</span><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Check &#123;@link DisableInject&#125; to see if we need autowire injection for this property</span><br><span class="hljs-comment">             */</span><br><br>            <span class="hljs-comment">/// 如果该方法不需要自动注入就跳过</span><br>            <span class="hljs-keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 获得该方法参数的clazz</span><br>            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Check &#123;@link Inject&#125; to see if we need auto-injection for this property</span><br><span class="hljs-comment">             * &#123;@link Inject#enable&#125; == false will skip inject property phase</span><br><span class="hljs-comment">             * &#123;@link Inject#InjectType#ByName&#125; default inject by name</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 获取需要注入的属性</span><br>            <span class="hljs-comment">// 比如setVersion，获取属性version</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> getSetterProperty(method);<br>            <span class="hljs-type">Inject</span> <span class="hljs-variable">inject</span> <span class="hljs-operator">=</span> method.getAnnotation(Inject.class);<br>            <span class="hljs-keyword">if</span> (inject == <span class="hljs-literal">null</span>) &#123;<br>                injectValue(instance, method, pt, property);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!inject.enable()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (inject.type() == Inject.InjectType.ByType) &#123;<br>                    injectValue(instance, method, pt, <span class="hljs-literal">null</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    injectValue(instance, method, pt, property);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要IOC，也就是需要setter，就会使用<code>objectFactory.getExtension(pt, property)</code>来获取对象并进行注入。</p><ul><li>如果该类&#x2F;接口上有@SPI注解，就通过SpiExtensionFactory来获取对象</li><li>如果没有，就通过SpringExtensionFactory来获得该类的实例。</li></ul><p>AdaptiveExtensionFactory中维护了一个list，里面就含有上述两个ExtensionFactory，当调用objectFactory.getExtension方法获取某个类的实例的时候，就会挨个尝试使用这两个类来获取指定的实例。</p><h2 id="2-3-小总结"><a href="#2-3-小总结" class="headerlink" title="2.3 小总结"></a>2.3 小总结</h2><blockquote><p>Dubbo SPI的具体流程</p></blockquote><ul><li>使用<code>ExtensionLoader.getExtensionLoader(Animal.class)</code>获取指定接口的extensionLoader</li><li>通过上一步获得的extensionLoader，调用getExtension方法去实例化自己想要的类。</li><li>在实例化之前，它会先逐行解析指定文件路径，获取并保存该文件所有的name和class映射关系</li><li>我们拿到我们想要的name和它的clazz，使用反射进行实例化</li><li>在实例完成之后会进行依赖注入（只能通过setter方式，如果有的话），这里就是Dubbo IOC</li><li>而且如果该类是包装类，还可以进行类的增强，也就是AOP部分</li></ul><blockquote><p>Dubbo IOC</p></blockquote><p>在Dubbo中，无论是通过name获取指定扩展类，还是自适应扩展，都会在创建完实例之后，进行一次依赖注入，这个过程就是IOC机制。</p><h1 id="（TODO）第三章-自适应扩展SPI"><a href="#（TODO）第三章-自适应扩展SPI" class="headerlink" title="（TODO）第三章 自适应扩展SPI"></a>（TODO）第三章 自适应扩展SPI</h1><h1 id="第四章-服务导出（暴露）"><a href="#第四章-服务导出（暴露）" class="headerlink" title="第四章 服务导出（暴露）"></a>第四章 服务导出（暴露）</h1><h2 id="4-1-初始说明"><a href="#4-1-初始说明" class="headerlink" title="4.1 初始说明"></a>4.1 初始说明</h2><p>一般而言，我们使用Dubbo和Spring进行整合。</p><p>在2.7.16的Dubbo中，有一个类<code>DubboBootstrapApplicationListener</code>用来监听容器刷新和关闭的事件。当它监听到<code>ContextRefreshedEvent</code>的时候，就会调用<code>DubboBootstrap</code>的start方法，这个方法里面就实现了服务暴露的核心逻辑。</p><p>注：在Dubbo2.6x的版本的时候，使用的是ServiceBean类来监听相关的事件，而且只是监听容器刷新事件来暴露服务，而不负责服务的关闭清理。</p><p>注：如果是和SpringBoot整合，就会通过<code>DubboAutoConfiguration</code>向springboot上下文中注入该类，从而进行监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboBootstrapApplicationListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OnceApplicationContextEventListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The bean name of &#123;<span class="hljs-doctag">@link</span> DubboBootstrapApplicationListener&#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 2.7.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BEAN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dubboBootstrapApplicationListener&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DubboBootstrap dubboBootstrap;<br><br>    <span class="hljs-comment">// 在构造器里面就已经初始化了DubboBootstrap</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DubboBootstrapApplicationListener</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.dubboBootstrap = DubboBootstrap.getInstance();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DubboBootstrapApplicationListener</span><span class="hljs-params">(ApplicationContext applicationContext)</span> &#123;<br>        <span class="hljs-built_in">super</span>(applicationContext);<br>        <span class="hljs-built_in">this</span>.dubboBootstrap = DubboBootstrap.getInstance();<br>        DubboBootstrapStartStopListenerSpringAdapter.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationContextEvent</span><span class="hljs-params">(ApplicationContextEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DubboBootstrapStartStopListenerSpringAdapter.applicationContext == <span class="hljs-literal">null</span>) &#123;<br>            DubboBootstrapStartStopListenerSpringAdapter.applicationContext = event.getApplicationContext();<br>        &#125;<br>        <span class="hljs-comment">// 监听容器刷新事件</span><br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ContextRefreshedEvent) &#123;<br>            onContextRefreshedEvent((ContextRefreshedEvent) event);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ContextClosedEvent) &#123;<br>            <span class="hljs-comment">// 监听容器关闭事件</span><br>            onContextClosedEvent((ContextClosedEvent) event);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContextRefreshedEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 调用start方法，接下来正是开始服务暴露过程</span><br>        dubboBootstrap.start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContextClosedEvent</span><span class="hljs-params">(ContextClosedEvent event)</span> &#123;<br>        DubboShutdownHook.getDubboShutdownHook().run();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LOWEST_PRECEDENCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a>4.2 源码分析</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>对于Dubbo服务的启动，大体分为两个步骤：<strong>Dubbo的初始化以及服务暴露</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DubboBootstrap <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这个started是一个标志位，表示服务启动</span><br>    <span class="hljs-keyword">if</span> (started.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        destroyed.set(<span class="hljs-literal">false</span>);<br>        ready.set(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 核心逻辑 --- 初始化</span><br>        initialize();<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(NAME + <span class="hljs-string">&quot; is starting...&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 1. export Dubbo Services</span><br>        <span class="hljs-comment">// 核心逻辑 --- 暴露服务</span><br>        exportServices();<br><br>        <span class="hljs-comment">// Not only provider register</span><br>        <span class="hljs-keyword">if</span> (!isOnlyRegisterProvider() || hasExportedServices()) &#123;<br>            <span class="hljs-comment">// 2. export MetadataService</span><br>            exportMetadataService();<br>            <span class="hljs-comment">//3. Register the local ServiceInstance if required</span><br>            registerServiceInstance();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Consumer的ReferenceConfig</span><br>        referServices();<br>        <span class="hljs-keyword">if</span> (asyncExportingFutures.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.awaitFinish();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    logger.warn(NAME + <span class="hljs-string">&quot; exportAsync occurred an exception.&quot;</span>);<br>                &#125;<br>                ready.set(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>                    logger.info(NAME + <span class="hljs-string">&quot; is ready.&quot;</span>);<br>                &#125;<br>                ExtensionLoader&lt;DubboBootstrapStartStopListener&gt; exts = getExtensionLoader(DubboBootstrapStartStopListener.class);<br>                exts.getSupportedExtensionInstances().forEach(ext -&gt; ext.onStart(<span class="hljs-built_in">this</span>));<br>            &#125;).start();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ready.set(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>                logger.info(NAME + <span class="hljs-string">&quot; is ready.&quot;</span>);<br>            &#125;<br>            ExtensionLoader&lt;DubboBootstrapStartStopListener&gt; exts = getExtensionLoader(DubboBootstrapStartStopListener.class);<br>            exts.getSupportedExtensionInstances().forEach(ext -&gt; ext.onStart(<span class="hljs-built_in">this</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(NAME + <span class="hljs-string">&quot; has started.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DubboBootstrap-initialize"><a href="#DubboBootstrap-initialize" class="headerlink" title="DubboBootstrap#initialize()"></a>DubboBootstrap#initialize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!initialized.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 初始化框架的扩展</span><br>    ApplicationModel.initFrameworkExts();<br>    <span class="hljs-comment">// 初始化配置中心，使用ConfigManager，它管理着Dubbo应用的所有配置类</span><br>    <span class="hljs-comment">// 刷新配置，设置一些系统的环境变量</span><br>    startConfigCenter();<br>    <span class="hljs-comment">// 加载远程的配置</span><br>    loadRemoteConfigs();<br>    <span class="hljs-comment">// 加载全局的配置</span><br>    checkGlobalConfigs();<br>    <span class="hljs-comment">// 初始化元数据中心</span><br>    <span class="hljs-comment">// @since 2.7.8</span><br>    startMetadataCenter();<br>    <span class="hljs-comment">// 初始化元数据操作接口</span><br>    initMetadataService();<br><br>    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>        logger.info(NAME + <span class="hljs-string">&quot; has been initialized!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DubboBootstrap-exportServices"><a href="#DubboBootstrap-exportServices" class="headerlink" title="DubboBootstrap#exportServices()"></a>DubboBootstrap#exportServices()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportServices</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 从configManager中获取所有的ServiceConfig实例，挨个遍历暴露</span><br>    <span class="hljs-comment">// 获取到的其实是ServiceBean，它继承了ServiceConfig</span><br>    <span class="hljs-comment">// 也就是说，其实我们想要暴露的服务，会先封装成ServiceConfig进行后续的处理</span><br>    configManager.getServices().forEach(sc -&gt; &#123;<br>        <span class="hljs-comment">// TODO, compatible with ServiceConfig.export()</span><br>        <span class="hljs-type">ServiceConfig</span> <span class="hljs-variable">serviceConfig</span> <span class="hljs-operator">=</span> (ServiceConfig) sc;<br>        serviceConfig.setBootstrap(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">// 如果是异步暴露</span><br>        <span class="hljs-keyword">if</span> (exportAsync) &#123;<br>            <span class="hljs-comment">// 使用线程池来异步执行暴露逻辑</span><br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> executorRepository.getServiceExporterExecutor();<br>            Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    exportService(serviceConfig);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    logger.error(<span class="hljs-string">&quot;export async catch error : &quot;</span> + t.getMessage(), t);<br>                &#125;<br>            &#125;);<br>            asyncExportingFutures.add(future);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 同步的暴露服务</span><br>            exportService(serviceConfig);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DubboBootstrap-exportService"><a href="#DubboBootstrap-exportService" class="headerlink" title="DubboBootstrap#exportService"></a>DubboBootstrap#exportService</h3><p>这个方法会执行ServiceConfig实现的暴露方法，结束后将暴露后的方法添加到<code>exportedServices</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportService</span><span class="hljs-params">(ServiceConfig sc)</span> &#123;<br>    <span class="hljs-keyword">if</span> (exportedServices.containsKey(sc.getServiceName())) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;There are multiple ServiceBean instances with the same service name: [&quot;</span> +<br>                                        sc.getServiceName() + <span class="hljs-string">&quot;], instances: [&quot;</span> +<br>                                        exportedServices.get(sc.getServiceName()).toString() + <span class="hljs-string">&quot;, &quot;</span> +<br>                                        sc.toString() + <span class="hljs-string">&quot;]. Only one service can be exported for the same triple (group, interface, version), &quot;</span> +<br>                                        <span class="hljs-string">&quot;please modify the group or version if you really need to export multiple services of the same interface.&quot;</span>);<br>    &#125;<br>    sc.export();<br>    exportedServices.put(sc.getServiceName(), sc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ServiceConfig-export"><a href="#ServiceConfig-export" class="headerlink" title="ServiceConfig#export"></a>ServiceConfig#export</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (bootstrap == <span class="hljs-literal">null</span>) &#123;<br>        bootstrap = DubboBootstrap.getInstance();<br>        <span class="hljs-comment">// compatible with api call.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != <span class="hljs-built_in">this</span>.getRegistry()) &#123;<br>            bootstrap.registries(<span class="hljs-built_in">this</span>.getRegistries());<br>        &#125;<br>        bootstrap.initialize();<br>    &#125;<br><br>    checkAndUpdateSubConfigs();<br><br>    <span class="hljs-comment">// 初始化服务的元数据信息</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        serviceMetadata.setVersion(getVersion(interfaceConfig));</span><br><span class="hljs-comment">        serviceMetadata.setGroup(getGroup(interfaceConfig));</span><br><span class="hljs-comment">        serviceMetadata.setDefaultGroup(getGroup(interfaceConfig));</span><br><span class="hljs-comment">        serviceMetadata.setServiceInterfaceName(getInterface());</span><br><span class="hljs-comment">    */</span><br>    initServiceMetadata(provider);<br>    serviceMetadata.setServiceType(getInterfaceClass());<br>    serviceMetadata.setTarget(getRef());<br>    serviceMetadata.generateServiceKey();<br><br>    <span class="hljs-keyword">if</span> (!shouldExport()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否是延时export</span><br>    <span class="hljs-keyword">if</span> (shouldDelay()) &#123;<br>        <span class="hljs-comment">// 如果是延时，就使用时间调度器延迟执行服务暴露逻辑</span><br>        DELAY_EXPORT_EXECUTOR.schedule(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Delay export server should print stack trace </span><br>                <span class="hljs-comment">// if there are exception occur.</span><br>                <span class="hljs-built_in">this</span>.doExport();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(<span class="hljs-string">&quot;delay export server occur exception, please check it.&quot;</span>, e);<br>            &#125;<br>        &#125;, getDelay(), TimeUnit.MILLISECONDS);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 直接暴露服务</span><br>        doExport();<br>    &#125;<br>    <span class="hljs-comment">// 发布ServiceConfigExportedEvent事件</span><br>    exported();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ServiceConfig-doExport"><a href="#ServiceConfig-doExport" class="headerlink" title="ServiceConfig#doExport"></a>ServiceConfig#doExport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doExport</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (unexported) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The service &quot;</span> + interfaceClass.getName() + <span class="hljs-string">&quot; has already unexported!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (exported) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    exported = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// path为接口的全限定名</span><br>    <span class="hljs-comment">// org.apache.dubbo.demo.DemoService</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(path)) &#123;<br>        path = interfaceName;<br>    &#125;<br>    <span class="hljs-comment">// 核心逻辑</span><br>    doExportUrls();<br>    bootstrap.setReady(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ServiceConfig-doExportUrls"><a href="#ServiceConfig-doExportUrls" class="headerlink" title="ServiceConfig#doExportUrls()"></a>ServiceConfig#doExportUrls()</h3><p>暴露核心逻辑的开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个ServiceConfig可能同时以多个协议暴露</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doExportUrls</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ApplicationModel是整个Dubbo容器</span><br>    <span class="hljs-type">ServiceRepository</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> ApplicationModel.getServiceRepository();<br>    <span class="hljs-type">ServiceDescriptor</span> <span class="hljs-variable">serviceDescriptor</span> <span class="hljs-operator">=</span> repository.registerService(getInterfaceClass());<br>    <span class="hljs-comment">// 将服务提供者的信息存放到服务仓库中</span><br>    repository.registerProvider(<br>        getUniqueServiceName(),<br>        ref,<br>        serviceDescriptor,<br>        <span class="hljs-built_in">this</span>,<br>        serviceMetadata<br>    );<br><br>    <span class="hljs-comment">// 获取服务注册中心的URL地址信息，</span><br>    <span class="hljs-comment">// 一个服务可以同时在多个注册中心中注册，因此是List</span><br>    <span class="hljs-comment">// 我们这里以zookeeper作为注册中心</span><br>    <span class="hljs-comment">// registry://192.168.235.123:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-annotation-provider&amp;dubbo=2.0.2&amp;id=registryConfig&amp;pid=30512&amp;registry=zookeeper&amp;release=2.7.16&amp;timestamp=1658286276739</span><br>    List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 遍历服务要暴露的协议集合，一个服务可能同时以不同协议暴露，比如dubbo协议、http协议等</span><br>    <span class="hljs-comment">// 一般默认dubbo</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">protocolConfigNum</span> <span class="hljs-operator">=</span> protocols.size();<br>    <span class="hljs-keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pathKey</span> <span class="hljs-operator">=</span> URL.buildKey(getContextPath(protocolConfig)<br>                                      .map(p -&gt; p + <span class="hljs-string">&quot;/&quot;</span> + path)<br>                                      .orElse(path), group, version);<br>        <span class="hljs-comment">// In case user specified path, register service one more time to map it to path.</span><br>        repository.registerService(pathKey, interfaceClass);<br>        <span class="hljs-comment">// 针对一个协议，在一个或多个注册中心暴露这个服务</span><br>        doExportUrlsFor1Protocol(protocolConfig, registryURLs, protocolConfigNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图所示：服务仓库ServiceRepository中存放了我们需要暴露的服务</p><p><img src="image-20220720110429077.png" alt="image-20220720110429077"></p><h3 id="ServiceConfig-doExportUrlsFor1Protocol"><a href="#ServiceConfig-doExportUrlsFor1Protocol" class="headerlink" title="ServiceConfig#doExportUrlsFor1Protocol()"></a>ServiceConfig#doExportUrlsFor1Protocol()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doExportUrlsFor1Protocol</span><span class="hljs-params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs, <span class="hljs-type">int</span> protocolConfigNum)</span> &#123;<br>    <span class="hljs-comment">// 获取协议名称 dubbo</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> protocolConfig.getName();<br>    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;<br>        name = DUBBO;<br>    &#125;<br>    <span class="hljs-comment">// 进行参数的组装</span><br>    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>    map.put(SIDE_KEY, PROVIDER_SIDE);<br><br>    <span class="hljs-comment">// 这里省略所有的参数组装过程</span><br><br>    <span class="hljs-comment">//init serviceMetadata attachments</span><br>    serviceMetadata.getAttachments().putAll(map);<br><br>    <span class="hljs-comment">// export service 构建URL实例</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> findConfigedHosts(protocolConfig, registryURLs, map);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> findConfigedPorts(protocolConfig, name, map, protocolConfigNum);<br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="hljs-string">&quot;/&quot;</span> + path).orElse(path), map);<br>    <span class="hljs-comment">// url：</span><br>    <span class="hljs-comment">// dubbo://192.168.40.1:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-annotation-provider&amp;bind.ip=192.168.40.1&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;metadata-type=remote&amp;methods=sayHello,sayHelloAsync&amp;pid=10772&amp;release=2.7.16&amp;service.name=ServiceBean:/org.apache.dubbo.demo.DemoService&amp;side=provider&amp;timestamp=1658291601742</span><br><br>    <span class="hljs-comment">// You can customize Configurator to append extra parameters</span><br>    <span class="hljs-keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)<br>        .hasExtension(url.getProtocol())) &#123;<br>        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)<br>            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);<br>    &#125;<br>    <span class="hljs-comment">// 获取scope，如果配置的scope是none或者没有配置就不暴露服务</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> url.getParameter(SCOPE_KEY);<br>    <span class="hljs-comment">// don&#x27;t export when none is configured</span><br>    <span class="hljs-keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;<br><br>        <span class="hljs-comment">// 本地暴露</span><br>        <span class="hljs-keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;<br>            exportLocal(url);<br>        &#125;<br>        <span class="hljs-comment">// 远程暴露</span><br>        <span class="hljs-keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;<br>                <span class="hljs-comment">// 挨个遍历已经配置了的注册中心的地址</span><br>                <span class="hljs-comment">// 一个一个暴露</span><br>                <span class="hljs-comment">// 一个协议（默认是dubbo）可以暴露到多个注册中心</span><br>                <span class="hljs-keyword">for</span> (URL registryURL : registryURLs) &#123;<br><br>                    <span class="hljs-keyword">if</span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) &#123;<br>                        url = url.addParameterIfAbsent(SERVICE_NAME_MAPPING_KEY, <span class="hljs-string">&quot;true&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 如果协议是injvm，就不需要暴露，在同一个jvm内的服务</span><br>                    <span class="hljs-keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<span class="hljs-comment">// 添加dynamic参数配置</span><br>                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));<br>                    <span class="hljs-comment">// 添加监控中心url配置，可选</span><br>                    <span class="hljs-type">URL</span> <span class="hljs-variable">monitorUrl</span> <span class="hljs-operator">=</span> ConfigValidationUtils.loadMonitor(<span class="hljs-built_in">this</span>, registryURL);<br>                    <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-literal">null</span>) &#123;<br>                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());<br>                    &#125;<br>                    <span class="hljs-comment">// 省略</span><br><br>                    <span class="hljs-comment">// For providers, this is used to enable custom proxy</span><br>                    <span class="hljs-comment">//         to generate invoker</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> url.getParameter(PROXY_KEY);<br>                    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;<br>                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);<br>                    &#125;<br>                    <span class="hljs-comment">// 使用ProxyFactory来生成接口的代理</span><br>                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass,<br>                                                                  registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));<br>                    <span class="hljs-comment">// 生成Invoker的包装类，实现了Invoker接口，其本身也是一个Invoker</span><br>                    <span class="hljs-comment">// 只是在Inovker的基础上扩展了ServiceConfig</span><br>                    <span class="hljs-type">DelegateProviderMetaDataInvoker</span> <span class="hljs-variable">wrapperInvoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="hljs-built_in">this</span>);<br>                    <span class="hljs-comment">// 使用Protocol来暴露服务接口到对应的注册中心</span><br>                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);<br>                    <span class="hljs-comment">// 将这个Exporter实例存入ServiceConfig中的exporters属性中</span><br>                    exporters.add(exporter);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不存在注册中心，仅到处服务</span><br>                <span class="hljs-comment">// 省略</span><br>            &#125;<br><br>            MetadataUtils.publishServiceDefinition(url);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.urls.add(url);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法注意如下重点：</p><ul><li>方法的作用是将想要暴露的服务用一个协议（默认是dubbo协议）暴露给一个或多个注册中心</li><li>当然一个服务也可以使用多个协议，挨个遍历所有协议，每个协议执行一下这个方法</li><li>暴露分为本地暴露和远程暴露，重点分析远程暴露</li><li>使用ProxyFactory来生成接口的代理，即将ServiceConfig包装成Invoker</li><li>将Invoker再包装成wrapperInvoker，即DelegateProviderMetaDataInvoker，它持有Invoker和ServiceConfig</li><li>使用Protocol来暴露服务接口到对应的注册中心，并生成Exporter</li></ul><h2 id="4-3-小总结"><a href="#4-3-小总结" class="headerlink" title="4.3 小总结"></a>4.3 小总结</h2><blockquote><p>说一说服务暴露的流程</p></blockquote><p>再Dubbo中，有一个类DubboBootstrapApplicationListener，它用来监听Spring容器的刷新和关闭事件。当他监听到容器刷新事件（ContextRefreshedEvent）的时候，就会调用DubboBootstrap的start方法，也就是开启服务暴露流程</p><p>首先它会进行一些初始化操作，包括ConfigManager。</p><p>然后它就从ConfigManager中拿到所有的想要暴露的服务进行挨个遍历暴露。注意，我们再ConfigManager中存取的服务其实已经被包装成了ServiceBean，它继承了ServiceConfig，也就是说，我们会将我们想要暴露的服务包装成ServiceConfig。</p><p>我们拿到所有的配置好了的协议（一般我们只有dubbo）和所有的服务注册中心的URL地址信息。然后挨个遍历服务要暴露的协议集合，然后注入到所有的注册中心中。</p><ul><li>暴露分为本地暴露和远程暴露，重点分析远程暴露</li><li>使用ProxyFactory来生成接口的代理，即将ServiceConfig包装成Invoker</li><li>将Invoker再包装成wrapperInvoker，即DelegateProviderMetaDataInvoker，它持有Invoker和ServiceConfig</li><li>使用Protocol来暴露服务接口到对应的注册中心，并生成Exporter</li></ul><p><strong>总的来说，服务发布分为两部分：服务注册和服务暴露</strong></p><p><strong>服务注册就是将提供者主机的服务信息写入到注册中心中；服务暴露就是将服务暴露于外部以让消费者可以直接调用，主要分为四部：形成服务暴露URL、生成服务暴露实例Exporter、通过Netty暴露服务、同步转异步</strong></p><p><img src="Dubbo.png" alt="Dubbo"></p><p><img src="image-20220720150454149.png" alt="image-20220720150454149"></p><blockquote><p>为什么需要本地暴露？</p></blockquote><p>可能存在同一个JVM内部引用自身服务的情况，就可以避免网络间的通信</p><h2 id="4-4-Invoker"><a href="#4-4-Invoker" class="headerlink" title="4.4 Invoker"></a>4.4 Invoker</h2><p>Invoker是一个非常重要的模型，在提供者和消费者都会出现Invoker。</p><blockquote><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p></blockquote><p>Invoker是由ProxyFactory创建而来，Dubbo默认的ProxyFactory实现类是<code>JavassistProxyFactory</code>。</p><p>封装成invoker其实是想要屏蔽调用的细节，统一暴露出一个可执行体。</p><h3 id="JavassistProxyFactory-getInvoker"><a href="#JavassistProxyFactory-getInvoker" class="headerlink" title="JavassistProxyFactory#getInvoker"></a>JavassistProxyFactory#getInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> &#123;<br>    <span class="hljs-comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span><br>    <span class="hljs-comment">// 为目标类创建Wrapper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">&#x27;$&#x27;</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);<br>    <span class="hljs-comment">// 创建匿名Invoker对象，并实现doInvoke方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractProxyInvoker</span>&lt;T&gt;(proxy, type, url) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doInvoke</span><span class="hljs-params">(T proxy, String methodName,</span><br><span class="hljs-params">                                  Class&lt;?&gt;[] parameterTypes,</span><br><span class="hljs-params">                                  Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-comment">// 调用Wrapper的invokeMethod方法</span><br>            <span class="hljs-comment">// invokeMethod最终会调用目标方法</span><br>            <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>也就是说，JavassistProxyFactory创建了一个继承自AbstractProxyInvoker类的匿名对象，并且重写了doInvoke方法。重写后的逻辑只是将调用请求转发给了Wrapper类的invokeMethod方法。</strong></p><p><strong>Wrapper是一个抽象类，在创建Wrapper子类的时候，子类代码生成逻辑会对getWrapper方法传入的Class对象进行解析，拿到类方法、类成员变量等信息，以及生成invokeMethod方法代码和其他一些方法代码。代码生成完毕之后，通过Javassist生成Class对象，最后通过反射创建Wrapper实例。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Wrapper <span class="hljs-title function_">getWrapper</span><span class="hljs-params">(Class&lt;?&gt; c)</span> &#123;<br>    <span class="hljs-keyword">while</span> (ClassGenerator.isDynamicClass(c)) <br>        <span class="hljs-comment">// can not wrapper on dynamic class.</span><br>    &#123;<br>        c = c.getSuperclass();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c == Object.class) &#123;<br>        <span class="hljs-keyword">return</span> OBJECT_WRAPPER;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> WRAPPER_MAP.computeIfAbsent(c, Wrapper::makeWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Wrapper-makeWrapper"><a href="#Wrapper-makeWrapper" class="headerlink" title="Wrapper#makeWrapper"></a>Wrapper#makeWrapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Wrapper <span class="hljs-title function_">makeWrapper</span><span class="hljs-params">(Class&lt;?&gt; c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (c.isPrimitive()) &#123; <span class="hljs-comment">// 判断是否是基本类型</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Can not create wrapper for primitive type: &quot;</span> + c);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getName();<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassUtils.getClassLoader(c);<br>    <span class="hljs-comment">// c1用于存储setPropertyValue方法代码</span><br>     <span class="hljs-comment">// c2用于存储getPropertyValue方法代码</span><br>    <span class="hljs-comment">// c3用于存储invokeMethod方法代码</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;public void setPropertyValue(Object o, String n, Object v)&#123; &quot;</span>);<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;public Object getPropertyValue(Object o, String n)&#123; &quot;</span>);<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws &quot;</span> + InvocationTargetException.class.getName() + <span class="hljs-string">&quot;&#123; &quot;</span>);<br>    <span class="hljs-comment">// 生成类型转换代码以及异常捕获代码</span><br>    c1.append(name).append(<span class="hljs-string">&quot; w; try&#123; w = ((&quot;</span>).append(name).append(<span class="hljs-string">&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;</span>);<br>    c2.append(name).append(<span class="hljs-string">&quot; w; try&#123; w = ((&quot;</span>).append(name).append(<span class="hljs-string">&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;</span>);<br>    c3.append(name).append(<span class="hljs-string">&quot; w; try&#123; w = ((&quot;</span>).append(name).append(<span class="hljs-string">&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;</span>);<br>    <span class="hljs-comment">// pts用于存储成员变量名和类型</span><br>    Map&lt;String, Class&lt;?&gt;&gt; pts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">// &lt;property name, property types&gt;</span><br>    <span class="hljs-comment">// ms用于存储方法描述信息以及Method实例    </span><br>    Map&lt;String, Method&gt; ms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(); <span class="hljs-comment">// &lt;method desc, Method instance&gt;</span><br>    <span class="hljs-comment">// mns为方法名列表</span><br>    List&lt;String&gt; mns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// method names.</span><br>    <span class="hljs-comment">// dmns用于存储定义在当前类中的方法的名称</span><br>    List&lt;String&gt; dmns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// declaring method names.</span><br><br>    <span class="hljs-comment">// 获取public访问级别的字段，并为所有字段生成条件判断语句</span><br>    <span class="hljs-keyword">for</span> (Field f : c.getFields()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fn</span> <span class="hljs-operator">=</span> f.getName();<br>        Class&lt;?&gt; ft = f.getType();<br>        <span class="hljs-keyword">if</span> (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><span class="hljs-comment">// 生成条件判断及赋值语句</span><br>        <span class="hljs-comment">// if( $2.equals(&quot;name&quot;) ) &#123; w.name = (java.lang.String) $3; return;&#125;</span><br>        c1.append(<span class="hljs-string">&quot; if( $2.equals(\&quot;&quot;</span>).append(fn).append(<span class="hljs-string">&quot;\&quot;) )&#123; w.&quot;</span>).append(fn).append(<span class="hljs-string">&quot;=&quot;</span>).append(arg(ft, <span class="hljs-string">&quot;$3&quot;</span>)).append(<span class="hljs-string">&quot;; return; &#125;&quot;</span>);<br>        <br>        <span class="hljs-comment">// 生成条件判断及返回语句</span><br>        <span class="hljs-comment">// if( $2.equals(&quot;name&quot;) ) &#123; return ($w)w.name; &#125;</span><br>        c2.append(<span class="hljs-string">&quot; if( $2.equals(\&quot;&quot;</span>).append(fn).append(<span class="hljs-string">&quot;\&quot;) )&#123; return ($w)w.&quot;</span>).append(fn).append(<span class="hljs-string">&quot;; &#125;&quot;</span>);<br>        <span class="hljs-comment">// 存储&lt;字段名，字段类型&gt; 键值对到pts中</span><br>        pts.put(fn, ft);<br>    &#125;<br>    <br>    <br><span class="hljs-comment">// 后续逻辑就不分析了</span><br></code></pre></td></tr></table></figure><h2 id="4-5-Protocol"><a href="#4-5-Protocol" class="headerlink" title="4.5 Protocol"></a>4.5 Protocol</h2><p>通过上面的分析，我们通过PROTOCOL.export(wrapperInvoker);将服务暴露给注册中心，然后返回Exporter。</p><p>而我们默认使用的Protocol就是<strong>RegistryProtocol</strong></p><h3 id="RegistryProtocol-export"><a href="#RegistryProtocol-export" class="headerlink" title="RegistryProtocol#export"></a>RegistryProtocol#export</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>    <span class="hljs-comment">// 获取注册中心URL，以zookeeper为例</span><br><span class="hljs-comment">//zookeeper://192.168.235.123:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-annotation-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F192.168.40.1%3A20880%2Forg.apache.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-demo-annotation-provider%26bind.ip%3D192.168.40.1%26bind.port%3D20880%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.demo.DemoService%26metadata-type%3Dremote%26methods%3DsayHello%2CsayHelloAsync%26pid%3D4832%26release%3D2.7.16%26service.name%3DServiceBean%3A%2Forg.apache.dubbo.demo.DemoService%26side%3Dprovider%26timestamp%3D1658305421214&amp;id=registryConfig&amp;pid=4832&amp;release=2.7.16&amp;timeout=20000&amp;timestamp=1658305421209</span><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">registryUrl</span> <span class="hljs-operator">=</span> getRegistryUrl(originInvoker);<br>    <span class="hljs-comment">// url to export locally</span><br>    <span class="hljs-comment">// 获取服务提供者的URL</span><br>    <span class="hljs-comment">// dubbo://192.168.40.1:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-annotation-provider&amp;bind.ip=192.168.40.1&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;metadata-type=remote&amp;methods=sayHello,sayHelloAsync&amp;pid=4832&amp;release=2.7.16&amp;service.name=ServiceBean:/org.apache.dubbo.demo.DemoService&amp;side=provider&amp;timestamp=1658305421214</span><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">providerUrl</span> <span class="hljs-operator">=</span> getProviderUrl(originInvoker);<br><br>    <span class="hljs-comment">// Subscribe the override data</span><br>    <span class="hljs-comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span><br>    <span class="hljs-comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span><br>    <span class="hljs-comment">//  subscription information to cover.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">overrideSubscribeUrl</span> <span class="hljs-operator">=</span> getSubscribedOverrideUrl(providerUrl);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">OverrideListener</span> <span class="hljs-variable">overrideSubscribeListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OverrideListener</span>(overrideSubscribeUrl, originInvoker);<br>    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);<br><br>    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);<br>    <span class="hljs-comment">// 导出服务，重点</span><br>    <span class="hljs-keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);<br><br>    <span class="hljs-comment">// url to registry</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> getRegistry(originInvoker);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">registeredProviderUrl</span> <span class="hljs-operator">=</span> getUrlToRegistry(providerUrl, registryUrl);<br><br>    <span class="hljs-comment">// decide if we need to delay publish</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">register</span> <span class="hljs-operator">=</span> providerUrl.getParameter(REGISTER_KEY, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (register) &#123;<br>        <span class="hljs-comment">// 向注册中心注册服务，重点</span><br>        registry.register(registeredProviderUrl);<br>    &#125;<br><br>    <span class="hljs-comment">// register stated url on provider model</span><br>    registerStatedUrl(registryUrl, registeredProviderUrl, register);<br><br><br>    exporter.setRegisterUrl(registeredProviderUrl);<br>    exporter.setSubscribeUrl(overrideSubscribeUrl);<br><br>    <span class="hljs-comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span><br>    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);<br><br>    notifyExport(exporter);<br>    <span class="hljs-comment">//Ensure that a new exporter instance is returned every time export</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DestroyableExporter</span>&lt;&gt;(exporter);<br>&#125;<br></code></pre></td></tr></table></figure><p>总体而言分为四部：</p><ol><li>调用 doLocalExport 导出服务（重点）</li><li>向注册中心注册服务（重点）</li><li>向注册中心进行订阅 override 数据</li><li>创建并返回 DestroyableExporter</li></ol><h3 id="RegistryProtocol-doLocalExport"><a href="#RegistryProtocol-doLocalExport" class="headerlink" title="RegistryProtocol#doLocalExport"></a>RegistryProtocol#doLocalExport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; <span class="hljs-title function_">doLocalExport</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> &#123;<br>    <span class="hljs-comment">// 访问缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> getCacheKey(originInvoker);<br><br>    <span class="hljs-keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;<br>        <span class="hljs-comment">// 创建Invoker为委托类对象</span><br>        Invoker&lt;?&gt; invokerDelegate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerDelegate</span>&lt;&gt;(originInvoker, providerUrl);<br>        <span class="hljs-comment">// 调用protocol的export方法导出服务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExporterChangeableWrapper</span>&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了protocol.export方法，如果我们的运行时协议是dubbo，那么此处的protocol变量就会在运行时加载DubboProtocol，并调用其export方法</p><h3 id="DubboProtocol-export"><a href="#DubboProtocol-export" class="headerlink" title="DubboProtocol#export"></a>DubboProtocol#export</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> invoker.getUrl();<br><br>    <span class="hljs-comment">// export service.</span><br>    <span class="hljs-comment">// 获取服务标识，由服务组名（如果有）、服务名、服务版本号（如果有）、端口组成</span><br>    <span class="hljs-comment">// org.apache.dubbo.demo.DemoService:20880</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> serviceKey(url);<br>    <span class="hljs-comment">// 创建 DubboExporter</span><br>    DubboExporter&lt;T&gt; exporter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboExporter</span>&lt;T&gt;(invoker, key, exporterMap);<br>    exporterMap.addExportMap(key, exporter);<br><br>    <span class="hljs-comment">//export an stub service for dispatching event</span><br>    <span class="hljs-comment">// 本地存根相关代码</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isStubSupportEvent</span> <span class="hljs-operator">=</span> url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isCallbackservice</span> <span class="hljs-operator">=</span> url.getParameter(IS_CALLBACK_SERVICE, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stubServiceMethods</span> <span class="hljs-operator">=</span> url.getParameter(STUB_EVENT_METHODS_KEY);<br>        <span class="hljs-keyword">if</span> (stubServiceMethods == <span class="hljs-literal">null</span> || stubServiceMethods.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +<br>                                                      <span class="hljs-string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 启动服务器</span><br>    openServer(url);<br>    optimizeSerialization(url);<br><br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DubboProtocol-openServer"><a href="#DubboProtocol-openServer" class="headerlink" title="DubboProtocol#openServer"></a>DubboProtocol#openServer</h3><h2 id="4-6-注册到zookeeper细节流程"><a href="#4-6-注册到zookeeper细节流程" class="headerlink" title="4.6 注册到zookeeper细节流程"></a>4.6 注册到zookeeper细节流程</h2><h3 id="创建注册中心实例"><a href="#创建注册中心实例" class="headerlink" title="创建注册中心实例"></a>创建注册中心实例</h3><p>让我们将眼光重新看向RegistryProtocol的export方法中，在里面有如下代码段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// url to registry</span><br><span class="hljs-comment">// 获得注册中心</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> getRegistry(originInvoker);<br><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">registeredProviderUrl</span> <span class="hljs-operator">=</span> getUrlToRegistry(providerUrl, registryUrl);<br><br><span class="hljs-comment">// decide if we need to delay publish</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">register</span> <span class="hljs-operator">=</span> providerUrl.getParameter(REGISTER_KEY, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (register) &#123;<br>    <span class="hljs-comment">// 进行注册</span><br>    registry.register(registeredProviderUrl);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是将url注册到注册中心的代码。</p><p>在获取注册中心实例的方法，即getRegistry中，会利用zookeeper:&#x2F;&#x2F;192.168.235.123:2181&#x2F;org.apache.dubbo.registry.RegistryService?application&#x3D;dubbo-demo-annotation-provider&amp;dubbo&#x3D;2.0.2&amp;export&#x3D;dubbo%3A%2F%2F192.168.40.1%3A20880%2Forg.apache.dubbo.demo.DemoService这个地址获取实例。</p><p>在getRegistry中，会使用<strong>registryFactory.getRegistry(url)<strong>，其中url就是上面这个url，而这里的registryFactory则代表的是</strong>ZookeeperRegistryFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperRegistryFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRegistryFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ZookeeperTransporter zookeeperTransporter;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperRegistryFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.zookeeperTransporter = ZookeeperTransporter.getExtension();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Invisible injection of zookeeper client via IOC/SPI</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zookeeperTransporter</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Inject(enable = false)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZookeeperTransporter</span><span class="hljs-params">(ZookeeperTransporter zookeeperTransporter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.zookeeperTransporter = zookeeperTransporter;<br>    &#125;<br><br>    <span class="hljs-comment">// 这个方法的调用其实相当于模板方法的具体实现</span><br>   <span class="hljs-comment">// 因为在他的父类AbstractRegistryFactory#getRegistry中</span><br>    <span class="hljs-comment">// 就调用了该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Registry <span class="hljs-title function_">createRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperRegistry</span>(url, zookeeperTransporter);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220720184619430.png" alt="image-20220720184619430"></p><p>继续查看<strong>ZookeeperRegistry</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperRegistry</span><span class="hljs-params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> &#123;<br>    <span class="hljs-built_in">super</span>(url);<br>    <span class="hljs-keyword">if</span> (url.isAnyHost()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;registry address == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> url.getParameter(GROUP_KEY, DEFAULT_ROOT);<br>    <span class="hljs-keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;<br>        group = PATH_SEPARATOR + group;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.root = group;<br>    zkClient = zookeeperTransporter.connect(url);<br>    zkClient.addStateListener((state) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (state == StateListener.RECONNECTED) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Trying to fetch the latest urls, in case there&#x27;re provider changes during connection loss.\n&quot;</span> +<br>                        <span class="hljs-string">&quot; Since ephemeral ZNode will not get deleted for a connection lose, &quot;</span> +<br>                        <span class="hljs-string">&quot;there&#x27;s no need to re-register url of this instance.&quot;</span>);<br>            ZookeeperRegistry.<span class="hljs-built_in">this</span>.fetchLatestAddresses();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == StateListener.NEW_SESSION_CREATED) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Trying to re-register urls and re-subscribe listeners of this instance to registry...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                ZookeeperRegistry.<span class="hljs-built_in">this</span>.recover();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(e.getMessage(), e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == StateListener.SESSION_LOST) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Url of this instance will be deleted from registry soon. &quot;</span> +<br>                        <span class="hljs-string">&quot;Dubbo client will try to re-register once a new session is created.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == StateListener.SUSPENDED) &#123;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == StateListener.CONNECTED) &#123;<br><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码就是Zookeeper注册中心实例的创建，接下来要分析的就是向注册中心注册服务：</p><h3 id="进行注册"><a href="#进行注册" class="headerlink" title="进行注册"></a>进行注册</h3><p>注册的最终逻辑会来到ZookeeperRegistry的doRegistry方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">(URL url)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="hljs-literal">true</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(<span class="hljs-string">&quot;Failed to register &quot;</span> + url + <span class="hljs-string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即通过Zookeeper客户端创建节点，节点路径由toUrlPath生成，格式比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/$&#123;group&#125;/</span><span class="hljs-variable">$&#123;serviceInterface&#125;</span><span class="hljs-regexp">/providers/</span><span class="hljs-variable">$&#123;url&#125;</span><br>比如<br><span class="hljs-regexp">/dubbo/</span>org.apache.dubbo.DemoService<span class="hljs-regexp">/providers/</span>dubbo%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F127.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>......<br></code></pre></td></tr></table></figure><h1 id="第五章-服务引用（引入）"><a href="#第五章-服务引用（引入）" class="headerlink" title="第五章 服务引用（引入）"></a>第五章 服务引用（引入）</h1><h2 id="5-1-初始说明"><a href="#5-1-初始说明" class="headerlink" title="5.1 初始说明"></a>5.1 初始说明</h2><p>对于Dubbo的服务引用时机，默认有两种：懒汉式和饿汉式</p><ul><li>饿汉式：在Spring容器加载的时候调用ReferenceBean的afterPropertiesSet方法进行服务引用</li><li>懒汉式：只有当这个服务被注入到其他类中时启动引入流程，默认的。</li></ul><p>会先根据配置参数组装成 URL ，一般而言我们都会配置的注册中心，所以会构建 RegistryDirectory 向注册中心注册消费者的信息，并且订阅提供者、配置、路由等节点。</p><p>得知提供者的信息之后会进入 Dubbo 协议的引入，会创建 Invoker ，期间会包含 NettyClient，来进行远程通信，最后通过 Cluster 来包装 Invoker，默认是 FailoverCluster，最终返回代理类。</p><p><strong>服务引用的目的就是创建我们需要的被@DubboReference标注的Bean，将其注入到容器中，并且去构建一下服务真正调用时候的一些必要东西，比如调用哪个IP哪个端口哪个服务实例，这些东西其实就是服务目录</strong></p><p><strong>服务目录需要提前构建到本地，这样调用的时候不用再去注册中心获取，总的来说，服务引用就是为了构建服务目录</strong></p><p><strong>每一个服务提供者的结构都有一个服务目录</strong></p><p><strong>前置提醒：</strong>在Dubbo和Spring的整合中，有这么一个类：<strong>ReferenceAnnotationBeanPostProcessor</strong>，它在我们对Spring中的Bean进行populate的时候会发挥作用，也就是说，它会检查我们想要实例化的Bean中有没有属性或方法标注了**@DubboReference**注解，如果有，就将其给注入进去，这其实和@Autowried注解的解析原理差不多。</p><p><img src="image-20220721100722371.png" alt="image-20220721100722371"></p><p>它的核心方法是<strong>doGetInjectedBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doGetInjectedBean</span><span class="hljs-params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span><br><span class="hljs-params">                                   InjectionMetadata.InjectedElement injectedElement)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The name of bean that annotated Dubbo&#x27;s &#123;<span class="hljs-doctag">@link</span> Service <span class="hljs-doctag">@Service</span>&#125; in local Spring &#123;<span class="hljs-doctag">@link</span> ApplicationContext&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">referencedBeanName</span> <span class="hljs-operator">=</span> buildReferencedBeanName(attributes, injectedType);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The name of bean that is declared by &#123;<span class="hljs-doctag">@link</span> Reference <span class="hljs-doctag">@Reference</span>&#125; annotation injection</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">referenceBeanName</span> <span class="hljs-operator">=</span> getReferenceBeanName(attributes, injectedType);<br><br>    referencedBeanNameIdx.computeIfAbsent(referencedBeanName, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;String&gt;()).add(referenceBeanName);<br><br>    <span class="hljs-comment">// 创建ReferenceBean</span><br>    <span class="hljs-comment">// 其中懒汉式就在创建的时候调用afterPropertiesSet方法中执行</span><br>    <span class="hljs-type">ReferenceBean</span> <span class="hljs-variable">referenceBean</span> <span class="hljs-operator">=</span> buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">localServiceBean</span> <span class="hljs-operator">=</span> isLocalServiceBean(referencedBeanName, referenceBean, attributes);<br><br>    prepareReferenceBean(referencedBeanName, referenceBean, localServiceBean);<br><br>    registerReferenceBean(referencedBeanName, referenceBean, localServiceBean, referenceBeanName);<br><br>    cacheInjectedReferenceBean(referenceBean, injectedElement);<br><br>    <span class="hljs-comment">// 方法中的referenceBean.get就是饿汉式</span><br>    <span class="hljs-keyword">return</span> getBeanFactory().applyBeanPostProcessorsAfterInitialization(referenceBean.get(), referenceBeanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>但其实，无论是懒汉式还是饿汉式，最终的逻辑都会来到ReferenceBean或者ReferenceConfig的get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (destroyed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="hljs-string">&quot;) has already destroyed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果是饿汉式，这个get方法其实已经通过getObject执行过一次了，ref不为null</span><br>    <span class="hljs-comment">// 如果是懒汉式，就去执行init逻辑，</span><br>    <span class="hljs-keyword">if</span> (ref == <span class="hljs-literal">null</span>) &#123;<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220721101732383.png" alt="image-20220721101732383"></p><h2 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h2><h3 id="ReferenceConfig-init"><a href="#ReferenceConfig-init" class="headerlink" title="ReferenceConfig#init"></a>ReferenceConfig#init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialized) &#123; <span class="hljs-comment">// 避免重复初始化</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bootstrap == <span class="hljs-literal">null</span>) &#123;<br>            bootstrap = DubboBootstrap.getInstance();<br>            <span class="hljs-comment">// compatible with api call.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != <span class="hljs-built_in">this</span>.getRegistries()) &#123;<br>                bootstrap.registries(<span class="hljs-built_in">this</span>.getRegistries());<br>            &#125;<br>            bootstrap.initialize();<br>        &#125;<br><span class="hljs-comment">//////////////-----分割线1-------------------</span><br>        checkAndUpdateSubConfigs();<br><br>        checkStubAndLocal(interfaceClass);<br>        ConfigValidationUtils.checkMock(interfaceClass, <span class="hljs-built_in">this</span>);<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        map.put(SIDE_KEY, CONSUMER_SIDE);<br><br>        <span class="hljs-comment">// 这段代码省略</span><br>    <span class="hljs-comment">// 在分割线1和分割线2之间的所有代码，主要目的就是检查并更新一些配置，</span><br>    <span class="hljs-comment">// 以及对于要引入的服务的一些配置信息都存放在map中，</span><br>    <span class="hljs-comment">// 到时候会根据这些信息来创建代理对象</span><br>    <span class="hljs-comment">// 比如配置某个方法重试几次，超时时间等</span><br><br>    <span class="hljs-comment">////////////-------分割线2--------------------</span><br>    <span class="hljs-comment">// 创建代理对象，真正的核心逻辑</span><br>        ref = createProxy(map);<br><br>        serviceMetadata.setTarget(ref);<br>        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);<br>        <span class="hljs-type">ConsumerModel</span> <span class="hljs-variable">consumerModel</span> <span class="hljs-operator">=</span> repository.lookupReferredService(serviceMetadata.getServiceKey());<br>        consumerModel.setProxyObject(ref);<br>        consumerModel.init(attributes);<br><br>        initialized = <span class="hljs-literal">true</span>;<br><br>        checkInvokerAvailable();<br><br>        <span class="hljs-comment">// dispatch a ReferenceConfigInitializedEvent since 2.7.4</span><br>        dispatch(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceConfigInitializedEvent</span>(<span class="hljs-built_in">this</span>, invoker));<br>    &#125;<br></code></pre></td></tr></table></figure><p>构建好的map对象如下图所示：</p><p><img src="image-20220721133457286.png" alt="image-20220721133457286"></p><h3 id="ReferenceConfig-createProxy"><a href="#ReferenceConfig-createProxy" class="headerlink" title="ReferenceConfig#createProxy"></a>ReferenceConfig#createProxy</h3><p>对于代理的创建，其实分为三种情况：</p><ul><li>引用本地JVM服务</li><li>通过直连的方式引用远程服务，不走注册中心</li><li>通过注册中心引用远程服务</li></ul><p>不管是哪种引用方式，最后都会得到一个Invoker实例，如果有多个注册中心，多个服务提供者，就会得到一组Invoker实例。</p><p>此时就需要通过集群管理类Cluster将多个Invoker合并成一个实例。合并后的实例具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，因为会对用户业务代码造成侵入。</p><p>无论是三种情况种的哪一种，最后都需要通过ProxyFactory为服务接口生成代理类，让代理类去调用Invoker逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createProxy</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> &#123;<br>    <span class="hljs-comment">// 引用本地服务，JVM 本地暴露</span><br>    <span class="hljs-keyword">if</span> (shouldJvmRefer(map)) &#123;<br>        <span class="hljs-comment">// 生成本地引用URL，协议为injvm</span><br>        <span class="hljs-comment">// 调用refer方法创建InjvmInvoker实例</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="hljs-number">0</span>, interfaceClass.getName()).addParameters(map);<br>        invoker = REF_PROTOCOL.refer(interfaceClass, url);<br>        <span class="hljs-comment">// 省略日志</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这个else主要目的是，读取直连配置项或注册中心url，</span><br>        <span class="hljs-comment">// 并将读取到的url存储到urls中</span><br>        <span class="hljs-comment">// 后续会对urls的size进行判断，如果是一个，则直接通过Protocol构建Invoker</span><br>        <span class="hljs-comment">// 否则对urls挨个构建他们自己的Invoker，并放入invokers中，</span><br>        <span class="hljs-comment">// 使用Cluster合并invokers</span><br>        urls.clear();<br>        <span class="hljs-comment">// URL不为空，就是点对点调用，不走注册中心的RPC调用</span><br>        <span class="hljs-keyword">if</span> (url != <span class="hljs-literal">null</span> &amp;&amp; url.length() &gt; <span class="hljs-number">0</span>) &#123; <br>            <span class="hljs-comment">// 当需要配置多个url的时候，可用分号进行分割</span><br>            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);<br>            <span class="hljs-keyword">if</span> (us != <span class="hljs-literal">null</span> &amp;&amp; us.length &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String u : us) &#123;<br>                    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> URL.valueOf(u);<br>                    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;<br>                        url = url.setPath(interfaceName); <br>                        <span class="hljs-comment">// 设置接口全限定名为url路径</span><br>                    &#125;<span class="hljs-comment">// 检测url协议是否为registry，如果是，表明用户想使用指定的注册中心</span><br>                    <span class="hljs-keyword">if</span> (UrlUtils.isRegistry(url)) &#123;<br>                        <span class="hljs-comment">// 将map转换为查询字符串，并作为refer参数的值添加到url种</span><br>                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span><br>        <span class="hljs-comment">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span><br>        <span class="hljs-comment">// 最后将合并后的配置设置为 url 查询字符串中</span><br>                        urls.add(ClusterUtils.mergeUrl(url, map));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// URL为空，从注册中心的配置中组装URL</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">// 确保协议不是inJvm</span><br>            <span class="hljs-keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;<br>                <span class="hljs-comment">// 检查注册表配置是否存在，然后将其转换为RegistryConfig</span><br>                checkRegistry();<br>                <span class="hljs-comment">// 通过注册中心的配置，生成us</span><br>                <span class="hljs-comment">//registry://192.168.235.123:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-annotation-consumer&amp;dubbo=2.0.2&amp;id=registryConfig&amp;pid=20440&amp;registry=zookeeper&amp;release=2.7.16&amp;timeout=20000&amp;timestamp=1658381745331</span><br>                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="hljs-built_in">this</span>, <span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 遍历集合</span><br>                <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;<br>                    <span class="hljs-keyword">for</span> (URL u : us) &#123;<br>                        <span class="hljs-comment">// 尝试获取monitorURL，如果存在就添加到map种</span><br>                        <span class="hljs-type">URL</span> <span class="hljs-variable">monitorUrl</span> <span class="hljs-operator">=</span> ConfigValidationUtils.loadMonitor(<span class="hljs-built_in">this</span>, u);<br>                        <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-literal">null</span>) &#123;<br>                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));<br>                        &#125; <span class="hljs-comment">// 将map转换为参数字符串格式，并拼接到url上</span><br>                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (urls.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 未配置注册中心，抛出异常</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br><span class="hljs-comment">// 只有一个注册中心或服务的提供者</span><br>        <span class="hljs-keyword">if</span> (urls.size() == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 调用RegistryProtocol的refer构建Invoker实例</span><br>            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="hljs-number">0</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 根据每一个URL构建invoker实例，添加到List集合</span><br>            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Invoker&lt;?&gt;&gt;();<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">registryURL</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>                <span class="hljs-comment">// refprotocol会在运行时根据url协议投加载指定的Protocol实例</span><br>                <span class="hljs-comment">// 并调用实例的refer方法</span><br>                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));<br>                <span class="hljs-keyword">if</span> (UrlUtils.isRegistry(url)) &#123;<br>                    registryURL = url; <span class="hljs-comment">// use last registry url</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (registryURL != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//如果注册中心链接不为空</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">cluster</span> <span class="hljs-operator">=</span> registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);<br>                <span class="hljs-comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span><br>                <span class="hljs-comment">// 由Cluster对多个Invoker进行合并</span><br>                invoker = Cluster.getCluster(cluster, <span class="hljs-literal">false</span>).join(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDirectory</span>(registryURL, invokers));<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// not a registry url, must be direct invoke.</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">cluster</span> <span class="hljs-operator">=</span> CollectionUtils.isNotEmpty(invokers)<br>                    ?<br>                    (invokers.get(<span class="hljs-number">0</span>).getUrl() != <span class="hljs-literal">null</span> ? invokers.get(<span class="hljs-number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) :<br>                     Cluster.DEFAULT)<br>                    : Cluster.DEFAULT;<br>                invoker = Cluster.getCluster(cluster).join(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDirectory</span>(invokers));<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 省略部分代码</span><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">consumerURL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, map.get(INTERFACE_KEY), map);<br>    MetadataUtils.publishServiceDefinition(consumerURL);<br><br>    <span class="hljs-comment">// create service proxy 生成代理类</span><br>    <span class="hljs-keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));<br>&#125;<br></code></pre></td></tr></table></figure><p>最后生成的Invoker（以我们的调试代码为例）如下图所示：</p><p><img src="image-20220721160729430.png" alt="image-20220721160729430"></p><p>在上面的分析中，我们已经创建好了Invoker，创建过程中实现的服务引用、生成服务者消费者链接，并向注册中心进行注册，订阅providers、configurators等节点下的数据。这些详细过程放到下一小节。</p><p>接下来就是为服务接口生成代理对象。也就是ReferenceConfig#createProxy方法的最后一句：PROXY_FACTORY.getProxy</p><p>createProxy方法执行完毕之后的代理为：它里面就包含了我们之间创建好的Invoker</p><p><img src="image-20220721160238497.png" alt="image-20220721160238497"></p><h2 id="5-3-Invoker创建"><a href="#5-3-Invoker创建" class="headerlink" title="5.3 Invoker创建"></a>5.3 Invoker创建</h2><p>注意的是，我们通过REF_PROTOCOL.refer进行Invoker的创建，同时它又是ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()，通过Dubbo的自适应SPI机制，会经过层层包装</p><p><img src="image-20220721165921661.png" alt="image-20220721165921661"></p><p>最终调用到<strong>RegistryProtocol的refer方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>    url = getRegistryUrl(url); <span class="hljs-comment">// 取 registry 参数值，并将其设置为协议头</span><br>    <span class="hljs-comment">// 获取注册中心实例</span><br>    <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> registryFactory.getRegistry(url); <br>    <span class="hljs-keyword">if</span> (RegistryService.class.equals(type)) &#123;<br>        <span class="hljs-keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);<br>    &#125;<br><br>    <span class="hljs-comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span><br>    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> qs.get(GROUP_KEY);<br>    <span class="hljs-keyword">if</span> (group != <span class="hljs-literal">null</span> &amp;&amp; group.length() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="hljs-number">1</span> || <span class="hljs-string">&quot;*&quot;</span>.equals(group)) &#123;<span class="hljs-comment">// 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行服务引用逻辑</span><br>            <span class="hljs-keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);<br>        &#125;<br>    &#125; <span class="hljs-comment">// 我们的逻辑</span><br>    <span class="hljs-keyword">return</span> doRefer(cluster, registry, type, url);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RegistryProtocol-doRefer"><a href="#RegistryProtocol-doRefer" class="headerlink" title="RegistryProtocol#doRefer"></a>RegistryProtocol#doRefer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">doRefer</span><span class="hljs-params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> &#123;<br>    <span class="hljs-comment">// 创建 RegistryDirectory 实例</span><br>    RegistryDirectory&lt;T&gt; directory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryDirectory</span>&lt;T&gt;(type, url);<br>    <span class="hljs-comment">// 设置注册中心和协议</span><br>    directory.setRegistry(registry);<br>    directory.setProtocol(protocol);<br>    <span class="hljs-comment">// all attributes of REFER_KEY</span><br>    Map&lt;String, String&gt; parameters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;(directory.getConsumerUrl().getParameters());<br>     <span class="hljs-comment">// 生成服务消费者链接</span><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">subscribeUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, type.getName(), parameters);<br>    <span class="hljs-keyword">if</span> (directory.isShouldRegister()) &#123;<br>       <span class="hljs-comment">// 注册服务消费者，在 consumers 目录下新节点 directory.setRegisteredConsumerUrl(subscribeUrl);</span><br>        registry.register(directory.getRegisteredConsumerUrl());<br>    &#125;<br>    directory.buildRouterChain(subscribeUrl);<br>   <span class="hljs-comment">// 订阅 providers、configurators、routers 等节点数据 directory.subscribe(toSubscribeUrl(subscribeUrl));</span><br> <span class="hljs-comment">// 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个</span><br>    Invoker&lt;T&gt; invoker = cluster.join(directory);<br>    List&lt;RegistryProtocolListener&gt; listeners = findRegistryProtocolListeners(url);<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(listeners)) &#123;<br>        <span class="hljs-keyword">return</span> invoker;<br>    &#125;<br><br>    RegistryInvokerWrapper&lt;T&gt; registryInvokerWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryInvokerWrapper</span>&lt;&gt;(directory, cluster, invoker, subscribeUrl);<br>    <span class="hljs-keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;<br>        listener.onRefer(<span class="hljs-built_in">this</span>, registryInvokerWrapper);<br>    &#125;<br>    <span class="hljs-keyword">return</span> registryInvokerWrapper;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们的doRefer方法的核心逻辑的处理都交给了RegistryDirectory来完成了。</p><p>它能够生成服务消费者链接，并注册到注册中心的consumers节点中，还会订阅providers等节点下的数据，如果一个注册中心有多个服务提供者的节点，就会将多个合并成一个，提供容错机制的包装</p><p>Dicrectory也是SPI接口，内部维护者一个List，这个List会动态变化</p><p><strong>后续还有DubboProtocol的流程以后再分析</strong></p><h2 id="5-4-代理对象生成"><a href="#5-4-代理对象生成" class="headerlink" title="5.4 代理对象生成"></a>5.4 代理对象生成</h2><p>代理对象生成的代码是<strong>PROXY_FACTORY.getProxy</strong>，而PROXY_FACTORY同样也是Dubbo自适应SPI引入的，经过了StubProxyFactoryWrapper之后，来到了AbstractProxyFactory</p><p>其实后续的代理对象生成逻辑都是Javassist的逻辑，也没必要详细分析，只需要知道通过JavassistProxyFactory将对象代理生成</p><h3 id="AbstractProxyFactory"><a href="#AbstractProxyFactory" class="headerlink" title="AbstractProxyFactory"></a>AbstractProxyFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-type">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> invoker.getUrl().getParameter(INTERFACES);<br>    <span class="hljs-keyword">if</span> (config != <span class="hljs-literal">null</span> &amp;&amp; config.length() &gt; <span class="hljs-number">0</span>) &#123;<br>        String[] types = COMMA_SPLIT_PATTERN.split(config);<br>        <span class="hljs-keyword">for</span> (String type : types) &#123;<br>            <span class="hljs-comment">// TODO can we load successfully for a different classloader?.</span><br>            interfaces.add(ReflectUtils.forName(type));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (generic) &#123;<br>        <span class="hljs-keyword">if</span> (!GenericService.class.isAssignableFrom(invoker.getInterface())) &#123;<br>            interfaces.add(com.alibaba.dubbo.rpc.service.GenericService.class);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// find the real interface from url</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">realInterface</span> <span class="hljs-operator">=</span> invoker.getUrl().getParameter(Constants.INTERFACE);<br>            interfaces.add(ReflectUtils.forName(realInterface));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-comment">// ignore</span><br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 添加我们的接口DemoService</span><br>    interfaces.add(invoker.getInterface());<br>    <span class="hljs-comment">// 添加内部的接口 </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">private static final Class&lt;?&gt;[] INTERNAL_INTERFACES = new Class&lt;?&gt;[]&#123;</span><br><span class="hljs-comment">            EchoService.class, Destroyable.class</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">    */</span><br>    interfaces.addAll(Arrays.asList(INTERNAL_INTERFACES));<br><span class="hljs-comment">// 抽象方法，最后交给子类实现</span><br>    <span class="hljs-keyword">return</span> getProxy(invoker, interfaces.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[<span class="hljs-number">0</span>]));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span>;<br></code></pre></td></tr></table></figure><h3 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h3><p>AbstractProxyFactory的实现类是JavassistProxyFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> &#123;<br>    <span class="hljs-keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerInvocationHandler</span>(invoker));<br>&#125;<br></code></pre></td></tr></table></figure><p>生成Proxy子类（Proxy是抽象类），并效用Proxy子类的newInstance方法创建Proxy实例。</p><p>InvokerInvocationHandler实现JDK的InvocationHandler接口，具体的用途是拦截接口类调用</p><h3 id="Proxy-getProxy"><a href="#Proxy-getProxy" class="headerlink" title="Proxy#getProxy"></a>Proxy#getProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Proxy <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt;... ics)</span> &#123;<br>    <span class="hljs-keyword">return</span> getProxy(ClassUtils.getClassLoader(Proxy.class), ics);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Proxy <span class="hljs-title function_">getProxy</span><span class="hljs-params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ics.length &gt; MAX_PROXY_COUNT) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;interface limit exceeded&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// 遍历接口列表</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ics.length; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">itf</span> <span class="hljs-operator">=</span> ics[i].getName();<br>        <span class="hljs-keyword">if</span> (!ics[i].isInterface()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(itf + <span class="hljs-string">&quot; is not a interface.&quot;</span>);<br>        &#125;<br><br>        Class&lt;?&gt; tmp = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 重新加载接口类</span><br>            tmp = Class.forName(itf, <span class="hljs-literal">false</span>, cl);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (tmp != ics[i]) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(ics[i] + <span class="hljs-string">&quot; is not visible from class loader&quot;</span>);<br>        &#125;<br><span class="hljs-comment">// 拼接接口全限定名，</span><br>        sb.append(itf).append(<span class="hljs-string">&#x27;;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// org.apache.dubbo.rpc.service.Destroyable;org.apache.dubbo.demo.DemoService;com.alibaba.dubbo.rpc.service.EchoService;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sb.toString();<br><br>    <span class="hljs-comment">// get cache by class loader.</span><br>    <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; cache;<br>    <span class="hljs-keyword">synchronized</span> (PROXY_CACHE_MAP) &#123;<br>        cache = PROXY_CACHE_MAP.computeIfAbsent(cl, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (cache) &#123;<br>        <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 从缓存中获取Reference&lt;Proxy&gt;实例</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Reference&lt;?&gt;) &#123;<br>                proxy = (Proxy) ((Reference&lt;?&gt;) value).get();<br>                <span class="hljs-keyword">if</span> (proxy != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> proxy;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">// 并发控制，保证只有一个线程可以进行后续操作</span><br>            <span class="hljs-keyword">if</span> (value == PENDING_GENERATION_MARKER) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    cache.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cache.put(key, PENDING_GENERATION_MARKER);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> PROXY_CLASS_COUNTER.getAndIncrement();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ClassGenerator</span> <span class="hljs-variable">ccp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, ccm = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 创建ClassGenerator对象</span><br>        ccp = ClassGenerator.newInstance(cl);<br><br>        Set&lt;String&gt; worked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ics.length; i++) &#123;<br>            <span class="hljs-comment">// 检测接口访问类型是否是Public</span><br>            <span class="hljs-keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">npkg</span> <span class="hljs-operator">=</span> ics[i].getPackage().getName();<br>                <span class="hljs-keyword">if</span> (pkg == <span class="hljs-literal">null</span>) &#123;<br>                    pkg = npkg;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!pkg.equals(npkg)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;non-public interfaces from different packages&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-comment">// 添加接口到 ClassGenerator 中</span><br>            ccp.addInterface(ics[i]);<br><span class="hljs-comment">// 遍历接口方法</span><br>            <span class="hljs-keyword">for</span> (Method method : ics[i].getMethods()) &#123;<br>                <span class="hljs-comment">// 获取方法描述信息，理解为方法签名</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> ReflectUtils.getDesc(method);<br>                <span class="hljs-keyword">if</span> (worked.contains(desc) || Modifier.isStatic(method.getModifiers())) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ics[i].isInterface() &amp;&amp; Modifier.isStatic(method.getModifiers())) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                worked.add(desc);<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">ix</span> <span class="hljs-operator">=</span> methods.size();<br>                Class&lt;?&gt; rt = method.getReturnType();<br>                Class&lt;?&gt;[] pts = method.getParameterTypes();<br><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Object[] args = new Object[&quot;</span>).append(pts.length).append(<span class="hljs-string">&quot;];&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; pts.length; j++) &#123;<br>                    code.append(<span class="hljs-string">&quot; args[&quot;</span>).append(j).append(<span class="hljs-string">&quot;] = ($w)$&quot;</span>).append(j + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;;&quot;</span>);<br>                &#125;<br>                code.append(<span class="hljs-string">&quot; Object ret = handler.invoke(this, methods[&quot;</span>).append(ix).append(<span class="hljs-string">&quot;], args);&quot;</span>);<br>                <span class="hljs-keyword">if</span> (!Void.TYPE.equals(rt)) &#123;<br>                    code.append(<span class="hljs-string">&quot; return &quot;</span>).append(asArgument(rt, <span class="hljs-string">&quot;ret&quot;</span>)).append(<span class="hljs-string">&quot;;&quot;</span>);<br>                &#125;<br><br>                methods.add(method);<br>                <span class="hljs-comment">// 添加方法名、访问控制符、参数列表、方法代码等信息</span><br>                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pkg == <span class="hljs-literal">null</span>) &#123;<br>            pkg = PACKAGE_NAME;<br>        &#125;<br><span class="hljs-comment">// 构建接口代理类名称，</span><br>        <span class="hljs-comment">// org.apache.dubbo.common.bytecode.proxy0</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">pcn</span> <span class="hljs-operator">=</span> pkg + <span class="hljs-string">&quot;.proxy&quot;</span> + id;<br>        ccp.setClassName(pcn);<br>        ccp.addField(<span class="hljs-string">&quot;public static java.lang.reflect.Method[] methods;&quot;</span>);<br>        <span class="hljs-comment">// 生成 private java.lang.reflect.InvocationHandler handler;</span><br>        ccp.addField(<span class="hljs-string">&quot;private &quot;</span> + InvocationHandler.class.getName() + <span class="hljs-string">&quot; handler;&quot;</span>);<br>        <span class="hljs-comment">// 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：</span><br>        <span class="hljs-comment">// porxy0(java.lang.reflect.InvocationHandler arg0) &#123;</span><br>        <span class="hljs-comment">//     handler=$1;</span><br>    <span class="hljs-comment">// &#125;</span><br>        ccp.addConstructor(Modifier.PUBLIC, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;handler=$1;&quot;</span>);<br>        <span class="hljs-comment">// 为接口代理类添加默认构造方法</span><br>        ccp.addDefaultConstructor();<br>        <br>        <span class="hljs-comment">// 生成接口代理类</span><br>        Class&lt;?&gt; clazz = ccp.toClass();<br>        clazz.getField(<span class="hljs-string">&quot;methods&quot;</span>).set(<span class="hljs-literal">null</span>, methods.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Method</span>[<span class="hljs-number">0</span>]));<br><br>        <span class="hljs-comment">// create Proxy class. // 构建 Proxy 子类名称，比如 Proxy1，Proxy2 等</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fcn</span> <span class="hljs-operator">=</span> Proxy.class.getName() + id;<br>        ccm = ClassGenerator.newInstance(cl);<br>        ccm.setClassName(fcn);<br>        ccm.addDefaultConstructor();<br>        ccm.setSuperClass(Proxy.class);<br>        <br>        <span class="hljs-comment">// 为 Proxy 的抽象方法 newInstance 生成实现代码，形如：</span><br>        <span class="hljs-comment">// public Object newInstance(java.lang.reflect.InvocationHandler h) &#123; </span><br>        <span class="hljs-comment">//     return new org.apache.dubbo.proxy0($1);</span><br>        <span class="hljs-comment">// &#125;</span><br>        ccm.addMethod(<span class="hljs-string">&quot;public Object newInstance(&quot;</span> + InvocationHandler.class.getName() + <span class="hljs-string">&quot; h)&#123; return new &quot;</span> + pcn + <span class="hljs-string">&quot;($1); &#125;&quot;</span>);<br>        Class&lt;?&gt; pc = ccm.toClass(); <span class="hljs-comment">// 生成 Proxy 实现类</span><br>        proxy = (Proxy) pc.newInstance(); <span class="hljs-comment">// 通过反射创建 Proxy 实例</span><br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// release ClassGenerator</span><br>        <span class="hljs-keyword">if</span> (ccp != <span class="hljs-literal">null</span>) &#123;<br>            ccp.release();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ccm != <span class="hljs-literal">null</span>) &#123;<br>            ccm.release();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (cache) &#123;<br>            <span class="hljs-keyword">if</span> (proxy == <span class="hljs-literal">null</span>) &#123;<br>                cache.remove(key);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cache.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Proxy&gt;(proxy));<br>            &#125;<br>            cache.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上述的ccp和ccm：</p><p>ccp即ClassGenerator，它用于为服务接口生成代理类，比如我们有一个DemoService接口，这个接口代理类就是由ccp生成的。</p><p>而ccm则是用于为org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法。</p><p>最后生成的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.common.bytecode;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">proxy0</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">org</span>.apache.dubbo.demo.DemoService &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.reflect.Method[] methods;<br><br>    <span class="hljs-keyword">private</span> java.lang.reflect.InvocationHandler handler;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">proxy0</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">proxy0</span><span class="hljs-params">(java.lang.reflect.InvocationHandler arg0)</span> &#123;<br>        handler = $<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(java.lang.String arg0)</span> &#123;<br>        Object[] args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>];<br>        args[<span class="hljs-number">0</span>] = ($w) $<span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> handler.invoke(<span class="hljs-built_in">this</span>, methods[<span class="hljs-number">0</span>], args);<br>        <span class="hljs-keyword">return</span> (java.lang.String) ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-小总结"><a href="#5-5-小总结" class="headerlink" title="5.5 小总结"></a>5.5 小总结</h2><blockquote><p>面试怎么回答？</p></blockquote><ul><li>首先我们知道，在服务消费者那边，它将想要暴露的服务暴露出来，并将信息注册到注册中心，而我们消费者想要做的服务引入，其实就是从注册中心拉取消费者的providers节点信息，并将自己的信息也注册到注册中心，同时生成服务接口的代理类，它能执行真正的请求。</li><li>而服务的引用时机有两种，分为懒汉式和饿汉式。饿汉式就是在Spring容器加载的时候调用ReferenceBean的afterPropertiesSet进行服务引用，还有一种就是只有当这个服务被注入到其他类的时候启动引入流程，默认的。</li><li>比如DemoController中引入了DemoService，懒汉式的实现方式是通过在给Controller进行populateBean的时候，使用ReferenceAnnotationBeanPostProcessor的postProcessPropertyValues方法进行的，它会解析标注了@DubboReference注解的属性，和@Autowired差不多。</li><li>对于代理的创建，总体而言有三种情况：引用本地JVM服务、直连方式，不需要注册中心、通过注册中心的方式。</li><li>无论是哪种方式，都需要创建Invoker，它使用REF_PROTOCOL的ref方法进行创建，需要RegistryProtocol和DubboProtocol；在创建的过程中，并构建RegistryDirectory，核心逻辑交给这个注册目录进行，它会根据配置参数组装成consumerURL，并且将consumers节点注册找注册中心，并且订阅providers、configurators、routers等节点的数据。而且如果一个注册中心中有多个服务提供者的节点，还会将多个合并成一个，并提供容错机制，包括负载均衡等。</li><li>创建好了Invoker之后，其实就已经具备了相关功能，但是为了不造成侵入，对用户无感知，就得创建代理类，创建使用JavassistProxyFactory。</li><li>生成的代理类被注入到Controller中，以后调用的时候，就直接走的是代理逻辑。</li></ul><blockquote><p>在消费者获取 Invoker 过程中大量出现了将多个 invoker 伪装为一个 Invoker 的情况， 为什么要这样设计呢？</p></blockquote><p>这样设计主要是为了应用服务路由、负载均衡、集群容错机制。即可以根据需求选择需要的 若干 Invoker，然后在对路由结果的 Invoker 进行负载均衡，选择出一个 Invoker。若选择出的 这个 Invoker 存在问题，则再根据不同的容错机制进行处理。</p><h1 id="第六章-服务调用过程"><a href="#第六章-服务调用过程" class="headerlink" title="第六章 服务调用过程"></a>第六章 服务调用过程</h1><p>调用某个接口的方法会调用之前生成的代理类，然后会先根据设置的<strong>服务降级策略</strong>进行判断，如果没有指定，就直接进行远程调用；如果指定的是强制降级就直接进行降级处理，不再发送远程请求；如果是其他的，首先会发送远程调用，然后发现没有可用的invoker后才会触发降级处理。</p><p>然后经过<strong>路由的过滤</strong>、<strong>负载均衡机制</strong>选择一个 invoker 发起远程调用，此时会记录此请求和请求的 ID 等待服务端的响应。</p><p>服务端接受请求之后会通过参数找到之前暴露存储的 map，得到相应的 exporter ，然后最终调用真正的实现类，再组装好结果返回，这个响应会带上之前请求的 ID。</p><p>消费者收到这个响应之后会通过 ID 去找之前记录的请求，然后找到请求之后将响应塞到对应的 Future 中，唤醒等待的线程，最后消费者得到响应，一个流程完毕。</p><p>如果处理过程发生异常，会按照<strong>集群容错策略</strong>进行容错处理。</p><p>关键的就是 cluster、路由、负载均衡，然后 Dubbo 默认是异步的，所以请求和响应是如何对应上的。</p><p>两者的通信采用Netty作为底层，调用过程会进行序列化和反序列化</p><blockquote><p>简述提供者处理消费者远程调用请求的整个过程。</p></blockquote><p>当 NettyClient 发送来消息后，NettyServer 的服务端处理器的 channelRead()方法就会 被触发，而该方法的 msg 参数就是 NettyClient 发送来的 RpcInvocation。这里的整个执行流 程是这样的：</p><ul><li>NettyServerHandler 的 channelRead()方法接收到客户端请求。 </li><li>Dispatcher 线程派发器线程池执行器从线程池中派发一个线程对客户端请求进行处理。</li><li>执行线程根据接收到的 msg 从 exporterMap 中获取到相应的服务暴露对象 exporter，然 后从 exporter 中获取到相应的 invoker。</li><li>invoker 调用其 invoke()完成远程调用的 Server 运算，并形成结果响应对象。</li><li>将结果响应对象发送给消费者端。</li></ul><p>**我们知道，服务发布过程主要完成了三大任务：将服务提供者注册到注册中心，将 服务暴露实例缓存到 exporterMap，启动 Netty Server。也就是说，在服务发布过程中就已经 将服务暴露实例缓存到了 exporterMap，以备后续真正远程调用的处理。 **</p><p><strong>当提供者通过 Netty Server 接收到消费者通过 Netty Client 发送的远程调用请求时，提供 者最终会从 exporterMap 中查找到其真正需要的 exporter，然后从中获取到相应的 invoker， 然后再调用 invoker 的 invoke()方法完成远程调用在服务端的本地执行。当然，提供者会将这 个执行结果再通过 Netty Server 发送给消费者。</strong></p><h2 id="6-1-服务调用方式"><a href="#6-1-服务调用方式" class="headerlink" title="6.1 服务调用方式"></a>6.1 服务调用方式</h2><p>如果我们将DemoService的代理类进行反编译，就会发现sayHello方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String string)</span> &#123;<br>    <span class="hljs-comment">// 将参数存储到 Object 数组中</span><br>    Object[] arrobject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;string&#125;;<br>    <span class="hljs-comment">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.handler.invoke(<span class="hljs-built_in">this</span>, methods[<span class="hljs-number">0</span>], arrobject);<br>    <span class="hljs-comment">// 返回调用结果</span><br>    <span class="hljs-keyword">return</span> (String)object;<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实是调用了InvocationHandler实现类的invoker方法，并将调用结果进行返回。</p><h3 id="InvokerInvocationHandler-invoke"><a href="#InvokerInvocationHandler-invoke" class="headerlink" title="InvokerInvocationHandler#invoke"></a>InvokerInvocationHandler#invoke</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvokerInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(InvokerInvocationHandler.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Invoker&lt;?&gt; invoker;<br>    <span class="hljs-keyword">private</span> ConsumerModel consumerModel;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InvokerInvocationHandler</span><span class="hljs-params">(Invoker&lt;?&gt; handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.invoker = handler;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serviceKey</span> <span class="hljs-operator">=</span> invoker.getUrl().getServiceKey();<br>        <span class="hljs-keyword">if</span> (serviceKey != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.consumerModel = ApplicationModel.getConsumerModel(serviceKey);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 拦截定义在Object类中未被重写的方法，比如wait/notify</span><br>        <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(invoker, args);<br>        &#125;<br>        <span class="hljs-comment">// 如果是toString、hashCode、equals等方法被子类重写了，也直接调用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<br>        <span class="hljs-keyword">if</span> (parameterTypes.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;toString&quot;</span>.equals(methodName)) &#123;<br>                <span class="hljs-keyword">return</span> invoker.toString();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;$destroy&quot;</span>.equals(methodName)) &#123;<br>                invoker.destroy();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;hashCode&quot;</span>.equals(methodName)) &#123;<br>                <span class="hljs-keyword">return</span> invoker.hashCode();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameterTypes.length == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">&quot;equals&quot;</span>.equals(methodName)) &#123;<br>            <span class="hljs-keyword">return</span> invoker.equals(args[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// RpcInvocation [methodName=sayHello, parameterTypes=[class java.lang.String], arguments=[world], attachments=&#123;&#125;]</span><br>        <span class="hljs-type">RpcInvocation</span> <span class="hljs-variable">rpcInvocation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcInvocation</span>(method, invoker.getInterface().getName(), args);<br>        <span class="hljs-comment">// serviceKey： org.apache.dubbo.demo.DemoService</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">serviceKey</span> <span class="hljs-operator">=</span> invoker.getUrl().getServiceKey();<br>        <span class="hljs-comment">// this.targetServiceUniqueName = targetServiceUniqueName;</span><br>        rpcInvocation.setTargetServiceUniqueName(serviceKey);<br><br>        <span class="hljs-keyword">if</span> (consumerModel != <span class="hljs-literal">null</span>) &#123;<br>            rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);<br>            rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoker.invoke(rpcInvocation).recreate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于InvokerInvokeHandler的invoke成员变量invoker，它的类型其实是<strong>MockClusterInvoker</strong>，通过之前的分析，我们知道它内部封装了服务降级的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockClusterInvoker</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Invoker</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MockClusterInvoker.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Directory&lt;T&gt; directory;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Invoker&lt;T&gt; invoker;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 获取服务降级的配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();<br>        <span class="hljs-comment">// 我们的示例中，value值是false，直接走no mock逻辑</span><br>        <span class="hljs-keyword">if</span> (value.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;false&quot;</span>.equalsIgnoreCase(value)) &#123;<br>            <span class="hljs-comment">//no mock</span><br>            result = <span class="hljs-built_in">this</span>.invoker.invoke(invocation);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.startsWith(<span class="hljs-string">&quot;force&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 强制降级，不发起远程调用</span><br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;force-mock: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; force-mock enabled , url : &quot;</span> + getUrl());<br>            &#125;<br>            <span class="hljs-comment">//force:direct mock</span><br>            result = doMockInvoke(invocation, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 表示消费者调用服务失败后，再执行mock逻辑，</span><br>            <span class="hljs-comment">//fail-mock</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                result = <span class="hljs-built_in">this</span>.invoker.invoke(invocation);<br><br>                <span class="hljs-comment">//fix:#4585</span><br>                <span class="hljs-keyword">if</span>(result.getException() != <span class="hljs-literal">null</span> &amp;&amp; result.getException() <span class="hljs-keyword">instanceof</span> RpcException)&#123;<br>                    RpcException rpcException= (RpcException)result.getException();<br>                    <span class="hljs-keyword">if</span>(rpcException.isBiz())&#123;<br>                        <span class="hljs-keyword">throw</span>  rpcException;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        result = doMockInvoke(invocation, rpcException);<br>                    &#125;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>                <span class="hljs-keyword">if</span> (e.isBiz()) &#123;<br>                    <span class="hljs-keyword">throw</span> e;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;fail-mock: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot; fail-mock enabled , url : &quot;</span> + getUrl(), e);<br>                &#125;<br>                result = doMockInvoke(invocation, e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于服务降级的具体逻辑以及它来由来我们之后单独放到一个章节中进行分析，这里只是说明了一下它的基本逻辑。</p><h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><p><img src="image-20220722215332188.png" alt="image-20220722215332188"></p><p>可以看到，在MockClusterInvoker调用它的invoker的invoke方法的时候，会来到FailoverClusterInvoker，这个类之后再分析，如上图所示，经过一系列调用之后，会来到AbstractInvoker类，而这个类就是DubboInvoker的抽象父类。该抽象类实现了invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">invoke</span><span class="hljs-params">(Invocation inv)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br><br>    <span class="hljs-keyword">if</span> (destroyed.get()) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Invoker for service &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost() + <span class="hljs-string">&quot; is destroyed, &quot;</span><br>                    + <span class="hljs-string">&quot;, dubbo version is &quot;</span> + Version.getVersion() + <span class="hljs-string">&quot;, this invoker should not be used any longer&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">RpcInvocation</span> <span class="hljs-variable">invocation</span> <span class="hljs-operator">=</span> (RpcInvocation) inv;<br>    invocation.setInvoker(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 设置Invoker</span><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;<br>        <span class="hljs-comment">// 设置attachment</span><br>        invocation.addObjectAttachmentsIfAbsent(attachment);<br>    &#125;<br><br>    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;<br><span class="hljs-comment">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span><br>        invocation.addObjectAttachments(contextAttachments);<br>    &#125;<br><br>    invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));<br>    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);<br><br>    AsyncRpcResult asyncResult;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// doInvoke方法由子类去实现，结果就是最终调用之后返回的结果（之后会解析）</span><br>        asyncResult = (AsyncRpcResult) doInvoke(invocation);<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123; <span class="hljs-comment">// biz exception</span><br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">te</span> <span class="hljs-operator">=</span> e.getTargetException();<br>        <span class="hljs-keyword">if</span> (te == <span class="hljs-literal">null</span>) &#123;<br>            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-literal">null</span>, e, invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (te <span class="hljs-keyword">instanceof</span> RpcException) &#123;<br>                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);<br>            &#125;<br>            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-literal">null</span>, te, invocation);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;<br>        <span class="hljs-keyword">if</span> (e.isBiz()) &#123;<br>            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-literal">null</span>, e, invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="hljs-literal">null</span>, e, invocation);<br>    &#125;<br>    RpcContext.getContext().setFuture(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureAdapter</span>(asyncResult.getResponseFuture()));<br>    <span class="hljs-keyword">return</span> asyncResult;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">doInvoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br></code></pre></td></tr></table></figure><p>该抽象类的invoke方法，主要是添加信息到RpcInvocation#attachment变量中，添加完毕之后就会进行doInvoke执行后续的调用，并返回AsyncResult。</p><p>设置完后的RpcInvocation如下图所示：</p><p><img src="image-20220722220148391.png" alt="image-20220722220148391"></p><p>我们来看<strong>DubboInvoker的doInvoke方法</strong></p><p><strong>注：其实每一个接口都会有自己的DubboInvoker，自己的MockClusterInvoker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Result <span class="hljs-title function_">doInvoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">RpcInvocation</span> <span class="hljs-variable">inv</span> <span class="hljs-operator">=</span> (RpcInvocation) invocation;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> RpcUtils.getMethodName(invocation);<br>    <span class="hljs-comment">// 设置path和version到attachment中</span><br>    inv.setAttachment(PATH_KEY, getUrl().getPath());<br>    inv.setAttachment(VERSION_KEY, version);<br><br>    ExchangeClient currentClient;<br>    <span class="hljs-keyword">if</span> (clients.length == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 获取ExchangeClient</span><br>        currentClient = clients[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        currentClient = clients[index.getAndIncrement() % clients.length];<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// isOneway为true，表示单向通信</span><br>        <span class="hljs-comment">// 也就是不关心你的请求是否发送成功</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isOneway</span> <span class="hljs-operator">=</span> RpcUtils.isOneway(getUrl(), invocation);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> calculateTimeout(invocation, methodName);<br>        <span class="hljs-keyword">if</span> (isOneway) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSent</span> <span class="hljs-operator">=</span> getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="hljs-literal">false</span>);<br>            currentClient.send(inv, isSent);<br>            <span class="hljs-keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getCallbackExecutor(getUrl(), inv);<br>            <span class="hljs-comment">// 向服务端发送请求，调取接口</span><br>            CompletableFuture&lt;AppResponse&gt; appResponseFuture =<br>                currentClient.request(inv, timeout, executor).thenApply(obj -&gt; (AppResponse) obj);<br>            <span class="hljs-comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span><br>            <span class="hljs-comment">// 放到上下文中，这样用户就可以从上下文中拿到这个future</span><br>            FutureContext.getContext().setCompatibleFuture(appResponseFuture);<br>            <span class="hljs-type">AsyncRpcResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncRpcResult</span>(appResponseFuture, inv);<br>            result.setExecutor(executor);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcException.TIMEOUT_EXCEPTION, <span class="hljs-string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, provider: &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcException.NETWORK_EXCEPTION, <span class="hljs-string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="hljs-string">&quot;, provider: &quot;</span> + getUrl() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-发送请求"><a href="#6-2-发送请求" class="headerlink" title="6.2 发送请求"></a>6.2 发送请求</h2><p>在Dubbo.doInvoke方法中，调用了currentClient.request方法，该方法是来自<strong>ReferenceCountExchangeClient</strong>，我们接着分析：</p><h3 id="ReferenceCountExchangeClient"><a href="#ReferenceCountExchangeClient" class="headerlink" title="ReferenceCountExchangeClient"></a>ReferenceCountExchangeClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountExchangeClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExchangeClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URL url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">referenceCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> ExchangeClient client;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReferenceCountExchangeClient</span><span class="hljs-params">(ExchangeClient client)</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = client;<br>        referenceCount.incrementAndGet();<br>        <span class="hljs-built_in">this</span>.url = client.getUrl();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">request</span><span class="hljs-params">(Object request)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-keyword">return</span> client.request(request);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">request</span><span class="hljs-params">(Object request, <span class="hljs-type">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-keyword">return</span> client.request(request, timeout);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">request</span><span class="hljs-params">(Object request, ExecutorService executor)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-keyword">return</span> client.request(request, executor);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">request</span><span class="hljs-params">(Object request, <span class="hljs-type">int</span> timeout, ExecutorService executor)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-keyword">return</span> client.request(request, timeout, executor);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout)</span> &#123;<br>        <span class="hljs-comment">// 自减</span><br>        <span class="hljs-keyword">if</span> (referenceCount.decrementAndGet() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) &#123;<br>                client.close();<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                client.close(timeout);<br>            &#125;<br><br>            replaceWithLazyClient();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类的内部定义了一个引用计数变量referenceCount，每当该对象被引用一次就会自增一次；每次close方法被调用就会自减一次。</p><p>其余的话也没做啥事情。</p><p>接下来来到了<strong>HeaderExchangeClient</strong>，它内部封装了一些关于心跳检测的逻辑，但是并非本次关注的重点，因此继续往下调用：</p><h3 id="HeaderExchangeChannel-request"><a href="#HeaderExchangeChannel-request" class="headerlink" title="HeaderExchangeChannel#request"></a>HeaderExchangeChannel#request</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Object&gt; <span class="hljs-title function_">request</span><span class="hljs-params">(Object request, <span class="hljs-type">int</span> timeout, ExecutorService executor)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>    <span class="hljs-keyword">if</span> (closed) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-built_in">this</span>.getLocalAddress(), <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Failed to send request &quot;</span> + request + <span class="hljs-string">&quot;, cause: The channel &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; is closed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// create request.</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>();<br>    req.setVersion(Version.getProtocolVersion());<br>    req.setTwoWay(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置双向通信标志</span><br>    req.setData(request); <span class="hljs-comment">// request为RpcInvocation</span><br>    <span class="hljs-type">DefaultFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> DefaultFuture.newFuture(channel, req, timeout, executor); <span class="hljs-comment">// 创建DefaultFutrue</span><br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// channel是该类得到属性，由构造器赋值得到</span><br>        <span class="hljs-comment">// 即为NettyClient</span><br>        channel.send(req);<br>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;<br>        future.cancel();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-comment">// 返回对象</span><br>    <span class="hljs-keyword">return</span> future;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法创建了一个Request对象，然后将该对象设置了一些属性后就交给NettyClient去调用send方法。而NettyClient其实并未实现该方法，而是继承自父类AbstractPeer。</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPeer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Endpoint</span>, ChannelHandler &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Object message)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        send(message, url.getParameter(Constants.SENT_KEY, <span class="hljs-literal">false</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// public abstract class AbstractEndpoint extends AbstractPeer implements Resetable &#123;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractEndpoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Object message, <span class="hljs-type">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-keyword">if</span> (needReconnect &amp;&amp; !isConnected()) &#123;<br>            connect();<br>        &#125; <span class="hljs-comment">// 得到的NettyChannel，由NettyClient得到</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> getChannel();<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span> || !channel.isConnected()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;message can not send, because channel is closed . url:&quot;</span> + getUrl());<br>        &#125; <span class="hljs-comment">// 继续往下调用</span><br>        channel.send(message, sent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NettyChannel-send"><a href="#NettyChannel-send" class="headerlink" title="NettyChannel#send"></a>NettyChannel#send</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Object message, <span class="hljs-type">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>    <span class="hljs-comment">// whether the channel is closed</span><br>    <span class="hljs-built_in">super</span>.send(message, sent);<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 发送消息</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> channel.writeAndFlush(message);<br>        <span class="hljs-comment">// send的值来自&lt;dubbo:method sent = &quot;true/false&quot;/&gt;中</span><br>        <span class="hljs-comment">// true：等待消息发出，消息发送失败则抛出异常</span><br>        <span class="hljs-comment">// false：不等待消息发出，将消息放入IO队列，即刻返回</span><br>        <span class="hljs-keyword">if</span> (sent) &#123;<br>            <span class="hljs-comment">// wait timeout ms</span><br>            timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);<br>            <span class="hljs-comment">// 等待消息发出，如果没能在规定时间内发出</span><br>            <span class="hljs-comment">// 则被置为false</span><br>            success = future.await(timeout);<br>        &#125;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> cause;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        removeChannelIfDisconnected(channel);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;Failed to send message &quot;</span> + PayloadDropper.getRequestWithoutData(message) + <span class="hljs-string">&quot; to &quot;</span> + getRemoteAddress() + <span class="hljs-string">&quot;, cause: &quot;</span> + e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;Failed to send message &quot;</span> + PayloadDropper.getRequestWithoutData(message) + <span class="hljs-string">&quot; to &quot;</span> + getRemoteAddress()<br>                                    + <span class="hljs-string">&quot;in timeout(&quot;</span> + timeout + <span class="hljs-string">&quot;ms) limit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息终于要发出去了，整个调用链路如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fallback">proxy0#sayHello(String)<br>  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])<br>    —&gt; MockClusterInvoker#invoke(Invocation)<br>      —&gt; AbstractClusterInvoker#invoke(Invocation)<br>        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)<br>          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用<br>            —&gt; ListenerInvokerWrapper#invoke(Invocation) <br>              —&gt; AbstractInvoker#invoke(Invocation) <br>                —&gt; DubboInvoker#doInvoke(Invocation)<br>                  —&gt; ReferenceCountExchangeClient#request(Object, int)<br>                    —&gt; HeaderExchangeClient#request(Object, int)<br>                      —&gt; HeaderExchangeChannel#request(Object, int)<br>                        —&gt; AbstractPeer#send(Object)<br>                          —&gt; AbstractClient#send(Object, boolean)<br>                            —&gt; NettyChannel#send(Object, boolean)<br>                              —&gt; NioClientSocketChannel#write(Object)<br></code></pre></td></tr></table></figure><p>消息肯定就不能这么发送出去，在发送之前，还得将请求的数据进行编码操作，</p><p><img src="data-format.jpg" alt="img"></p><p>具体编码过程参考<strong>ExchangeCodec#encode</strong>，包括序列化等，而序列化的操作参考<strong>DubboCodec#encodeRequestData</strong></p><h2 id="6-3-接受请求"><a href="#6-3-接受请求" class="headerlink" title="6.3 接受请求"></a>6.3 接受请求</h2><p>同样是参考<strong>ExchangeCodec#decode</strong>，将客户端发来的数据进行解码，包括检查魔数等等，解码之后，将解码得到的字段封装到Request中，随后还会调用<strong>DecodeableRpcInvocation的decode</strong>方法进行后续的解码工作，也就是将方法名、attachement、调用参数等解析出来，并存放在DecodeableRpcInvocation中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p><p>而后将DecodeableRpcInvocation对象设置到Request的data属性中，得到了一个Request对象。</p><p>解码器将数据包解析成Request对象之后，NettyServerHandler会将消息发送出去，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">NettyChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> NettyChannel.getOrAddChannel(ctx.channel(), url, handler);<br>    handler.received(channel, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终整个调用链如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fallback">NettyServerHandler#channelRead(ChannelHandlerContext, MessageEvent)<br>  —&gt; AbstractPeer#received(Channel, Object)<br>    —&gt; MultiMessageHandler#received(Channel, Object)<br>      —&gt; HeartbeatHandler#received(Channel, Object)<br>        —&gt; AllChannelHandler#received(Channel, Object)<br>          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑<br></code></pre></td></tr></table></figure><p>后续的流程不再分析</p><h1 id="第七章-服务降级"><a href="#第七章-服务降级" class="headerlink" title="第七章 服务降级"></a>第七章 服务降级</h1><h1 id="第八章-路由"><a href="#第八章-路由" class="headerlink" title="第八章 路由"></a>第八章 路由</h1><h1 id="第九章-负载均衡"><a href="#第九章-负载均衡" class="headerlink" title="第九章 负载均衡"></a>第九章 负载均衡</h1><h1 id="第十章-集群容错"><a href="#第十章-集群容错" class="headerlink" title="第十章 集群容错"></a>第十章 集群容错</h1><ul><li>Failover Cluster失败自动切换：dubbo的默认容错方案，当调用失败时自动切换到其他可用的节点，具 体的重试次数和间隔时间可通过引用服务的时候配置，默认重试次数为1也就是只调用一次。</li><li>Failback Cluster失败自动恢复：在调用失败，记录日志和调用信息，然后返回空结果给consumer，并 且通过定时任务每隔5秒对失败的调用进行重试 </li><li>Failfast Cluster快速失败：只会调用一次，失败后立刻抛出异常 </li><li>Failsafe Cluster失败安全：调用出现异常，记录日志不抛出，返回空结果</li><li>Forking Cluster并行调用多个服务提供者：通过线程池创建多个线程，并发调用多个provider，结果保 存到阻塞队列，只要有一个provider成功返回了结果，就会立刻返回结果</li><li>Broadcast Cluster广播模式：逐个调用每个provider，如果其中一台报错，在循环调用结束后，抛出异<br>常。</li></ul><h1 id="终章-常见面试题"><a href="#终章-常见面试题" class="headerlink" title="终章 常见面试题"></a>终章 常见面试题</h1><blockquote><p>Dubbo和SpringCloud的区别</p></blockquote><ol><li>Dubbo的传输是二进制的，占用宽带更少；而后者是HTTP传输，占用宽带更多，而且传输格式是JSON，消耗更大</li><li>前者是后者的一个子集，前者解决的是分布式中的服务之间的调用问题，而后者是提供了全套的解决方案。</li></ol><blockquote><p>Dubbo3.0</p></blockquote><ul><li>拥抱云原生，多语言，java-go社区互通，部分治理能力交给service mesh去搞，进行打通。</li><li>定制新的tri协议</li><li>服务发现从接口粒度改为服务粒度</li></ul>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat源码分析</title>
    <link href="/Tomcat/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Tomcat/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>搭建tomcat的源码环境，首先得去官网下载tomcat的源码包，我们这里使用的是tomcat9.0.44，然后将解压好的源码包添加一个pom文件，让其变成一个maven项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat9<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>tomcat-9.0.44<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.44<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>tomcat-9.0.44<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;  test 下的有些文件报错，因此将test文件夹去掉了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/biz.aQute.bnd/annotation --&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/biz.aQute.bnd/biz.aQute.bndlib --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>biz.aQute.bnd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>biz.aQute.bndlib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.jasper/org.apache.jasper --&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-jasper --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.41<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant-apache-log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant-commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.rpc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.xml.rpc-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于我们以前启动tomcat来说，都是执行startup命令，但是这次我们以源码分析，可以查看startup命令，然后它其实执行的是catalina.bat命令，它里面规定了<code>MAINCLASS=org.apache.catalina.startup.Bootstrap</code>。</p><p>因此我们重点就可以开始分析源码中的Bootstrap类了。</p><p>我们先将项目启动起来，先配置一个Application：</p><p><img src="image-20220421204107522.png" alt="image-20220421204107522"></p><p>然后给这个Application配置一个主类，就是我们上面说的Bootstrap类，同时可能项目启动的时候会报错，这时候就可以去根据提示修改源码，把VERSON_15等给修改成VERSON_8。然后为了解决乱码问题，可以添加一些VM。</p><p><img src="image-20220421204554002.png" alt="image-20220421204554002"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Duser.language</span>=<span class="hljs-string">en</span><br><span class="hljs-attr">-Duser.region</span>=<span class="hljs-string">US</span><br><span class="hljs-attr">-Dfile.encoding</span>=<span class="hljs-string">UTF-8</span><br><span class="hljs-attr">-Dsun.jnu.encoding</span>=<span class="hljs-string">UTF-8</span><br></code></pre></td></tr></table></figure><p>如果一个请求<a href="http://localhost:8080/noaharno/hello%EF%BC%8C%E9%A6%96%E5%85%88%E6%A0%B9%E6%8D%AElocalhost%E8%A7%A3%E6%9E%90%E5%88%B0%E6%88%91%E4%BB%AC%E6%9C%AC%E6%9C%BA%E5%9F%9F%E5%90%8D%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E6%9C%AC%E6%9C%BA%E5%90%AF%E5%8A%A8%E4%BA%86%E4%B8%80%E4%B8%AAtomcat%EF%BC%8C%E5%AE%83%E7%9B%91%E5%90%AC%E4%BA%868080%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%B0%B1%E4%BC%9A%E4%BA%A4%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84server%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E7%BB%99Catalina">http://localhost:8080/noaharno/hello，首先根据localhost解析到我们本机域名，而我们本机启动了一个tomcat，它监听了8080端口，因此这个请求就会交给我们的server服务器，服务器交给Catalina</a> Service进行处理，然后它里面的Connector接受到了请求，然后交给引擎进行处理，然后此时我们的请求是localhost，然后引擎就会交给localhost所在的host，然后从webapps进行寻找。</p>]]></content>
    
    
    <categories>
      
      <category>Tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCache源码分析</title>
    <link href="/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-搭建测试环境"><a href="#第一章-搭建测试环境" class="headerlink" title="第一章 搭建测试环境"></a>第一章 搭建测试环境</h1><ul><li>引入相关依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>配置属性文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.235</span><span class="hljs-number">.123</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">time-to-live:</span> <span class="hljs-string">30000s</span><br></code></pre></td></tr></table></figure><ul><li>添加@EnableCaching注解</li><li>解决SpringRedis自带的RedisTemplate序列化问题：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisCacheConfiguration <span class="hljs-title function_">redisCacheConfiguration</span><span class="hljs-params">(CacheProperties cacheProperties)</span> &#123;<br>        CacheProperties.<span class="hljs-type">Redis</span> <span class="hljs-variable">redisProperties</span> <span class="hljs-operator">=</span> cacheProperties.getRedis();<br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration<br>                .defaultCacheConfig();<br>        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>()));<br>        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>()));<br><br>        <span class="hljs-keyword">if</span> (redisProperties.getTimeToLive() != <span class="hljs-literal">null</span>) &#123;<br>            config = config.entryTtl(redisProperties.getTimeToLive());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (redisProperties.getKeyPrefix() != <span class="hljs-literal">null</span>) &#123;<br>            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;<br>            config = config.disableCachingNullValues();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;<br>            config = config.disableKeyPrefix();<br>        &#125;<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编写测试样例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> orderService.getOrderById(id);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">// 最终结果是第一次访问的时候访问数据库，之后就直接访问redis</span><br>    <span class="hljs-meta">@Cacheable(value = &#123;&quot;study:cache:order&quot;&#125;,key = &quot;#id&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderById</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(id, <span class="hljs-string">&quot;订单&quot;</span>, <span class="hljs-number">20</span>);<br>        log.info(<span class="hljs-string">&quot;from db &#123;&#125; ========&quot;</span>, order);<br>        <span class="hljs-keyword">return</span> order;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-SpringCache源码分析"><a href="#第二章-SpringCache源码分析" class="headerlink" title="第二章 SpringCache源码分析"></a>第二章 SpringCache源码分析</h1><h2 id="2-1-EnableCaching"><a href="#2-1-EnableCaching" class="headerlink" title="2.1 @EnableCaching"></a>2.1 @EnableCaching</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(CachingConfigurationSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableCaching &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>    AdviceMode <span class="hljs-title function_">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY;<br><span class="hljs-comment">// int LOWEST_PRECEDENCE = Integer.MAX_VALUE;</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Ordered.LOWEST_PRECEDENCE;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中最重要的就是通过Import注解引入了<strong>CachingConfigurationSelector</strong>，这个类通过<strong>ConfigurationClassParser</strong>类执行它的selectImports方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;<br>    <span class="hljs-keyword">switch</span> (adviceMode) &#123;<br>        <span class="hljs-keyword">case</span> PROXY:<br>            <span class="hljs-keyword">return</span> getProxyImports();<br>        <span class="hljs-keyword">case</span> ASPECTJ:<br>            <span class="hljs-keyword">return</span> getAspectJImports();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the imports to use if the &#123;<span class="hljs-doctag">@link</span> AdviceMode&#125; is set to &#123;<span class="hljs-doctag">@link</span> AdviceMode#PROXY&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;Take care of adding the necessary JSR-107 import if it is available.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String[] getProxyImports() &#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>    result.add(AutoProxyRegistrar.class.getName());<br>    result.add(ProxyCachingConfiguration.class.getName());<br>    <span class="hljs-keyword">if</span> (jsr107Present &amp;&amp; jcacheImplPresent) &#123;<br>        result.add(PROXY_JCACHE_CONFIGURATION_CLASS);<br>    &#125;<br>    <span class="hljs-keyword">return</span> StringUtils.toStringArray(result);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h3><p>由于我们默认采用PROXY，因此它会向容器中引入两个类：<strong>AutoProxyRegistrar和ProxyCachingConfiguration</strong>，对于第一个类，其实在Spring的事务源码中也同样会引入该类，它是一个ImportBeanDefinitionRegistrar，在它的内部的registerBeanDefinitions方法中，会获取到@EnableCaching注解中的属性，然后通过这些属性判断是否注入一些BeanDefinition，比如<strong>InfrastructureAdvisorAutoProxyCreator</strong>。</p><p>AutoProxyRegistrar在容器刷新过程中的invokeBeanFactoryPostProcessors步骤中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">candidateFound</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 注意这里可能会拿到多个注解，</span><br>    Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();<br>    <span class="hljs-keyword">for</span> (String annType : annTypes) &#123;<br>        <span class="hljs-comment">// 如果项目中引入了事务，在Spring事务注解中，同样也会通过@EnableTransactionalManager注解</span><br>        <span class="hljs-comment">// 来执行这一步骤，但是对于InfrastructureAdvisorAutoProxyCreator的beanDefinition只能有一个</span><br>        <span class="hljs-comment">// 因此两个注解之间，他们的属性只会有一个生效，这就是在@EnableCaching注解中的proxyTargetClass（）</span><br>        <span class="hljs-comment">// 它的官方注释上写着：</span><br>        <span class="hljs-comment">// Note that setting this attribute to &#123;@code true&#125; will affect &lt;em&gt;all&lt;/em&gt;</span><br>       <span class="hljs-comment">// Spring-managed beans requiring proxying, not just those marked with &#123;@code @Cacheable&#125;.</span><br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);<br>        <span class="hljs-keyword">if</span> (candidate == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> candidate.get(<span class="hljs-string">&quot;mode&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxyTargetClass</span> <span class="hljs-operator">=</span> candidate.get(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>);<br>        <span class="hljs-keyword">if</span> (mode != <span class="hljs-literal">null</span> &amp;&amp; proxyTargetClass != <span class="hljs-literal">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;<br>            Boolean.class == proxyTargetClass.getClass()) &#123;<br>            candidateFound = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (mode == AdviceMode.PROXY) &#123;<br>                <span class="hljs-comment">// 内部注入InfrastructureAdvisorAutoProxyCreator</span><br>                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);<br>                <span class="hljs-keyword">if</span> ((Boolean) proxyTargetClass) &#123;<br>                    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">///////// 。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ProxyCachingConfiguration"><a href="#ProxyCachingConfiguration" class="headerlink" title="ProxyCachingConfiguration"></a>ProxyCachingConfiguration</h3><p>看完了AutoProxyRegistrar，接下来看CachingConfigurationSelector引入的另一个类：<strong>ProxyCachingConfiguration</strong></p><p>它主要向容器中注入三个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyCachingConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCachingConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="hljs-title function_">cacheAdvisor</span><span class="hljs-params">(</span><br><span class="hljs-params">        CacheOperationSource cacheOperationSource, CacheInterceptor cacheInterceptor)</span> &#123;<br><br>        <span class="hljs-type">BeanFactoryCacheOperationSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryCacheOperationSourceAdvisor</span>();<br>        advisor.setCacheOperationSource(cacheOperationSource);<br>        advisor.setAdvice(cacheInterceptor);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableCaching != <span class="hljs-literal">null</span>) &#123;<br>            advisor.setOrder(<span class="hljs-built_in">this</span>.enableCaching.&lt;Integer&gt;getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> advisor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> CacheOperationSource <span class="hljs-title function_">cacheOperationSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationCacheOperationSource</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> CacheInterceptor <span class="hljs-title function_">cacheInterceptor</span><span class="hljs-params">(CacheOperationSource cacheOperationSource)</span> &#123;<br>        <span class="hljs-type">CacheInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>();<br>        interceptor.configure(<span class="hljs-built_in">this</span>.errorHandler, <span class="hljs-built_in">this</span>.keyGenerator, <span class="hljs-built_in">this</span>.cacheResolver, <span class="hljs-built_in">this</span>.cacheManager);<br>        interceptor.setCacheOperationSource(cacheOperationSource);<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其实可以发现，SpringCache和SpringTransactional非常相似，甚至它们引入的类实现的都是同一种接口。</p><p><img src="image-20220930211346234.png" alt="image-20220930211346234"></p><p>其中最重要的类肯定就是BeanFactoryCacheOperationSourceAdvisor，它是一个Advisor，而我们容器中已经存在了一个AopProxyCreator，也就是InfrastructureAdvisorAutoProxyCreator。这样AOP功能其实就可以实现了。</p><h1 id="第三章-Caffeine源码分析"><a href="#第三章-Caffeine源码分析" class="headerlink" title="第三章 Caffeine源码分析"></a>第三章 Caffeine源码分析</h1><h1 id="第四章-两者的结合"><a href="#第四章-两者的结合" class="headerlink" title="第四章 两者的结合"></a>第四章 两者的结合</h1>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC源码分析</title>
    <link href="/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-什么是SPI"><a href="#第一章-什么是SPI" class="headerlink" title="第一章 什么是SPI"></a>第一章 什么是SPI</h2><p>SPI全称：Service Provider Interfact，是一种服务扩展机制，首先在配置文件中定义好接口的实现类，然后根据这个接口从配置文件中加载该接口的所有实现类，以供使用。</p><p>使用场景：</p><ul><li>JDBC驱动加载：根据不同的数据库厂商加载不同的JDBC驱动包。</li><li>SpringBoot的SPI机制：在META-INF下的spring.factories中加上自定义的自动配置，事件监听或初始化器等。</li><li>Dubbo的SPI机制：路由扩展、负载均衡扩展、集群扩展等。</li></ul><p><strong>为什么不用new呢？</strong></p><p>这和我们java的设计相关，系统设计的各种抽象，往往有多种不同的实现方案，而我们一般各模块之间基于接口编程，不对实现类进行硬编码。比如如果我们解析一串数据有两种方式，word和excel，如果一开始使用word来解析，发现不实用，想要替换成excel。如果使用的是new的方式，就得去修改源代码，而使用我们的SPI机制，就可以不用动用源代码，只需修改配置文件。</p><p>有点类似于IOC的思想，将装配的控制权转移到程序之外，在模块化设计中这个机制尤为重要，所以SPI的核心思想就是解耦。</p><p><strong>缺点</strong></p><ul><li>使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果不想用某些实现类，但是它也会被加载并实例化，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过iterator形式获取。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><p><strong>代码示例：</strong></p><p><img src="image-20220423182525691-16507245180971.png" alt="image-20220423182525691"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataServiceInterface</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataServiceInterface</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am Service1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataServiceInterface</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am Service2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在META-INF.services中的top.noaharno.spi.DataServiceInterfact文件中配置如下内容：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span>.noaharno.spi.MyService1<br><span class="hljs-built_in">top</span>.noaharno.spi.MyService2<br></code></pre></td></tr></table></figure><p>然后进行测试，发现两个MyService中的say方法都被调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ServiceLoader&lt;DataServiceInterface&gt; loader = ServiceLoader.load(DataServiceInterface.class);<br><br>    loader.forEach(DataServiceInterface::say);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-MVC的启动原理"><a href="#第二章-MVC的启动原理" class="headerlink" title="第二章 MVC的启动原理"></a>第二章 MVC的启动原理</h2><h3 id="2-1-Servlet3-0规范"><a href="#2-1-Servlet3-0规范" class="headerlink" title="2.1 Servlet3.0规范"></a>2.1 Servlet3.0规范</h3><p>首先根据官网的关于SpringMVC注解版的注册并初始化DispatcherServlet，它由Servlet容器自动检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebApplicationInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebApplicationInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br><br>        <span class="hljs-comment">// Load Spring web application configuration 创建IOC容器</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        context.register(AppConfig.class); <span class="hljs-comment">// 传入一个配置类</span><br><span class="hljs-comment">// 以上，IOC容器都没有启动</span><br>        <span class="hljs-comment">// Create and register the DispatcherServlet 配置了DispatcherServlet，利用Servlet的初始化机制</span><br>        <span class="hljs-type">DispatcherServlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispatcherServlet</span>(context);<br>        ServletRegistration.<span class="hljs-type">Dynamic</span> <span class="hljs-variable">registration</span> <span class="hljs-operator">=</span> servletContext.addServlet(<span class="hljs-string">&quot;app&quot;</span>, servlet);<br>        registration.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        registration.addMapping(<span class="hljs-string">&quot;/&quot;</span>); <span class="hljs-comment">// 映射路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要写了这个，就相当于配置了SpringMVC的DispatcherServlet。Tomcat一旦启动，就会加载它，然后就会按照代码流程创建容器、指定配置类，至此所有IOC、AOP等spring的功能就准备好了。然后它会注册一个Servlet，也就是DispatcherServlet，以后所有的请求都会交给这个Servlet。</p><p>注意的是必须Servlet3.0以上才可以，Tomcat是Servlet3.0规范的一个实现。</p><p><strong>那么为什么我们配置好了tomcat，然后配置好上述的代码之后，整个Spring应用就能启动了呢？</strong></p><p>首先在Tomcat的源码中，它使用了SPI机制并遵循Servlet3.0规范，在启动的时候会去加载<code>javax.servlet.ServletContainerInitializer</code>接口的实现类，而我们的SpringMVC就实现了这个接口：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p><p><img src="image-20220423193202343-16507245230712.png" alt="image-20220423193202343"></p><p>然后其实就是根据这个类，让我们上述的<strong>MyWebApplicationInitializer中的onStartup</strong>去进行执行的。让我们具体看这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HandlesTypes(WebApplicationInitializer.class)</span> <span class="hljs-comment">// 说明我们只对实现了WebApplicationInitializer接口的类感兴趣</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContainerInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br>        <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>        List&lt;WebApplicationInitializer&gt; initializers = Collections.emptyList();<br><br>        <span class="hljs-keyword">if</span> (webAppInitializerClasses != <span class="hljs-literal">null</span>) &#123;<br>            initializers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(webAppInitializerClasses.size());<br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<br>                <span class="hljs-comment">// Be defensive: Some servlet containers provide us with invalid classes,</span><br>                <span class="hljs-comment">// no matter what @HandlesTypes says... 所有的非接口非抽象的WebApplicationInitializer实现类</span><br>                <span class="hljs-keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;<br>                    WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        initializers.add((WebApplicationInitializer) <span class="hljs-comment">//集合负责保存满足上面条件的类</span><br>                                         ReflectionUtils.accessibleConstructor(waiClass).newInstance());<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Failed to instantiate WebApplicationInitializer class&quot;</span>, ex);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (initializers.isEmpty()) &#123;<br>            servletContext.log(<span class="hljs-string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//下面会遍历所有满足要求的WebApplicationInitializer，调用他们的onStartup</span><br>        servletContext.log(initializers.size() + <span class="hljs-string">&quot; Spring WebApplicationInitializers detected on classpath&quot;</span>);<br>        AnnotationAwareOrderComparator.sort(initializers);<br>        <span class="hljs-keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;<br>            initializer.onStartup(servletContext); <span class="hljs-comment">//所有的 WebApplicationInitializer 的 onStartup</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码总结来说：</p><ol><li>找到所有的WebApplicationInitializer接口的子类或其衍生类</li><li>过滤掉所有的接口和抽象类</li><li>排好序之后挨个执行他们自己实现的onStartup方法。</li></ol><h3 id="2-2-onStartup方法的执行"><a href="#2-2-onStartup方法的执行" class="headerlink" title="2.2 onStartup方法的执行"></a>2.2 onStartup方法的执行</h3><p>至此，我们配置好的启动类中的onStartup方法就可以被执行了，接下来我们细看onStartup方法干了些什么？</p><p>首先我们新建一个IOC容器，然后给这个容器传入我们的配置类，接着new一个DispatcherServlet，然后将我们的容器传进去，最后将DispatcherServlet给放进ServletContext中。</p><p><strong>可是我们并没有看到IOC容器的刷新步骤啊？</strong>这就得说一说DispatcherServet的组成了：</p><p><img src="image-20220423205416098.png" alt="image-20220423205416098.png"></p><p><strong>重点可以看到，DispatcherServlet其实是一个Servelt</strong></p><p><img src="image-20220423205454310-16507245268483.png" alt="image-20220423205454310"></p><p>在Servelt的规范中：</p><ol><li>Servelt创建对象</li><li>Servlet调用init初始化</li><li>每次请求过来就会调用service进行处理</li><li>tomcat停止应用的时候就会调用destroy进行销毁。</li></ol><p>于是我们来看一下DispatcherServlet的init方法中的实现细节，进行分析：</p><p>首先在<strong>HttpServletBean</strong>（实现了Servlet）中，它对init方法进行了实现，在经过一系列的工作后，它调用了一个方法：**initServletBean()**，而且它其实并没有对他进行实现，是一个空方法，这就是模板模式的体现，给子类留的方法，让子类自行去实现。</p><p>然后我们的<strong>FrameworkServlet</strong>就继承了<strong>HttpServletBean</strong>，它实现了initServletBean方法，在这个方法里面，重点就是下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.webApplicationContext = initWebApplicationContext(); <span class="hljs-comment">//初始化WebIOC容器</span><br></code></pre></td></tr></table></figure><p>也就是说，在这一行代码中，就完成了我们web版本的IOC容器的初始化流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span><br>        WebApplicationContextUtils.getWebApplicationContext(getServletContext()); <span class="hljs-comment">//父容器</span><br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//先会获取之前的 WebApplicationContext（构建父子容器）</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webApplicationContext != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// A context instance was injected at construction time -&gt; use it</span><br>        wac = <span class="hljs-built_in">this</span>.webApplicationContext; <span class="hljs-comment">//当前的web-ioc容器</span><br>        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;<br>            <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">cwac</span> <span class="hljs-operator">=</span> (ConfigurableWebApplicationContext) wac;<br>            <span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;<br>                <span class="hljs-comment">// The context has not yet been refreshed -&gt; provide services such as</span><br>                <span class="hljs-comment">// setting the parent context, setting the application context id, etc</span><br>                <span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// The context instance was injected without an explicit parent -&gt; set</span><br>                    <span class="hljs-comment">// the root application context (if any; may be null) as the parent</span><br>                    cwac.setParent(rootContext); <span class="hljs-comment">//父子容器的体现，</span><br>                &#125;<br>                configureAndRefreshWebApplicationContext(cwac); <span class="hljs-comment">//配置并且刷新容器</span><br>            &#125;<br>        &#125;<br>    &#125;<br>......<br>        <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.refreshEventReceived) &#123;<br>        <span class="hljs-comment">// Either the context is not a ConfigurableApplicationContext with refresh</span><br>        <span class="hljs-comment">// support or the context injected at construction time had already been</span><br>        <span class="hljs-comment">// refreshed -&gt; trigger initial onRefresh manually here.</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.onRefreshMonitor) &#123;<br>            onRefresh(wac);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.publishContext) &#123;<br>        <span class="hljs-comment">// Publish the context as a servlet context attribute.</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> getServletContextAttributeName();<br>        getServletContext().setAttribute(attrName, wac);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="SpringMVC%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86.png" alt="SpringMVC应用启动原理"></p><h3 id="2-3-父子容器"><a href="#2-3-父子容器" class="headerlink" title="2.3 父子容器"></a>2.3 父子容器</h3><p>我们以上述的代码启动我们的mvc项目，其中父容器为null。</p><p>而在我们以前的xml版本中：</p><ol><li>在web.xml中配置ContextLoaderListener，指定Spring配置文件的位置</li><li>在web.xml中配置DispatcherServlet，指定SpringMVC配置文件位置。</li><li>以上就会产生父子容器，其中父容器就是Spring配置文件进行包扫描并保存所有组件的容器；子容器就是SpringMVC配置文件进行包扫描并保存所有组件的容器。</li><li>使用webloc.setParent(springIoc)。</li><li>如果查找一个组件，先从子容器查找，找不到的话再去父容器查找，做到<strong>容器隔离</strong></li></ol><p><img src="mvc-context-hierarchy.png" alt="mvc context hierarchy"></p><p>在Spring官方文档中，有以下描述：</p><ol><li><strong>应用中可以包含多个IOC容器。</strong></li><li><strong>DispatcherServlet的创建的子容器主要包含Controller、view resolvers等和web相关的一些bean。</strong></li><li><strong>父容器root WebApplicationContex主要包含包含一些基础的bean，比如一些需要在多个servlet共享的dao、service等bean。</strong></li><li><strong>如果在子容器中找不到bean的时候可以去父容器查找bean。</strong></li></ol><p><strong>作用：</strong>一般而言，我们一个应用只需要一个DispatcherServlet，然后每个DispatcherServlet一般都会关联一个ApplicationContext。如果我们是商城业务，不同的模块如商品、订单、购物车等使用了不同的DispatcherServlet来处理请求，这就意味着一个应用里面有多个ApplicationContext，由于每个容器之间都是独立的，因此订单模块就无法直接使用商品模块和购物车模块中容器的服务来下单。虽然也可以将商品和购物车模块中的服务注册进我们的订单模块中，就可以解决这个问题，但是这样会导致多个容器中保存了多个相同类型的bean。于是就可以使用我们的父子容器，将这些公共的服务注册进相同的父容器中，这样每个子容器就都能使用到父容器中的公共bean。</p><p>在Spring官方文档中，使用非xml版方式指定父子容器代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最快速的整合注解版SpringMVC和Spring的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickAppStarter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//根容器的配置（Spring的配置文件===Spring的配置类）</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;SpringConfig.class&#125;; <span class="hljs-comment">// 父容器</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//web容器的配置（SpringMVC的配置文件===SpringMVC的配置类）</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;SpringMVCConfig.class&#125;; <span class="hljs-comment">// 子容器</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//Servlet的映射，DispatcherServlet的映射路径</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizeRegistration</span><span class="hljs-params">(ServletRegistration.Dynamic registration)</span> &#123;<br>        <span class="hljs-comment">//super.customizeRegistration(registration);</span><br>        <span class="hljs-comment">//registration.addMapping(&quot;&quot;);//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意重写customizeRegistration就可以对DispatcherServlet进行额外的配置，比如调用setLoadOnStartup来设置加载时的优先级，调用setInitParameter来初始化参数，调用setMultipartConfig来设置Servlet3.0的多路支持。</p><p>然后我们的SpringMVCConfig和SpringConfig如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;top.noaharno.web&quot;,includeFilters = &#123;</span><br><span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ANNOTATION,value = Controller.class)</span><br><span class="hljs-meta">&#125;,useDefaultFilters = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMVCConfig</span> &#123;<br>    <span class="hljs-comment">//子容器，扫描所有标注了@Controller的组件</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;top.noaharno.web&quot;,excludeFilters = &#123;</span><br><span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ANNOTATION,value = Controller.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>    <span class="hljs-comment">//Spring的父容器，扫描除了@Controller标注之外的所有组件。</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们看<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>的继承树：</p><p><img src="image-20220424151534147.png" alt="image-20220424151534147"></p><p>同样的，它也是实现了WebApplicationInitializer接口，因此在tomcat启动的时候，也会去调用它或者它的父类重写了的onStartup方法。由于AbstractAnnotationConfigDispatcherServletInitializer并没有去实现onStartup方法，而是它的父类AbstartDispatcherServletInitializer实现了该方法，因此会调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-built_in">super</span>.onStartup(servletContext); <span class="hljs-comment">// 调用父类的startUp方法进行各种初始化</span><br>    registerDispatcherServlet(servletContext); <span class="hljs-comment">// 注册DispatcherServlet</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们来看onStartup方法，它调用的是AbstractContextLoaderInitializer类中的onStartup方法，里面只有一条实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-comment">//注册ContextLoaderListener；contextInitialized</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    registerContextLoaderListener(servletContext);<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这个名字就很熟悉了，就是我们在xml版的springmvc整合中配置的父容器，用来存放@Service之类的组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerContextLoaderListener</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootAppContext</span> <span class="hljs-operator">=</span> createRootApplicationContext(); <span class="hljs-comment">//创建一个根容器</span><br>    <span class="hljs-keyword">if</span> (rootAppContext != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ContextLoaderListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextLoaderListener</span>(rootAppContext);<br>        listener.setContextInitializers(getRootApplicationContextInitializers());<br>        servletContext.addListener(listener);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;No ContextLoaderListener registered, as &quot;</span> +<br>                     <span class="hljs-string">&quot;createRootApplicationContext() did not return an application context&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会去创建一个根容器，然后将这个rootAppContext给放在一个ContextLoaderListener中，然后将其注册到ServletContext中。这个监听器的作用后续再说。</p><p>那么是怎么去创建我们的根容器的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span> <span class="hljs-comment">//重写了爷爷类的创建根容器方法</span><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    Class&lt;?&gt;[] configClasses = getRootConfigClasses(); <span class="hljs-comment">//获取根配置</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;<br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        context.register(configClasses); <span class="hljs-comment">//创建了一个IOC容器并把配置类注册进来</span><br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>getRootConfigClasses方法是AbstractAnnotationConfigDispatcherServletInitializer留给子类的模板方法，然后我们的QuickAppStarter就实现了它， 也就是new Class&lt;?&gt;[]{SpringConfig.class};</li><li>创建一个IOC容器，并且将我们第一步重写方法所返回的配置类给注册进去</li><li>此时就完成了父容器的创建，但是还未初始化。</li></ol><p>然后继续回到AbstartDispatcherServletInitializer类重写的onStartup方法，它调用了**registerDispatcherServlet(servletContext)**，该方法帮助我们注册了DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDispatcherServlet</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">servletName</span> <span class="hljs-operator">=</span> getServletName(); <span class="hljs-comment">// 获取默认的名字，dispatcher</span><br>    Assert.hasLength(servletName, <span class="hljs-string">&quot;getServletName() must not return null or empty&quot;</span>);<br><br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">servletAppContext</span> <span class="hljs-operator">=</span> createServletApplicationContext(); <span class="hljs-comment">//创建Servlet容器</span><br>    Assert.notNull(servletAppContext, <span class="hljs-string">&quot;createServletApplicationContext() must not return null&quot;</span>);<br><span class="hljs-comment">// 在这里创建我们的DispatcherServlet，并将上一步创建好的Servlet容器放进去，也就是我们的子容器</span><br>    <span class="hljs-type">FrameworkServlet</span> <span class="hljs-variable">dispatcherServlet</span> <span class="hljs-operator">=</span> createDispatcherServlet(servletAppContext);<br>    Assert.notNull(dispatcherServlet, <span class="hljs-string">&quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;</span>);<br>    dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());<br>    <span class="hljs-comment">// 接下来的步骤和我们使用注解版的SpringMVC大差不差。</span><br>    ServletRegistration.<span class="hljs-type">Dynamic</span> <span class="hljs-variable">registration</span> <span class="hljs-operator">=</span> servletContext.addServlet(servletName, dispatcherServlet);<br>    <span class="hljs-keyword">if</span> (registration == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Failed to register servlet with name &#x27;&quot;</span> + servletName + <span class="hljs-string">&quot;&#x27;. &quot;</span> +<br>                                        <span class="hljs-string">&quot;Check if there is another servlet registered under the same name.&quot;</span>);<br>    &#125;<br><br>    registration.setLoadOnStartup(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置加载优先级</span><br>    registration.addMapping(getServletMappings()); <span class="hljs-comment">//根据我们指定的DispatcherServlet的路径进行注册</span><br>    registration.setAsyncSupported(isAsyncSupported());<br><br>    Filter[] filters = getServletFilters();<br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(filters)) &#123;<br>        <span class="hljs-keyword">for</span> (Filter filter : filters) &#123;<br>            registerServletFilter(servletContext, filter);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 同样是模板方法，留给我们在子类去实现这个，对DispatcherServlet进行额外的配置。</span><br>    customizeRegistration(registration);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取默认的名字</li><li>创建我们的子容器</li><li>创建DispatcherServlet，里面流程待会细说</li><li>注册registerServletFilter</li><li>模板方法customizeRegistration的执行。</li></ol><p>首先我们来看我们的子容器的具体创建步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>    Class&lt;?&gt;[] configClasses = getServletConfigClasses(); <span class="hljs-comment">//获取web应用的配置</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;<br>        context.register(configClasses);<br>    &#125;<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><p>和根容器的创建流程一致，创建好我们的IOC容器之后，然后执行子类重写的getServletConfigClasses获取配置类的Class数组，然后将其注册进我们的容器中。</p><p>⭐此时我们的两个容器都已经创建好了，然后当我们的web应用启动完成的时候，Tomcat出发监听器钩子启动根容器，这个时候就会去调用我们<strong>ContextLoaderListener的contextInitialized方法</strong>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInitialized</span><span class="hljs-params">(ServletContextEvent event)</span> &#123; <span class="hljs-comment">//根容器初始化</span><br>    initWebApplicationContext(event.getServletContext()); <span class="hljs-comment">//初始化webioc容器,也就是我们的父容器</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在**initWebApplicationContext()**方法中：</p><ol><li>调用<strong>configureAndRefreshWebApplicationContext(cwac, servletContext);方法去初始化IOC容器，也就是我们的十二步刷新</strong></li><li>调用**servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);**，将容器放到Servlet域中。</li></ol><p>⭐<strong>在Tomcat启动之后，tomcat会调用DispatcherServlet的初始化方法，</strong>这个流程就是我们之前分析SpringMVC注解版的时候的具体流程了，也就是<strong>设置父子容器，配置并刷新web容器</strong></p><p>至此，整个父子容器的形成过程源码部分分析完毕！两个容器已经准备和初始化完毕，并且形成了父子容器。</p><p><img src="SpringMVC%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8.png" alt="SpringMVC中的父子容器"></p><h2 id="第三章-请求处理流程"><a href="#第三章-请求处理流程" class="headerlink" title="第三章 请求处理流程"></a>第三章 请求处理流程</h2><h3 id="3-1-DispatcherServlet中的九大组件"><a href="#3-1-DispatcherServlet中的九大组件" class="headerlink" title="3.1 DispatcherServlet中的九大组件"></a>3.1 DispatcherServlet中的九大组件</h3><p>当Tomcat启动之后，会调用DispatcherServlet的init方法，在这个方法里面，它会去配置父子容器，并且去刷新子容器。然后就是常规的十二步，不过在十二大步中的最后一步：<strong>finishRefresh中，它会去发布事件</strong></p><p>它首先会调用**publishEvent(new ContextRefreshedEvent(this))**，发布上下文环境刷新完成的时间，在这个方法里面：</p><ol><li>先将事件封装成PayloadApplicationEvent</li><li>拿到多播器发送事件即可</li><li>在发送过程中，利用观察者模式（for遍历），将符合event和type的所有ApplicationListener事件监听器拿来，然后挨个去执行他们的<strong>onApplicationEvent</strong>方法。</li><li>我们处理DispatcherServlet的初始化完成事件，用到的是<strong>SourceFIlteringListener</strong></li></ol><p>在我们的SourceFIlteringListener的onApplicationEvent方法中，调用的是onApplicationEventInternal方法，最终重重调用，核心方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 来自FrameworkServlet类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>    <span class="hljs-built_in">this</span>.refreshEventReceived = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.onRefreshMonitor) &#123;<br>        onRefresh(event.getApplicationContext()); <span class="hljs-comment">// 留给子类的模板方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，它会调用DispatcherServlet的onRefresh方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">initStrategies(context); <span class="hljs-comment">//初始化九大组件</span><br></code></pre></td></tr></table></figure><p>正是这个方法，初始化了DispatcherServlet的九大组件。</p><p>总结来说：【九大组件何时初始化？】：<strong>Tomcat启动，触发DispatcherServlet的初始化，当初始化全部结束的时候，容器会发送Spring的事件，然后SourceFilteringListener感知到了事件之后，将事件回调到DispatcherServlet的onRefresh方法，然后就去执行初始化九大组件的相关逻辑。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> &#123; <span class="hljs-comment">//初始化所有策略，九大组件在这里进行了初始化</span><br>    initMultipartResolver(context); <span class="hljs-comment">//容器中有就用，没有就是null</span><br>    initLocaleResolver(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initThemeResolver(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initHandlerMappings(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initHandlerAdapters(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initHandlerExceptionResolvers(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initRequestToViewNameTranslator(context); <span class="hljs-comment">//Spring没有浓重说他，//从容器中获取，没有用默认</span><br>    initViewResolvers(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>    initFlashMapManager(context); <span class="hljs-comment">//从容器中获取，没有用默认</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这九大组件的初始化流程其实都差不多，除了<strong>MultipartResolver是容器中有就用，没有就是null（需要我们自己导入相关包并进行配置），其余的八个都是从容器中获取，没有就用默认值</strong>。我们以MultipartResolver和LocaleResolver为例子进行讲解：</p><p><strong>MultipartResolver：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMultipartResolver</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 从容器中尝试去获得beanName为multipartResolver，类型为MultipartResolver的组件</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        首先查找自己，发现自己没有multipartResolver，然后去父容器去查找，也就是我们的根容器</span><br><span class="hljs-comment">        查过过程中发现没有beanName为multipartResolver的beanDefinition</span><br><span class="hljs-comment">        抛出NoSuchBeanDefinitionException</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-built_in">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Detected &quot;</span> + <span class="hljs-built_in">this</span>.multipartResolver);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Detected &quot;</span> + <span class="hljs-built_in">this</span>.multipartResolver.getClass().getSimpleName());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>        <span class="hljs-comment">// 捕获到异常，设置multipartResolver为null</span><br>        <span class="hljs-comment">// Default is no multipart resolver.</span><br>        <span class="hljs-built_in">this</span>.multipartResolver = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No MultipartResolver &#x27;&quot;</span> + MULTIPART_RESOLVER_BEAN_NAME + <span class="hljs-string">&quot;&#x27; declared&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LocaleResolver：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initLocaleResolver</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//容器中先来获取</span><br>        <span class="hljs-built_in">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Detected &quot;</span> + <span class="hljs-built_in">this</span>.localeResolver);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Detected &quot;</span> + <span class="hljs-built_in">this</span>.localeResolver.getClass().getSimpleName());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>        <span class="hljs-comment">// We need to use the default. 容器中没有，读取默认配置文件进行加载</span><br>        <span class="hljs-built_in">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class); <span class="hljs-comment">//获取默认策略</span><br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No LocaleResolver &#x27;&quot;</span> + LOCALE_RESOLVER_BEAN_NAME +<br>                         <span class="hljs-string">&quot;&#x27;: using default [&quot;</span> + <span class="hljs-built_in">this</span>.localeResolver.getClass().getSimpleName() + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程也是先去容器中获取，如果找不到就会抛出异常。该方法捕获到异常之后，就去读取默认配置文件进行加载，它会去DispatcherServlet所在的类路径下去找一个<strong>DispatcherServlet.properties</strong>资源，里面定义了我们其余八大组件的初始化组件。</p><p><img src="image-20220424201042209.png" alt="image-20220424201042209"></p><p>最终我们的所有的组件，然后挨个去执行createBean方法，将他们创建在容器中。</p><p><strong>如果实现了InitializingBean接口，还会在初始化完成之后，执行他们的afterPropertiesSet方法。</strong></p><p>⭐<strong>RequestMappingHandlerAdapter实现了InitializingBean接口，因此我们在初始化对象完毕之后调用方法afterPropertiesSet()：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//初始化以后</span><br>    <span class="hljs-comment">// Do this first, it may add ResponseBody advice beans</span><br>    initControllerAdviceCache();  <span class="hljs-comment">//初始化 ControllerAdvice 【异常处理相关的功能】</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//拿到底层所有的 argumentResolvers 参数解析器</span><br>        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();<br>        <span class="hljs-built_in">this</span>.argumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers); <br>        <span class="hljs-comment">//把这些resolver统一组合到一个对象里面，方便管控</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.initBinderArgumentResolvers == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// </span><br>        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();<br>        <span class="hljs-built_in">this</span>.initBinderArgumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 拿到所有的返回值处理器，并保存起来。</span><br>        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();<br>        <span class="hljs-built_in">this</span>.returnValueHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>它会先初始化了ControllerAdvice相关功能，然后准备所有的参数解析器和返回值处理器并放到各自的组合对象中保存起来。</strong></p><p><img src="Dispatcher%E4%B9%9D%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="Dispatcher九大组件初始化流程"></p><h3 id="3-2-SpringMVC运行流程"><a href="#3-2-SpringMVC运行流程" class="headerlink" title="3.2 SpringMVC运行流程"></a>3.2 SpringMVC运行流程</h3><p>我们明白了DispatcherServlet的九大组件之后，接下来开始解析浏览器发送一个请求，MVC是怎么处理它的？也就是SpringMVC的运行流程。</p><p>我们首先知道，所有的请求都会交给我们的DispatcherServlet，然后执行它的<strong>doDispatch</strong>方法，这是SpringMVC处理请求的核心功能。</p><p>当然，MVC是如何调用doDispatch方法的呢？首先根据Servlet规范，Servlet在执行的时候会去执行service方法，然后我们的FrameworkServlet重写了这个方法，它会执行<code>super.service(request, response)</code>，进而执行HttpServlet重写的service方法，在该方法中，它会去判断当前请求的类型，比如GET、POST、PUT、DELETE等等，然后根据该请求的类型去执行相应的方法，这里我们执行的是get请求，因此会去执行doGet方法，我们的FrameworkServlet又重写了这个Servlet，最终层层调用之后，来到了<strong>DispatcheServlet.doService()方法上</strong>。</p><p>在该方法中：</p><ol><li>首先判断该request是否是includeRequest，即判断该request是否包含属性javax.servlet.include.request_uri。如果包含，就会将request域中指定的属性给提前保存，也就是快照指定属性【暂不具体分析】</li><li>然后它会将基本的属性保存到request域中，方便处理，比如我们的<strong>web容器、国际化解析器、主题解析器</strong>等等。</li><li>如果我们的flashMapManager（闪存管理器，重定向携带数据）不为空，就给request设置一些属性。</li><li><strong>重点执行doDispatch方法，处理派发功能</strong></li></ol><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1. 总览"></a>1. 总览</h4><p>先说一说该方法的大致流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// handler（目标方法）的执行链</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 文件上传标志</span><br>    <span class="hljs-comment">//对异步请求的支持（Servlet3.0以后才有的，Webflux）</span><br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            processedRequest = checkMultipart(request); <span class="hljs-comment">//检查当前是否文件上传请求</span><br>            multipartRequestParsed = (processedRequest != request); <span class="hljs-comment">// 该标志位方法末尾有用</span><br><br>            <span class="hljs-comment">// 构造出了【目标方法+拦截器整个链路】决定使用哪个Handler处理当前请求 </span><br>            <span class="hljs-comment">// Determine handler for the current request.</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果找不到人处理，就send 404</span><br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//适配器怎么找的、 Determine handler adapter for the current request.</span><br>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//所有拦截器的 preHandle 执行</span><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">//使用 mappedHandler整个链</span><br>            &#125;<br><br>            <span class="hljs-comment">//真正来执行目标方法 Actually invoke the handler.（反射执行目标方法、确定参数值，处理返回值【封装成ModelAndView】）</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><span class="hljs-comment">// 如果mv中的view为null，就给它默认的视图名字</span><br>            applyDefaultViewName(processedRequest, mv);<br>            mappedHandler.applyPostHandle(processedRequest, response, mv); <span class="hljs-comment">//所有拦截器的postHandle</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            <span class="hljs-comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span><br>            <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span><br>            dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, err);<br>        &#125; <span class="hljs-comment">//处理结果</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;  <span class="hljs-comment">//下面的即使执行完，异常还是抛出去</span><br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span><br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span><br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123; <span class="hljs-comment">// 如果是文件处理请求，就进行此操作</span><br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大致流程：</strong></p><ol><li>检查当前请求是否是文件上传请求【使用multipartResolver.isMultipart来判断是否是文件上传请求】</li><li>调用**getHandler(processedRequest)**构造出【目标方法+拦截器】的整个链路，在内部还会决定用哪个Handler处理当前请求</li><li>如果构造不出链路，即找不到Handler处理该请求，就<strong>sendError 404</strong></li><li>然后找到哪个<strong>HandlerAdapter</strong>适配器能解析这个请求</li><li>执行所有的拦截器的<strong>preHandle</strong></li><li>调用<strong>ha.handle</strong>真正来执行目标方法【反射执行目标方法、确定参数值、处理返回值【封装成ModelAndView】</li><li>如果没有指定跳转的页面，就给一个默认的页面：<strong>applyDefaultViewName</strong></li><li>执行所有拦截器的<strong>postHandle</strong></li><li><strong>processDispatchResult</strong>处理结果，将我的MV转换成真正的View对象进行渲染</li><li>进行完渲染之后，执行所有拦截器的<strong>afterCompletion</strong>方法</li><li>最后如果是文件上传请求，就<strong>cleanupMultipart(processedRequest);</strong></li></ol><p><img src="doDispatch%E6%80%BB%E8%A7%88.png" alt="doDispatch总览"></p><h4 id="2-构造HandlerExecutionChain"><a href="#2-构造HandlerExecutionChain" class="headerlink" title="2. 构造HandlerExecutionChain"></a>2. 构造HandlerExecutionChain</h4><p>我们会调用<strong>getHandler</strong>方法来构造目标方法+拦截器的整个链路，接下来来看具体流程：</p><p>1、<strong>首先拿到容器中所有的HandlerMapping，然后挨个判断哪个HandlerMapping能处理当前请求，这里我们是使用的RequestMappingHandlerMapping。</strong></p><p><img src="image-20220425200852799.png" alt="image-20220425200852799"></p><p>2、<strong>利用HandlerMapping的registry去寻找映射，返回HandlerMethod，这是真正执行当前请求的方法</strong></p><p><img src="image-20220425200919056.png" alt="image-20220425200919056"></p><p>3、<strong>将系统中所有的拦截器都拿来，然后和HandlerMethod一起封装成HandlerExecutionChain，并返回出去。</strong></p><p><strong>那么RequestMappingHandlerMapping中的registry是从哪里来的呢？</strong></p><p>和我们3.1章节说的一样，RequestMappingHandlerMapping在初始化的时候执行了afterPropertiesSet方法，而在这里面就进行了registry的设置，他会找到所有标注了@Controller注解的组件，然后探索组件内所有标注了@RequestMapping注解的方法，最后将其进行封装并添加进mappingRegistry的registry中。</p><p><img src="MVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-%E6%9E%84%E9%80%A0%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%93%BE%E8%B7%AF.png" alt="MVC运行流程-构造目标方法和拦截器的执行链路"></p><h4 id="3-获取HandlerAdapter"><a href="#3-获取HandlerAdapter" class="headerlink" title="3. 获取HandlerAdapter"></a>3. 获取HandlerAdapter</h4><p>拿到所有的HandlerAdapter，然后挨个遍历，看当前HandlerAdapter是否支持当前的HandlerMapping。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title function_">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerAdapters != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//拿到默认的所有适配器</span><br>        <span class="hljs-keyword">for</span> (HandlerAdapter adapter : <span class="hljs-built_in">this</span>.handlerAdapters) &#123;<br>            <span class="hljs-keyword">if</span> (adapter.supports(handler)) &#123;<br>                <span class="hljs-keyword">return</span> adapter;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;No adapter for handler [&quot;</span> + handler +<br>                               <span class="hljs-string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-利用反射真正执行目标方法"><a href="#4-利用反射真正执行目标方法" class="headerlink" title="4. 利用反射真正执行目标方法"></a>4. 利用反射真正执行目标方法</h4><p>使用上述流程获得的HandlerAdapter去真正执行目标方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                           HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//把原生的request，response封装到一个对象中方便后续只用这一个参数就行【装饰器模式】</span><br>    <span class="hljs-type">ServletWebRequest</span> <span class="hljs-variable">webRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response);<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//数据绑定器，比如我们在注册的时候，需要将用户密码封装成一个Person类，</span><br>        <span class="hljs-comment">//比如：  请求数据到自定义Object属性的映射需要用到</span><br>        <span class="hljs-type">WebDataBinderFactory</span> <span class="hljs-variable">binderFactory</span> <span class="hljs-operator">=</span> getDataBinderFactory(handlerMethod);<br>        <span class="hljs-comment">//获取到模型工厂 Model（要交给页面的数据） View（我们要去的 视图）</span><br>        <span class="hljs-type">ModelFactory</span> <span class="hljs-variable">modelFactory</span> <span class="hljs-operator">=</span> getModelFactory(handlerMethod, binderFactory);<br>        <span class="hljs-comment">// 封装handlerMethod，并进行了增强【装饰器模式】，提供handlerMethod里面信息的快速获取</span><br>        <span class="hljs-type">ServletInvocableHandlerMethod</span> <span class="hljs-variable">invocableMethod</span> <span class="hljs-operator">=</span> createInvocableHandlerMethod(handlerMethod);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//【重要】参数解析器：未来用来反射解析目标方法中每一个参数的值</span><br>            invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-built_in">this</span>.argumentResolvers);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//【重要】返回值解析器：未来用来处理目标方法执行后的返回值，无论目标方法返回什么得想办法变成适配器能用的ModelAndView</span><br>            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-built_in">this</span>.returnValueHandlers);<br>        &#125;<br>        invocableMethod.setDataBinderFactory(binderFactory);<br>        invocableMethod.setParameterNameDiscoverer(<span class="hljs-built_in">this</span>.parameterNameDiscoverer);<br>        <span class="hljs-comment">//以上的 几个核心组件都挺重要的  ModelAndViewContainer以后流程共享ModelAndView数据的临时存储容器</span><br>        <span class="hljs-type">ModelAndViewContainer</span> <span class="hljs-variable">mavContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewContainer</span>();<br>        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));<br>        modelFactory.initModel(webRequest, mavContainer, invocableMethod);<br>        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-built_in">this</span>.ignoreDefaultModelOnRedirect);<br>        <span class="hljs-comment">//异步请求有关的</span><br>        <span class="hljs-type">AsyncWebRequest</span> <span class="hljs-variable">asyncWebRequest</span> <span class="hljs-operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);<br>        asyncWebRequest.setTimeout(<span class="hljs-built_in">this</span>.asyncRequestTimeout);<br><br>        <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br>        asyncManager.setTaskExecutor(<span class="hljs-built_in">this</span>.taskExecutor);<br>        asyncManager.setAsyncWebRequest(asyncWebRequest);<br>        asyncManager.registerCallableInterceptors(<span class="hljs-built_in">this</span>.callableInterceptors);<br>        asyncManager.registerDeferredResultInterceptors(<span class="hljs-built_in">this</span>.deferredResultInterceptors);<br><br>        <span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> asyncManager.getConcurrentResult();<br>            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];<br>            asyncManager.clearConcurrentResult();<br>            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> LogFormatUtils.formatValue(result, !traceOn);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Resume with async result [&quot;</span> + formatted + <span class="hljs-string">&quot;]&quot;</span>;<br>            &#125;);<br>            invocableMethod = invocableMethod.wrapConcurrentResult(result);<br>        &#125;<br>        <span class="hljs-comment">//真正开始执行目标方法</span><br>        invocableMethod.invokeAndHandle(webRequest, mavContainer);<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        webRequest.requestCompleted();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="%E5%8F%8D%E5%B0%84%E5%A4%84%E7%90%86%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95.png" alt="反射处理目标方法"></p><h4 id="5-处理ModelAndView"><a href="#5-处理ModelAndView" class="headerlink" title="5. 处理ModelAndView"></a>5. 处理ModelAndView</h4><p>首先如果有异常，就会去处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">errorView</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//如果有异常处理异常，以下if内全是异常处理环节</span><br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;<br>            logger.debug(<span class="hljs-string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);<br>            mv = ((ModelAndViewDefiningException) exception).getModelAndView();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//定义无数种异常解析器就会得到不同的异常解析效果</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (mappedHandler != <span class="hljs-literal">null</span> ? mappedHandler.getHandler() : <span class="hljs-literal">null</span>);<br>            mv = processHandlerException(request, response, handler, exception); <span class="hljs-comment">//处理异常，所有的异常解析器都不能干活，这个异常就抛出去了</span><br>            errorView = (mv != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//上面所有的异常解析器都没能处理这个异常，下面直接炸....</span><br>    <span class="hljs-comment">// 动态策略。 Did the handler return a view to render?   为啥？@ResponseBody（提前在解析返回值的时候，就已经把数据写出去了，所以这一步就没有了）</span><br>    <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>        render(mv, request, response); <span class="hljs-comment">//渲染ModeAndView，来解析模型和视图；最终决定响应效果</span><br>        <span class="hljs-keyword">if</span> (errorView) &#123;<br>            WebUtils.clearErrorRequestAttributes(request);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用render方法渲染视图</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Determine locale for request and apply it to the response.</span><br>    <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span><br>        (<span class="hljs-built_in">this</span>.localeResolver != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.localeResolver.resolveLocale(request) : request.getLocale());<br>    response.setLocale(locale);<br>    <span class="hljs-comment">//默认AcceptHeaderLocaleResolver会根据请求头中的Accept-Language字段决定浏览器能接受哪种中文/英文 页面</span><br>    View view; <span class="hljs-comment">//视图</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> mv.getViewName(); <span class="hljs-comment">//适配器执行完目标方法以后返回的ModelAndView对象里面有  index.jsp</span><br>    <span class="hljs-comment">// 但是此时只是知道了视图名称，还不是真正能用的View对象，这时候就需要下面的方法将其转为真正能够使用的View对象</span><br>    <span class="hljs-keyword">if</span> (viewName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//************ 把目标方法的返回值字符串index.jsp 真正转为能用的View对象； We need to resolve the view name.</span><br>        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);<br>        ......<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="MVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-%E6%B8%B2%E6%9F%93ModelAndView.png" alt="MVC运行流程-渲染ModelAndView"></p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p><img src="MVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="MVC运行流程"></p><h2 id="第四章-EnableMvc注解原理【存疑，待做】"><a href="#第四章-EnableMvc注解原理【存疑，待做】" class="headerlink" title="第四章 @EnableMvc注解原理【存疑，待做】"></a>第四章 @EnableMvc注解原理【存疑，待做】</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot源码分析</title>
    <link href="/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-SpringBootApplication"><a href="#第一章-SpringBootApplication" class="headerlink" title="第一章 @SpringBootApplication"></a>第一章 @SpringBootApplication</h2><p>首先，为什么我们在使用SpringBoot的时候，只需要**@SpringBootApplication + SpringApplication.run，然后导入各种 spring-boot-starter-xxx**，就能将Spring + SpringMVC + Tomcat + 其他场景给整合进来，然后SpringBoot里面就会有很多的组件了呢？这个注解到底做了什么事情呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">                                 @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure><p>上述代码的@SpringBootConfiguration其实就是一个@Configuration，然后就是一个@ComponentScan会导入SpringbootSourceApplication启动类所在的目录及其所有子目录中的组件。</p><p><strong>1、接下来分析@EnableAutoConfiguration注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure><p>上述代码中的**@AutoConfigurationPackage<strong>核心就是</strong>@Import(AutoConfigurationPackages.Registrar.class)<strong>，给我们导入了组件</strong>AutoConfigurationPackages.Registrar.class<strong>，然后它本身还会导入一个</strong>AutoConfigurationImportSelector**组件。</p><p><strong>2、接下来分析@Import(AutoConfigurationPackages.Registrar.class)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>        register(registry, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]));<br>    &#125;<br>    <span class="hljs-comment">// 上述register方法的第二个参数其实就是我们的主启动类所在的包的包名。</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title function_">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(BeanDefinitionRegistry registry, String... packageNames)</span> &#123;<br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;<br>        <span class="hljs-type">BasePackagesBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> (BasePackagesBeanDefinition) registry.getBeanDefinition(BEAN);<br>        beanDefinition.addBasePackages(packageNames); <br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// // 将主程序的根目录添加到BeanDefinition中</span><br>        registry.registerBeanDefinition(BEAN, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasePackagesBeanDefinition</span>(packageNames));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们根据**@AutoConfigurationPackage<strong>注解导入的Registrar类其实就是将我们的</strong>主程序的根目录<strong>添加到BeanDefinition中，从而指定后续</strong>@ComponentScan注解要扫描的包位置**</p><p><strong>⭐即@ComponentScan注解具体扫描的包的根路径由SpringBoot项目主程序类所在的包位置决定，在扫描过程中，由@AutoConfigurationPackage注解进行解析，从而得到SpringBoot项目主程序启动类所在包的具体位置。</strong></p><p><strong>3、接下来分析@Import(AutoConfigurationImportSelector.class)注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">rotected AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125;<br>    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);<br>    <span class="hljs-comment">// 利用SPI机制，去类路径下找META-INF/spring.factories文件中的EnableAutoConfiguration对应的所有候选自动配置类</span><br>    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>    <span class="hljs-comment">// 去除重复的候选配置类</span><br>    configurations = removeDuplicates(configurations);<br>    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>    checkExcludedClasses(configurations, exclusions);<br>    configurations.removeAll(exclusions);<br>    <span class="hljs-comment">// 根据导入的依赖，最终筛选符合当前项目运行环境的对应的自动配置类</span><br>    configurations = getConfigurationClassFilter().filter(configurations);<br>    fireAutoConfigurationImportEvents(configurations, exclusions);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="@SpringBootApplication%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90.png" alt="@SpringBootApplication注解解析"></p><h2 id="第二章-Tomcat和MVC组件的准备过程"><a href="#第二章-Tomcat和MVC组件的准备过程" class="headerlink" title="第二章 Tomcat和MVC组件的准备过程"></a>第二章 Tomcat和MVC组件的准备过程</h2><ol><li>SpringBoot.run会创建一个IOC容器：<strong>AnnotationConfigServletWebServerApplicationContext</strong></li><li>IOC容器启动，onRefresh会启动Tomcat</li><li>Tomcat启动会加载所有的Servlet</li><li>DispatcherServlet初始化，会加载九大组件的整个初始化流程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码分析</title>
    <link href="/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>导入spring源码需要gradle，但是问题就是gradle导入源码太慢了，因此也可以退而求其次，选择用maven来搭建，只不过用maven的话，无法修改源码，无法在源码上写注释，但是其实问题不大。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-r2dbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-oxm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-messaging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jcl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-instrument<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-indexer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>optional<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-framework-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="第一章-核心注解"><a href="#第一章-核心注解" class="headerlink" title="第一章 核心注解"></a>第一章 核心注解</h2><table><thead><tr><th align="left"><strong>注解</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td align="left">@Bean</td><td>容器中注册组件</td></tr><tr><td align="left">@Primary</td><td>同类组件如果有多个，标注主组件</td></tr><tr><td align="left">@DependsOn</td><td>组件之间声明依赖关系</td></tr><tr><td align="left">@Lazy</td><td>组件懒加载（最后使用的时候才创建）</td></tr><tr><td align="left">@Scope</td><td>声明组件的作用范围(SCOPE_PROTOTYPE,SCOPE_SINGLETON)</td></tr><tr><td align="left">@Configuration</td><td>声明这是一个配置类，替换以前配置文件</td></tr><tr><td align="left">@Component</td><td>@Controller、@Service、@Repository</td></tr><tr><td align="left">@Indexed</td><td>加速注解，所有标注了  @Indexed 的组件，直接会启动快速加载</td></tr><tr><td align="left">@Order</td><td>数字越小优先级越高，越先工作</td></tr><tr><td align="left">@ComponentScan</td><td>包扫描</td></tr><tr><td align="left">@Conditional</td><td>条件注入</td></tr><tr><td align="left">@Import</td><td>导入第三方jar包中的组件，或定制批量导入组件逻辑</td></tr><tr><td align="left">@ImportResource</td><td>导入以前的xml配置文件，让其生效</td></tr><tr><td align="left">@Profile</td><td>基于多环境激活</td></tr><tr><td align="left">@PropertySource</td><td>外部properties配置文件和JavaBean进行绑定.结合ConfigurationProperties</td></tr><tr><td align="left">@PropertySources</td><td>@PropertySource组合注解</td></tr><tr><td align="left">@Autowired</td><td>自动装配</td></tr><tr><td align="left">@Qualifier</td><td>精确指定</td></tr><tr><td align="left">@Value</td><td>取值、计算机环境变量、JVM系统。xxxx。@Value(“${xx}”)</td></tr><tr><td align="left">@Lookup</td><td>单例组件依赖非单例组件，非单例组件获取需要使用方法</td></tr></tbody></table><p>注：**@Indexed需要引入依赖**</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-indexer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-1-使用xml文件创建bean"><a href="#1-1-使用xml文件创建bean" class="headerlink" title="1.1 使用xml文件创建bean"></a>1.1 使用xml文件创建bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>    &lt;bean class=<span class="hljs-string">&quot;top.noaharno.bean.Person&quot;</span> id=<span class="hljs-string">&quot;person&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;张三&quot;</span>/&gt;<br>    &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(Person.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-使用注解的方式创建bean"><a href="#1-2-使用注解的方式创建bean" class="headerlink" title="1.2 使用注解的方式创建bean"></a>1.2 使用注解的方式创建bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfig</span> &#123;<br><br>    <span class="hljs-comment">// 通过注解的方式导入bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">person</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        person.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(Person.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Import注解"><a href="#1-3-Import注解" class="headerlink" title="1.3 @Import注解"></a>1.3 @Import注解</h3><p>除了使用@Bean来导入bean，还可以在MainConfig类上使用@Import(Person.class)来导入bean，但是这种方式是利用无参构造器来创建bean到容器中的。</p><p>@Import的部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Configuration <span class="hljs-doctag">@Configuration</span>&#125;, &#123;<span class="hljs-doctag">@link</span> ImportSelector&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span><br><span class="hljs-comment"> */</span><br>Class&lt;?&gt;[] value();<br></code></pre></td></tr></table></figure><p>可以看到，它一共有四种方式导入，我们先关注ImportDefinitionRegistrar方式导入bean定义信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BeanDefinitionRegistry Bean定义信息注册中心，图纸中心，档案馆，它里面都是BeanDefinition</span><br><span class="hljs-comment">// 所有的bean定义信息都在这里面存着</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span><br><span class="hljs-params">                                        BeanDefinitionRegistry registry)</span> &#123;<br><br>        <span class="hljs-comment">// BeanDefinition</span><br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">catDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>();<br>        catDefinition.setBeanClass(Cat.class);<br>        <span class="hljs-comment">// 可以声明定义信息，包括我需要自动装配什么</span><br>        <span class="hljs-comment">// Spring 这个实例的类型、名字</span><br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;tomCat&quot;</span>, catDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的重点是了解一下BeanDefinitionRegistry，这是spring中非常重要的一个类。</p><p>可以使用<code>@Import(MyInportRegistrar.class)</code>的方式向容器中导入tomcat这个名字的bean</p><h3 id="1-4-Lookup注解"><a href="#1-4-Lookup注解" class="headerlink" title="1.4 @Lookup注解"></a>1.4 @Lookup注解</h3><p>如果我们让Person里面组合一个Cat类，然后让Cat的类型为<code>@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>，原型模式，这样如果通过注解方式的容器来获取Cat实例，就会得到不一样的Cat实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们同时创建两个Person，并且比较两个Person中的cat对象是否想的，得到的答案确是相等的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean1</span> <span class="hljs-operator">=</span> context.getBean(Person.class);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> context.getBean(Person.class);<br>    System.out.println(bean2.getCat() == bean1.getCat());<br>&#125;<br></code></pre></td></tr></table></figure><p>原因就是person是单实例的，在我们创建了第一个person的时候，给person赋值，就会根据原型模式创建出一个cat。导致获取到的cat就是第一次创建person对象的时候，容器初始化的cat。</p><p>要想每次创建person，都会创建一个新的cat，就需要注解@Lookup了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-comment">//    @Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-comment">// 去容器中找。不过注意的是@Bean的这种方式注册的Person，@Lookup不生效。</span><br>    <span class="hljs-meta">@Lookup</span>  <span class="hljs-comment">// 标注在get方法上面。</span><br>    <span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">getCat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cat;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章-Spring整体架构"><a href="#第二章-Spring整体架构" class="headerlink" title="第二章 Spring整体架构"></a>第二章 Spring整体架构</h2><h3 id="2-1-Spring整体流程"><a href="#2-1-Spring整体流程" class="headerlink" title="2.1 Spring整体流程"></a>2.1 Spring整体流程</h3><p><img src="image-20211222142442575.png" alt="image-20211222142442575"></p><p>Spring暴露给程序员的，通过XML、注解、网络、磁盘等方式，将功能定义出来，最终生成一个组件或者功能 的配置清单。<strong>比如我们在xml中写的bean配置都会在spring底层中对应一个BeanDefinition</strong>，然后通过ResourceLoader（资源加载器）帮我们把这些Resources加载来，并交给BeanDefinitionReader（Bean定义信息的读取器），然后放在spring中的档案馆里面（也就是BeanDefinitionRegistry），其实就是一个BeanDefinitionMap，保存组件是咋定义的。接着就是将这些BeanDefinition创建成对象（车间流水线的工作）。创建完之后就可以从容器中拿取了。在对象创建过程中，有很多池，所有创建好的实例分类放到池中。</p><h3 id="2-2-Resource-和-ResourceLoader"><a href="#2-2-Resource-和-ResourceLoader" class="headerlink" title="2.2 Resource 和 ResourceLoader"></a>2.2 Resource 和 ResourceLoader</h3><p>在spring中，resource可以有很多种，可以来自于xml、注解，也可以来自于磁盘、网络</p><p><img src="image-20211222145211353.png" alt="image-20211222145211353"></p><p>而ResourceLoader中，使用了策略模式，资源加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-comment">// 资源加载策略接口</span><br>    Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(String location)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-BeanFactory"><a href="#2-3-BeanFactory" class="headerlink" title="2.3 BeanFactory"></a>2.3 BeanFactory</h3><p>The root interface for accessing a Spring bean container。BeanFactory是根接口，整个访问容器的入口。这个接口可以保存很多的BeanDefinition信息，每一个信息都有一个唯一的名字。</p><p><img src="image-20211222150358883.png" alt="image-20211222150358883"></p><ul><li><strong>HierarchicalBeanFactory</strong>：定义工厂父子关系的工厂（父子容器）</li><li><strong>ListableBeanFactory</strong>：它的实现是DefaultListableBeanFactory，保存了ioc容器中的核心信息</li><li><strong>AutowireCapaableBeanFactory</strong>：提供自动装配能力</li></ul><p>AnnotationApplicationContext组合了档案馆，而档案馆有自动装配能力。</p><p>在ListableBeanFactory的实现类<code>AbstractApplicationContext</code>中，有一个<code>ResourcePatternResolver</code>，并且在<code>AbstractApplicationContext</code>对象创建的时候就拿到了，它是一个ResourceLoader。而AbstractApplicationContext就是<strong>策略模式环境类</strong>。</p><p>在<code>DefaultListableBeanFactory</code>中有一个属性，这里面所有BeanDefinition信息按照名字对应BeanDefinition关系都保存好了，这个就是<strong>总档案馆</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Map of bean definition objects, keyed by bean name. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-BeanDefinition信息的注册流程"><a href="#2-4-BeanDefinition信息的注册流程" class="headerlink" title="2.4 BeanDefinition信息的注册流程"></a>2.4 BeanDefinition信息的注册流程</h3><p>根据前置分析，我们的总档案馆就存放在DefaultListableBeanFactory中的beanDefinitionMap中，就可以通过查看啥时候调用了beanDefinitionMap的put方法，就知道了生成的BeanDefinition是什么时候被存放在总档案馆里面了。</p><p>因此就可以将断点打在DefaultListableBeanFactory中的registerBeanDefinition方法的首句上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;cat&quot;</span>, Cat.class);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top.noaharno.bean.Cat&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三的猫&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以Debugger方式运行测试类，然后分析整个执行堆栈。</p><p>首先我们通过<code>new ClassPathXmlApplicationContext</code>来创建IOC容器的时候，需要在构造器里面执行<strong>refresh</strong>方法刷新容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(</span><br><span class="hljs-params">      String[] configLocations, <span class="hljs-type">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>   <span class="hljs-built_in">super</span>(parent);<br>   setConfigLocations(configLocations);<br>   <span class="hljs-keyword">if</span> (refresh) &#123;<br>      refresh(); <span class="hljs-comment">// 刷新容器，即创建整个容器的过程，这是最重要的地方</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在refresh方法中，我们这次就分析下面的一句话，其余的后续再分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br><span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br></code></pre></td></tr></table></figure><p>也就是说，我们先告诉子类去刷新它们内部的beanFactory，并且将刷新好的beanFactory进行返回，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title function_">obtainFreshBeanFactory</span><span class="hljs-params">()</span> &#123;<br>   refreshBeanFactory(); <span class="hljs-comment">// 刷新工厂</span><br>   <span class="hljs-keyword">return</span> getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// 如果有beanFacory了就销毁它</span><br>    <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>        destroyBeans();<br>        closeBeanFactory();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在这里创建我们的BeanFactory，档案馆，也就是存放图纸的地方</span><br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> createBeanFactory();<br>        <span class="hljs-comment">// 给工厂一个序列化id</span><br>        beanFactory.setSerializationId(getId());<br>        customizeBeanFactory(beanFactory);<br>        <span class="hljs-comment">// 这里就是准备给创建好的beanFactory加载所有的BeanDefinitions</span><br>        loadBeanDefinitions(beanFactory);<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在如上的loadBeanDefinitions方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>    <span class="hljs-comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br>    <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">beanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(beanFactory);<br><br>    <span class="hljs-comment">// Configure the bean definition reader with this context&#x27;s</span><br>    <span class="hljs-comment">// resource loading environment.</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-built_in">this</span>.getEnvironment());<br>    <span class="hljs-comment">// 给读取器组合一个资源加载器</span><br>    beanDefinitionReader.setResourceLoader(<span class="hljs-built_in">this</span>);<br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEntityResolver</span>(<span class="hljs-built_in">this</span>));<br><br>    <span class="hljs-comment">// Allow a subclass to provide custom initialization of the reader,</span><br>    <span class="hljs-comment">// then proceed with actually loading the bean definitions.</span><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    <span class="hljs-comment">// 加载所有的Bean定义信息。</span><br>    loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们想要加载所有的BeanDefinition信息的时候，需要创建一个<strong>XMLBeanDefinitionReader</strong>，一个读取器，为的就是<strong>利用Dom解析把xml解析成Document。</strong></p><p>然后就继续调用<strong>loadBeanDefinitions</strong>方法，只不过这次是将我们准备好的beanDefinitionReader传进去了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return an array of Resource objects, referring to the XML bean definition</span><br><span class="hljs-comment"> * files that this context should be built with.</span><br><span class="hljs-comment"> * &lt;p&gt;The default implementation returns &#123;<span class="hljs-doctag">@code</span> null&#125;. Subclasses can override</span><br><span class="hljs-comment"> * this to provide pre-built Resource objects rather than location Strings.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> an array of Resource objects, or &#123;<span class="hljs-doctag">@code</span> null&#125; if none</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getConfigLocations()</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 默认返回为null。子类可以重写该方法</span><br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-literal">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    <span class="hljs-comment">// 允许多个配置文件</span><br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-literal">null</span>) &#123;<br>        reader.loadBeanDefinitions(configLocations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20211224140916647.png" alt="image-20211224140916647"></p><p>此时通过方法**reader.loadBeanDefinitions(configLocations)**，读取器终于要开始读取配置文件中的bean了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>   Assert.notNull(locations, <span class="hljs-string">&quot;Location array must not be null&quot;</span>);<br>   <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在这个方法里面，是对每一个配置文件都逐个进行加载</span><br>   <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>      count += loadBeanDefinitions(location);<br>   &#125;<br>   <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location, <span class="hljs-meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// 首先判断有没有资源加载器</span><br>    <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> getResourceLoader();<br>    <span class="hljs-keyword">if</span> (resourceLoader == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]: no ResourceLoader available&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-comment">// Resource pattern matching available.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 策略模式，获取资源</span><br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-comment">// 依次遍历所有的Resources，逐个进行加载。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resources);<br>            ............<br>&#125;<br></code></pre></td></tr></table></figure><p>以下方法就是解析单个Resource的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load bean definitions from the specified XML file.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> encodedResource the resource descriptor for the XML file,</span><br><span class="hljs-comment"> * allowing to specify an encoding to use for parsing the file</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of bean definitions found</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>.........<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream()) &#123;<br>        <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br>        <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-literal">null</span>) &#123;<br>            inputSource.setEncoding(encodedResource.getEncoding());<br>        &#125;<br>        <span class="hljs-comment">// 利用DOM解析配置文件中的Bean为BeanDefinition了</span><br>        <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>    &#125;<br>.........<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 这里的doc其实就是package org.w3c.dom; dom解析</span><br>        <span class="hljs-comment">// 利用dom解析工具把xml变成dom解析文档（Document）</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> registerBeanDefinitions(doc, resource);<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from &quot;</span> + resource);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    .........<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在前面，我们通过BeanDefinitionReader利用DOM解析把xml解析成Document</span><br><span class="hljs-comment">    而在这里，我们利用BeanDefinitionDocumentReader将Document里面的对象解析成BeanDefinition</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br>    <span class="hljs-comment">// 记录统计前BeanDefinition的加载个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment">// 利用BeanDefinitionDocumentReader将document解析成BeanDefinition</span><br>    <span class="hljs-comment">// 这里使用到了单一职责原理，将逻辑处理委托给的单一的类进行处理，这个逻辑处理类就是BeanDefinitionDocumentReader对象</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-comment">// 统计本次加载BeanDefinition的个数</span><br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是看registerBeanDefinitions中的doRegisterBeanDefinitions方法，该方法的核心就是以下语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanDefinitionParserDelegate</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate;<br><span class="hljs-built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br>......<br>parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>......<br></code></pre></td></tr></table></figure><p>也就是说，Spring准备一个BeanDefinitionParserDelegate，这里面其实利用了解释器模式，用于将Document对象解析成BeanDefinition。</p><p><img src="image-20211224144153374.png" alt="image-20211224144153374"></p><p><img src="image-20211224144220296.png" alt="image-20211224144220296"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            <span class="hljs-comment">// 遍历文档中的所有的节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    <span class="hljs-comment">// 解析节点</span><br>                    parseDefaultElement(ele, delegate);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析节点的方法如下，其实底层也就是通过if else来判断当前解析的节点是以什么开头的，然后分别调用不同的方法来解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        <span class="hljs-comment">// 由于我们的测试条件，是在配置文件中通过bean来创建对象，就调用这个解析方法</span><br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processBeanDefinition方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// 把当前标签解析完了，并将BeanDefinition和beanName给封装成bdHolder</span><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">bdHolder</span> <span class="hljs-operator">=</span> delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-literal">null</span>) &#123;<br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Register the final decorated instance.</span><br>            <span class="hljs-comment">// 利用工具类进行注册，</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            它里面的核心其实就是利用BeanDefinitionRegistry注册中心进行注册</span><br><span class="hljs-comment">            */</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>                                     bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>        &#125;<br>        <span class="hljs-comment">// Send registration event.</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(bdHolder));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看开头的<strong>BeanDefinitionHolder</strong>，这个类其实就是封装了BeanDefinition和beanName这两个属性。Holder还可以用于注册bean的别名信息。</p><p>而在最后的<strong>registerBeanDefinition</strong>方法中，也就是最终的将我们之前生成好的BeanDefinition注册进DefaultListableBeanFactory（总档案馆）中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <br>.........<br><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">existingDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.get(beanName);<br>    <span class="hljs-comment">// 首先判断我们该BeanDefinition是否已经被注册进去了。</span><br>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-literal">null</span>) &#123;<br>        .........<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<br>            <span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.beanDefinitionMap) &#123;<br>                <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>                List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 同时还会保存所有的BeanDefinition名字</span><br>                updatedDefinitions.addAll(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br>                updatedDefinitions.add(beanName);<br>                <span class="hljs-built_in">this</span>.beanDefinitionNames = updatedDefinitions;<br>                removeManualSingletonName(beanName);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Still in startup registration phase</span><br>            <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>            <span class="hljs-built_in">this</span>.beanDefinitionNames.add(beanName);<br>            removeManualSingletonName(beanName);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.frozenBeanDefinitionNames = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    .........<br>&#125;<br></code></pre></td></tr></table></figure><p>最后创建好的BeanDefinition如下图所示：</p><p><img src="image-20211224153114851.png" alt="image-20211224153114851"></p><p><strong>总结：</strong></p><p><img src="image-20211224150722256.png" alt="image-20211224150722256"></p><p>最后总结来说，其实就是以XML方式注册BeanDefinition信息的时候，首先得刷新容器，在刷新容器的过程中将档案馆DefaultListableBeanFactory给创建出来，然后遍历所有的配置文件，再遍历所有配置文件中的资源，逐个节点进行解析。最后利用BeanDefinitionParserDelegate将节点解析成相应的BeanDefinition之后，就将该BeanDefinition给注册进总档案管中。</p><h3 id="2-5-BeanDefinition创建过程"><a href="#2-5-BeanDefinition创建过程" class="headerlink" title="2.5 BeanDefinition创建过程"></a>2.5 BeanDefinition创建过程</h3><p>经过上一节疏通的BeanDefinition信息注册流程，我们已经明白了BeanDefinition是怎么注册的了。本小节我们详细追踪一下BeanDefinition的创建过程。</p><p>由上一节可知，spring利用<strong>BeanDefinitionParserDelegate</strong>来生成BeanDefinitionHolder：BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;<br>    <span class="hljs-comment">// 根据Element获取id和nameAttr</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ele.getAttribute(ID_ATTRIBUTE);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<br><br>    List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>        aliases.addAll(Arrays.asList(nameArr));<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> id; <span class="hljs-comment">// 这就是为什么xml中配置的bean的id就是它的名字的底层</span><br><br>    .........<br>        <br><span class="hljs-comment">// 这就是创建BeanDefinition的过程</span><br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);<br>    <br>    .........<br>&#125;<br></code></pre></td></tr></table></figure><p>在parseBeanDefinitionElement方法中，核心语句是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> createBeanDefinition(className, parent);<br></code></pre></td></tr></table></figure><p>createBeanDefinition使用了BeanDefinitionReaderUtils.createBeanDefinition方法来创建对应的Bean Definition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractBeanDefinition <span class="hljs-title function_">createBeanDefinition</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> String parentName, <span class="hljs-meta">@Nullable</span> String className, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    <span class="hljs-comment">// 创建了一个BeanDefinition准备封装标签中的内容</span><br>    <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>    bd.setParentName(parentName);<br>    <span class="hljs-keyword">if</span> (className != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>            bd.setBeanClass(ClassUtils.forName(className, classLoader));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            bd.setBeanClassName(className);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure><p>在拿到了该BeanDefinition的基本信息后，又给该BeanDefinition添加了许多其余的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 刚刚解析过</span><br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> createBeanDefinition(className, parent);<br><span class="hljs-comment">// 下面就是解析bean标签里面的元数据填充完BeanDefinition</span><br>    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br><br>    parseMetaElements(ele, bd);<br>    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br><br>    parseConstructorArgElements(ele, bd);<br>    parsePropertyElements(ele, bd);<br>    parseQualifierElements(ele, bd);<br><br>    bd.setResource(<span class="hljs-built_in">this</span>.readerContext.getResource());<br>    bd.setSource(extractSource(ele));<br><br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-xxxAware"><a href="#2-6-xxxAware" class="headerlink" title="2.6 xxxAware"></a>2.6 xxxAware</h3><p>比如我们如果想要在Person类中有一个方法， 那就是能获取到Spring的IOC容器，可以通过@Autowired将IOC容器自动注入进来，也可以使用Aware。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span>, MessageSourceAware &#123;<br>    <span class="hljs-comment">// 利用回调机制，把ioc容器传入 xxxAware</span><br>    <span class="hljs-comment">// Aware：帮我们装配spring底层的组件</span><br>    ApplicationContext context;<br>    MessageSource messageSource;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;person创建。。。&quot;</span>); <span class="hljs-comment">// TODO  打断点</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ApplicationContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.context = applicationContext; <span class="hljs-comment">// TODO 打断点</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageSource</span><span class="hljs-params">(MessageSource messageSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.messageSource = messageSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(Person.class);<br>        System.out.println(context == bean.getContext()); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们需要创建BeanFactory（细节上几节说了），接着就得完成BeanFactory的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>finishBeanFactoryInitialization(beanFactory);<br></code></pre></td></tr></table></figure><p>而我们创建Person的过程其实就是在这里面进行的。在这个方法里面，我们关注它最后一行的方法：**beanFactory.preInstantiateSingletons();**，这个方法的作用就是初始化所有的非懒加载的单实例Bean</p><p>接下来我们看这个方法是怎么实现的：在这个方法里面， 先拿到DefaultListableBeanFactory中的beanDefinitionNames，然后就依次遍历每一个beanName，进行大量判断之后，就调用**getBean(beanName)**，通过beanName来创建出对应的Bean。</p><p>在getBean里面，核心调用了doGetBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object beanInstance;<br><br>    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName); <span class="hljs-comment">// 检查缓存有没有</span><br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        .........<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        .........<br>            <span class="hljs-keyword">try</span> &#123;<br>                .........<br>                    <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>                    <span class="hljs-comment">// 看当前bean有没有依赖其余的bean，如果有就先获取它依赖的bean</span><br>                    String[] dependsOn = mbd.getDependsOn();<br>                <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                        ......<br>                            registerDependentBean(dep, beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            getBean(dep);<br>                        &#125;<br>                        ......<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Create bean instance.</span><br>                <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                    <span class="hljs-comment">// getSingleton方法</span><br>                    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">/// 创建Bean对象的实例</span><br>                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                        &#125;<br>                        ......<br>                    &#125;<br></code></pre></td></tr></table></figure><p>注意的是doGetBean方法执行的时候，首先就看看缓存中有没有该Bean，即<strong>getSingleton(beanName)方法</strong>，这个方法其实是看<strong>DefaultSingletonBeanRegistry中的singletonObjects缓存</strong>中有没有该Bean。</p><p><strong>IOC容器-单例池就是DefaultSingletonBeanRegistry中的singletonObjects，缓存所有的单实例对象，单例对象池</strong></p><p><strong>在执行getSingleton方法的时候，用ObjectFactory方法体提供Bean实例</strong></p><p>在createBean方法内部，执行了doCreateBean方法，我们重点分析这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>    <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>    <span class="hljs-comment">// Instantiate the bean.</span><br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br>    <span class="hljs-comment">// 创建bena的实例对象，在这里面使用策略模式来创建</span><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    .........<br><br>        <span class="hljs-comment">// Initialize the bean instance.</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">try</span> &#123;<br>        populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化bean实例</span><br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>        ......<br></code></pre></td></tr></table></figure><p>注：createBeanInstance(beanName, mbd, args);，利用策略模式来创建Bean。可以用jdk的反射，也可以用cglib</p><p><strong>现在我们知道了Person对象通过注解方式创建Bean的时机了，也就是AbstractAutowireCapableBeanFactory中的doCreateBean方法中的createBeanInstance方法。那么spring是什么时候通过Aware将ApplicationContext给放进去的呢？</strong></p><p>这时候就得继续分析。</p><p>在我们创建好Person对象的实例之后，就得调用initializeBean方法来对Person对象进行初始化。</p><p>在初始化的时候，<strong>重点用了一个ApplicationContextAwareProcessor后置处理器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 后置处理器</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们查看这个postProcessBeforeInitialization方法来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||<br>          bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||<br>          bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware ||<br>          bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-type">AccessControlContext</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>        acc = <span class="hljs-built_in">this</span>.applicationContext.getBeanFactory().getAccessControlContext();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (acc != <span class="hljs-literal">null</span>) &#123;<br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            invokeAwareInterfaces(bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;, acc);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 重点！！执行Aware规定的方法</span><br>        invokeAwareInterfaces(bean);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发现这个位于ApplicationContextAwareProcessor类中的方法首先判断该bean是否属于对应Aware类型，如果是，就得执行invokeAwareInterfaces方法将对应的Aware放到对应的Bean中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) &#123;<br>        ((EnvironmentAware) bean).setEnvironment(<span class="hljs-built_in">this</span>.applicationContext.getEnvironment());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) &#123;<br>        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="hljs-built_in">this</span>.embeddedValueResolver);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware) &#123;<br>        ((ResourceLoaderAware) bean).setResourceLoader(<span class="hljs-built_in">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware) &#123;<br>        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="hljs-built_in">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware) &#123;<br>        ((MessageSourceAware) bean).setMessageSource(<span class="hljs-built_in">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware) &#123;<br>        ((ApplicationStartupAware) bean).setApplicationStartup(<span class="hljs-built_in">this</span>.applicationContext.getApplicationStartup());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) &#123;<br>        ((ApplicationContextAware) bean).setApplicationContext(<span class="hljs-built_in">this</span>.applicationContext);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在Spring的底层，判断该bean到底是实现了哪个Aware接口，并执行对应的方法将对应的容器放到该Bean中。</strong></p><p><img src="image-20211224152312172.png" alt="image-20211224152312172"></p><p>总结：</p><ul><li>Bean的功能增强全都是由BeanPostProcessor + InitializingBean </li><li>Person为什么能把ApplicationContext、MessageSource当作自己的参数传进来：通过接口的方式自动注入，由BeanPostProcessor + InitializingBean实现。</li></ul><h3 id="2-7-BeanPostProcessor（后置处理器）"><a href="#2-7-BeanPostProcessor（后置处理器）" class="headerlink" title="2.7 BeanPostProcessor（后置处理器）"></a>2.7 BeanPostProcessor（后置处理器）</h3><p><strong>spring底层通过后置增强机制，增强很多功能</strong>。就比如上述的给Person中注入ApplicationContext，其实是通过实现ApplicationContextAware接口来实现的，而这个接口会使用到ApplicationContextAwareProcessor类，注意的是这个Processer类其实就是实现了BeanPostProcessor接口，也就是后置处理器。</p><h3 id="2-8-Autowire将Cat装配的具体流程再次体验BeanPostProcessor的作用"><a href="#2-8-Autowire将Cat装配的具体流程再次体验BeanPostProcessor的作用" class="headerlink" title="2.8 @Autowire将Cat装配的具体流程再次体验BeanPostProcessor的作用"></a>2.8 @Autowire将Cat装配的具体流程再次体验BeanPostProcessor的作用</h3><p>那么自动装配是怎么完成的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> Cat cat;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCat</span><span class="hljs-params">(Cat cat)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cat = cat; <span class="hljs-comment">// TODO 2.8的断点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在2.6 xxxAware章节中，只是简单的介绍了beanFactory.preInstantiateSingletons()中的getBean方法，对于它之前的一些判断直接略过了，因此这里再看该方法中的判断过程的详细流程：</p><p>在<code>DefaultListableBeanFactory类中的beanFactory.preInstantiateSingletons()//Instantiate all remaining (non-lazy-init) singletons</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>......<br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);<br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    ...<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 核心方法，获取Bean</span><br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，它会去遍历beanDefinitionNames中的每一个beanName，然后判断该beanName所属的RootBeanDefinition是否是抽象的，是否是单例的，是否懒加载的，如果这个beanName不是抽象的，是单例的，不是懒加载的，就再判断该beanName是不是一个FactoryBean，<strong>如果都不是的话，就会去执行核心的getBean方法。</strong></p><p>通过这个方法，可以再次进行扩展：<strong>我们其实有两种bean，一个是普通bean，一个是工厂bean。</strong></p><p>对于普通bean来说，比如Person，注册的组件对象就是Person对象，类型就是Person。而对于FactoryBean来说，就是实现了FactoryBean接口的组件，比如<strong>class HelloFactory implement FactoryBean</strong>，而FactoryBean注册的不是HelloFactory，而是HelloFactory这个工厂调用了getObject（）返回的对象，类型就是getObjectType方法返回的类型。<strong>MyBatis和Spring的整合就是利用了这个FactoryBean</strong>。</p><p>接下来我们就针对于非抽象、单例、非懒加载的普通bean的实例化再去详细看看：</p><p>和以前的流程大致一样，调用getBean方法，然后调用doGet方法，接着就通过getSingleton中传入一个lambda表达式，去执行createBean方法。createBean方法中其实真正执行的是方法doCreateBean(beanName, mbdToUse, args)，传入beanName，RootBeanDefinition，和一些args。</p><p>在doCreateBean方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-comment">// 实例化bean之后，要给它的属性进行赋值，即进行初始化</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>    populateBean(beanName, mbd, instanceWrapper); <span class="hljs-comment">// 重点：给创建好的对象赋值</span><br>    exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220413195915559.png" alt="image-20220413195915559"></p><p>然后在populateBean方法中，它回拿到BeanPostProcessorCache中的instantiationAware，然后在这之前其实该bean已经实例化完成， 但是在初始化该bean之前，后置处理器会拦截那些加了注解的属性，进行自动注入，至于哪些注解，就看下面的解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>    <span class="hljs-comment">// 这里的bp其实是AutowiredAnnotationBeanPostProcessor，它也是个后置处理器</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    pvs：封装好的PropertyValues，这次的测试中，它的processedProperties就是“cat”</span><br><span class="hljs-comment">    bw.getWrappedInstance()：也就是Person对象</span><br><span class="hljs-comment">    beanName：person</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvsToUse</span> <span class="hljs-operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br>    <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>        <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    pvs = pvsToUse;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：可以看到，使用@Autowired、@Value、或者如果引入了包JSR-330，包括@Inject注解，就可以进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AutowiredAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);<br>    <span class="hljs-built_in">this</span>.autowiredAnnotationTypes.add(Value.class);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.autowiredAnnotationTypes.add((Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;)<br>                                          ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));<br>        logger.trace(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        <span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就会去处理bp.postProcessProperties方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;<br>    <span class="hljs-comment">// 找到所有的自动装配的元数据信息</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    至于怎么寻找，它会通过反射的方式先找所有属性中标注了@Autowired、@Value、@Inject的注解，</span><br><span class="hljs-comment">    然后找到所有方法，看有没有相应的注解。</span><br><span class="hljs-comment">    然后它会将所有找到的东西进行封装成一个List&lt;InjectionMetadata.InjectedElement&gt; elements，</span><br><span class="hljs-comment">    接着将这个elements给返回：return InjectionMetadata.forElements(elements, clazz);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">InjectionMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个方法重点！</span><br>        metadata.inject(bean, beanName, pvs);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName, <span class="hljs-string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pvs;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看这个inject方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">(Object target, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Collection&lt;InjectedElement&gt; checkedElements = <span class="hljs-built_in">this</span>.checkedElements;<br>    Collection&lt;InjectedElement&gt; elementsToIterate =<br>        (checkedElements != <span class="hljs-literal">null</span> ? checkedElements : <span class="hljs-built_in">this</span>.injectedElements);<br>    <span class="hljs-keyword">if</span> (!elementsToIterate.isEmpty()) &#123;<br>        <span class="hljs-keyword">for</span> (InjectedElement element : elementsToIterate) &#123;<br>            element.inject(target, beanName, pvs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220413202307212.png" alt="image-20220413202307212"></p><p>InjectedElement，装饰模式，通过分析所有方法或者属性找到标注@Autowired等注解的，然后封装为InjectedElement。</p><p>上述方法会将找到的标注了@Autowired等注解的属性和方法包装成的InjectedElement，执行该element的inject方法，来到AutowiredAnnotationBeanPostProcessor，然后利用反射进行赋值。<code>method.invoke(bean, arguments);</code>这里的arguments其实就是Cat对象。</p><h3 id="2-9-Spring中各种后置增强器的执行顺序和流程（即Bean的生命周期）"><a href="#2-9-Spring中各种后置增强器的执行顺序和流程（即Bean的生命周期）" class="headerlink" title="2.9 Spring中各种后置增强器的执行顺序和流程（即Bean的生命周期）"></a>2.9 Spring中各种后置增强器的执行顺序和流程（即Bean的生命周期）</h3><h4 id="0-调试环境的搭建"><a href="#0-调试环境的搭建" class="headerlink" title="0. 调试环境的搭建"></a>0. 调试环境的搭建</h4><p>首先值得注意的是，在Spring中有三种增强器：</p><ul><li><strong>BeanPostProcessor：</strong>后置增强普通的Bean组件，每一个子接口的增强器在何时运行，在于改变，比如@Autowired就能改变Bean的属性的赋值</li><li><strong>BeanFactoryPostProcessor：</strong>后置增强BeanFactory。它只提供了一个接口：<code>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</code>试想一下，它将整个factory都传过来了，这不就想怎么增强就怎么增强</li><li><strong>InitializingBean：</strong>Bean组件初始化以后对组件进行后续设置。它也只提供一个接口<code>void afterPropertiesSet() throws Exception;</code>在于额外处理，因为它的接口中并没有传入相关的参数。</li></ul><p><img src="image-20220415214707327.png" alt="image-20220415214707327"></p><p><img src="image-20220415214211929.png" alt="image-20220415214211929"></p><p>接下来我们就来分析这三种接口的执行流程以及在哪执行，首先得准备测试环境，<strong>我们给每个构造器、重写的各种方法都打上断点，进行分析</strong>：</p><p><img src="image-20220415214843490.png" alt="image-20220415214843490"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 让其为原型模式 每次获取的都是复制品，如果不搞的话，就是默认为单例模式</span><br><span class="hljs-comment">//@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-comment">//@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    Cat() &#123;<br>        System.out.println(<span class="hljs-string">&quot;cat被创建了&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> <span class="hljs-comment">// 自动赋值功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;cat ... setName正在调用：&quot;</span> + name);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInitializingBean...afterPropertiesSet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Bean组件的 PostProcessor；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanPostProcessor</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanPostProcessor...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanPostProcessor...postProcessAfterInitialization...&quot;</span>+bean+<span class="hljs-string">&quot;==&gt;&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-comment">// 下面的方法还可以对该bean进行干预</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanPostProcessor...postProcessBeforeInitialization...&quot;</span>+bean+<span class="hljs-string">&quot;==&gt;&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> bean; <span class="hljs-comment">// new Object();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InstantiationAwareBeanPostProcessor</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInstantiationAwareBeanPostProcessor</span><span class="hljs-params">()</span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;MyInstantiationAwareBeanPostProcessor...&quot;</span>);<br>   &#125; <span class="hljs-comment">//初始化之前进行后置处理，Spring留给我们给这个组件创建对象的回调。</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>      System.out.println(<span class="hljs-string">&quot;MyInstantiationAwareBeanPostProcessor...postProcessBeforeInstantiation=&gt;&quot;</span>+beanClass+<span class="hljs-string">&quot;--&quot;</span>+beanName); <span class="hljs-comment">//if(class.isAssFrom(Cat.class))&#123;return new Dog()&#125;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//如果我们自己创建了对象返回。Spring则不会帮我们创建对象，用我们自己创建的对象？ 我们创建的这个对象，Spring会保存单实例？还是每次getBean都调到我们这里创建一个新的？</span><br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>      System.out.println(<span class="hljs-string">&quot;MyInstantiationAwareBeanPostProcessor...postProcessAfterInstantiation=&gt;&quot;</span>+bean+<span class="hljs-string">&quot;--&quot;</span>+beanName); <span class="hljs-comment">//提前改变一些Spring不管的bean里面的属性</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//返回false则bean的赋值全部结束</span><br>   &#125;  <span class="hljs-comment">//下面的方法作用？比如：解析自定义注解进行属性值注入；pvs 封装了所有的属性信息。</span><br>   <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span><br>         <span class="hljs-keyword">throws</span> BeansException &#123; <span class="hljs-comment">//@GuiguValue();redis</span><br>      System.out.println(<span class="hljs-string">&quot;MyInstantiationAwareBeanPostProcessor...postProcessProperties=&gt;&quot;</span>+bean+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMergedBeanDefinitionPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MergedBeanDefinitionPostProcessor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyMergedBeanDefinitionPostProcessor</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMergedBeanDefinitionPostProcessor...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMergedBeanDefinitionPostProcessor...postProcessBeforeInitialization...=&gt;&quot;</span>+bean+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> bean; <span class="hljs-comment">//null</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMergedBeanDefinitionPostProcessor...postProcessAfterInitialization..=&gt;&quot;</span>+bean+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMergedBeanDefinitionPostProcessor...postProcessMergedBeanDefinition..=&gt;&quot;</span>+beanName+<span class="hljs-string">&quot;--&quot;</span>+beanType+<span class="hljs-string">&quot;---&quot;</span>+beanDefinition);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetBeanDefinition</span><span class="hljs-params">(String beanName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMergedBeanDefinitionPostProcessor...resetBeanDefinition..&quot;</span>+beanName);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//bean进行代理增强期间进行使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInstantiationAwareBeanPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MySmartInstantiationAwareBeanPostProcessor</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySmartInstantiationAwareBeanPostProcessor...&quot;</span>);<br>    &#125;  <span class="hljs-comment">//预测bean的类型，最后一次改变组件类型。</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MySmartInstantiationAwareBeanPostProcessor...predictBeanType=&gt;&quot;</span>+beanClass+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-comment">// TODO 看看下面这个方法，如果多个SmartBP类同时执行了这个方法，会咋样</span><br>    <span class="hljs-comment">//返回我们要使用的构造器候选列表</span><br>    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)<br><br>        <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MySmartInstantiationAwareBeanPostProcessor...determineCandidateConstructors=&gt;&quot;</span>+beanClass+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br>        <span class="hljs-comment">//返回一个我们指定的构造器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回早期的bean引用，定义三级缓存中的bean信息</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MySmartInstantiationAwareBeanPostProcessor...getEarlyBeanReference=&gt;&quot;</span>+bean+<span class="hljs-string">&quot;--&quot;</span>+beanName);<br><br>        <span class="hljs-keyword">return</span> bean; <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果想要指定后置处理器的顺序，需要实现接口PriorityOrdered，然后数字越小，优先级越高</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanDefinitionRegistryPostProcessor</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//紧接着执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor....postProcessBeanFactory...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//先执行的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry...&quot;</span>);<br>        <span class="hljs-comment">//增强bean定义信息的注册中心，比如自己注册组件</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    MyBeanFactoryPostProcessor() &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyBeanFactoryPostProcessor...&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;BeanFactoryPostProcessor....postProcessBeanFactory&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;top.noaharno.processor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top.noaharno.bean.Cat&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试环境已经搭建好，接下来就是一步步调试，查看源码：</p><h4 id="1-invokeBeanFactoryPostProcessors"><a href="#1-invokeBeanFactoryPostProcessors" class="headerlink" title="1. invokeBeanFactoryPostProcessors"></a>1. invokeBeanFactoryPostProcessors</h4><p>上述标题的方法其实就是容器刷新十二大步中的一步，在准备好BeanFactory之后，就得去调用这个方法对所有的BeanFactory进行后置增强。<strong>配置类会在这里进行解析</strong></p><p>在这个方法中，它会去执行所有的工厂增强器：<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</code>。</p><p><strong>注意这个PostProcessorRegistrationDeledate，也就是后置处理器的注册代理，它代理执行所有后置增强器的功能。</strong></p><p><img src="image-20220417083530926.png" alt="image-20220417083530926"></p><p>在invokeBeanFactoryPostProcessors方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行工厂的后置处理器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;<br><br>    <span class="hljs-comment">// 标记已经被处理过的bean</span><br>    Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;<br>        <span class="hljs-type">BeanDefinitionRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> (BeanDefinitionRegistry) beanFactory;<br>        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//先拿到底层默认有的BeanFactoryPostProcessor，这里暂时是没有</span><br>        <span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br>            <span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;<br>                <span class="hljs-type">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-variable">registryProcessor</span> <span class="hljs-operator">=</span><br>                    (BeanDefinitionRegistryPostProcessor) postProcessor;<br>                registryProcessor.postProcessBeanDefinitionRegistry(registry);<br>                registryProcessors.add(registryProcessor);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                regularPostProcessors.add(postProcessor);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 不要在这里初始化FactoryBeans：我们需要让所有常规bean保持未初始化状态，以便让bean factory后处理器应用于它们！在实现PriorityOrdered、Ordered和其他功能的BeanDefinitionRegistryPostProcessor之间进行分离。</span><br>        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 首先：从工厂中获取所有的实现了 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor； </span><br>        String[] postProcessorNames =<br>            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">//拿到系统中每一个组件的BD信息，进行类型对比，是否匹配指定的类型</span><br>        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>            <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<span class="hljs-comment">//从工厂中获取这个组件【getBean整个组件创建的流程】并放到这个集合</span><br>                processedBeans.add(ppName);<br>            &#125;<br>        &#125; <span class="hljs-comment">//下面利用优先级排序</span><br>        sortPostProcessors(currentRegistryProcessors, beanFactory);<br>        registryProcessors.addAll(currentRegistryProcessors);<br>        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); <span class="hljs-comment">//执行这些BeanDefinitionRegistryPostProcessor的</span><br>        currentRegistryProcessors.clear();<br><br>        <span class="hljs-comment">// 接下来，获取所有实现了Ordered接口的 BeanDefinitionRegistryPostProcessor</span><br>        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>            <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>                processedBeans.add(ppName);<br>            &#125;<br>        &#125;<span class="hljs-comment">//排序</span><br>        sortPostProcessors(currentRegistryProcessors, beanFactory);<br>        registryProcessors.addAll(currentRegistryProcessors);<br>        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); <span class="hljs-comment">//执行</span><br>        currentRegistryProcessors.clear();<br><br>        <span class="hljs-comment">// 最后，我们自定义的一般没有任何优先级和排序接口   Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">reiterate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (reiterate) &#123;<br>            reiterate = <span class="hljs-literal">false</span>;<br>            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//拿到所有的BeanDefinitionRegistryPostProcessor</span><br>            <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>                <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br>                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>                    processedBeans.add(ppName);<br>                    reiterate = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<span class="hljs-comment">//排序，根据类名大小写进行排序</span><br>            sortPostProcessors(currentRegistryProcessors, beanFactory);<br>            registryProcessors.addAll(currentRegistryProcessors);<br>            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());<br>            currentRegistryProcessors.clear(); <span class="hljs-comment">//防止重复执行</span><br>        &#125;<br><br>        <span class="hljs-comment">// 接下来，再来执行postProcessBeanFactory的回调</span><br>        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br>        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br>        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>    &#125;<br>    <span class="hljs-comment">//以前在执行 BeanDefinitionRegistryPostProcessor ,以后来执行 BeanFactoryPostProcessor</span><br>    <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br>    <span class="hljs-comment">// uninitialized to let the bean factory post-processors apply to them!</span><br>    String[] postProcessorNames =<br>        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br>    <span class="hljs-comment">// Ordered, and the rest.</span><br>    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>        <span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br>            <span class="hljs-comment">// skip - already processed in first phase above</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>            orderedPostProcessorNames.add(ppName);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            nonOrderedPostProcessorNames.add(ppName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 首先执行所有实现了 PriorityOrdered 的 BeanFactoryPostProcessor；First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br>    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br>    <span class="hljs-comment">// 接下来执行，实现了 Ordered 接口的 BeanFactoryPostProcessor  Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br>    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br>        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>    &#125;<br>    sortPostProcessors(orderedPostProcessors, beanFactory);<br>    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br>    <span class="hljs-comment">// 最后执行没有任何优先级和排序接口的 BeanFactoryPostProcessor Finally, invoke all other BeanFactoryPostProcessors.</span><br>    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br>        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>    &#125;<br>    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); <span class="hljs-comment">//执行所有的 BeanFactoryPostProcessor</span><br><br>    <span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br>    <span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br>    beanFactory.clearMetadataCache();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么它是如何执行BeanDefinitionRegistryPostProcessor中的postProcessBeanDefinitionRegistry方法的呢？其实也就是方法：<code>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</code>它会将当前需要进行处理的BeanDefinitionRegistryPostProcessor和DefaultListableBeanFactory传进去，然后遍历所有的传进去的Processor进行执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">    Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> &#123;<br><br>    <span class="hljs-keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;<br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">postProcessBeanDefRegistry</span> <span class="hljs-operator">=</span> applicationStartup.start(<span class="hljs-string">&quot;spring.context.beandef-registry.post-process&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;postProcessor&quot;</span>, postProcessor::toString);<br>        postProcessor.postProcessBeanDefinitionRegistry(registry); <span class="hljs-comment">//核心，配置类的后置处理器会在此解析配置类</span><br>        postProcessBeanDefRegistry.end();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理完所有的BeanDefinitionRegistryPostProcessor的postProcessBeanDefitionRegistry回调之后，它会紧接着去执行该类的postProcessBeanFactory回调，和前面类似，也是进行一个遍历执行。</p><p>这时候就已经处理完所有的BeanDefinitionRegistryPostProcessor了，然后就会立马去按照上述的流程执行BeanFactoryPostProcessor的postProcessBeanFactory回调。注意的是，这一步他会先去获取到的所有BeanFactoryPostProcessor类型的BeanName，然后去判读这个BeanName有没有被上述流程处理过，因为BeanDefinitionRegistryPostProcessor其实就是继承了BeanFactoryPostProcessor的。</p><p><strong>总结：</strong></p><ol><li>在容器刷新十二大步中的第五步，即工厂创建好了之后就会进行增强， 执行bean工厂的后置增强功能。</li><li>它使用PostProcessorRegistrationDelegate代理执行所有后置增强器的功能。</li><li>具体流程就是它首先会执行容器中默认有的BeaDefinitionRegistryPostProcessor，执行它们的postProcessorBeanDefinitionRegistry后置增强方法，注意只执行了这个方法，剩下的postProcessorBeanFactory方法留到后续流程一起执行。</li><li>然后它会依照方法后置增强器类是否实现PriorityOrdered、Order、没有实现任何排序接口这三中情况进行分类，然后分别排序，接着就是分别执行bean工厂的增强。</li><li><strong>在获取所有的BeanDefinitionRegistryPostProcessor的时候，它会去调用getBean方法走后续的流程，将该Processor给创建出来</strong></li><li>在分类执行完所有的postProcessorBeanDefinitionRegistry增强方法之后，他会去统一去执行所有方法后置增强器的postProcessorBeanFactory，至此，所有BeaDefinitionRegistryPostProcessor的实现类都已经执行完了它们的增强。</li><li>下一步就是执行所有BeanFactoryPostProcessor的bean工厂增强方法，流程和BeaDefinitionRegistryPostProcessor大致一样。</li></ol><p><img src="image-20220417092804970.png" alt="image-20220417092804970"></p><p>至此：所有的工厂增强逻辑已经讲解完毕。</p><p><strong>那么Spring中到哪哪里用到了这个BeanFactory的后置增强器呢？思考下面的问题：</strong></p><ol><li>Configuration注解的作用是什么，Spring是如何解析加了@Configuration注解的类？</li><li>Spring在什么时候对@ComponentScan、@ComponentScans注解进行了解析？</li><li>Spring什么时候解析了@Import注解，如何解析的？</li><li>Spring什么时候解析了@Bean注解？</li></ol><p>我们可以以注解版方式进行调试启动，可以发现Spring底层有一个Processor：ConfigurationClassPostProcessor，配置类的后置处理器。</p><p><img src="20190917233910588.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-comment">// 把配置类中所有的bean的定义信息导入进来。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">factoryId</span> <span class="hljs-operator">=</span> System.identityHashCode(beanFactory);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>            <span class="hljs-string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.factoriesPostProcessed.add(factoryId);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.registriesPostProcessed.contains(factoryId)) &#123;<br>        <span class="hljs-comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span><br>        <span class="hljs-comment">// Simply call processConfigurationClasses lazily at this point then.</span><br>        <span class="hljs-comment">// 核心方法</span><br>        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);<br>    &#125;<br><br>    enhanceConfigurationClasses(beanFactory);<br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ImportAwareBeanPostProcessor</span>(beanFactory));<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法processConfigBeanDefinitions中，它会去从给定的BeanDefinitionRegistry中拿到所有的BeanDefinitionNames，然后依次去遍历这些name，如果这个name所对应的BeanDefinition是一中包含属性configurationClass，就将该配置类加到候选集合里面，后来就将这个集合configCandidates转换为一个Set，然后依次遍历set中的每个对象。</p><p><img src="image-20220414162031257.png" alt="image-20220414162031257"></p><p><img src="image-20220414162504808.png" alt="image-20220414162504808"></p><p><img src="image-20220414162434285.png" alt="image-20220414162434285"></p><p>在后续的处理中，它会通过读取这个类的注解、成员和方法，去构建一个完整的ConfigurationClass。</p><ul><li>首先他会去处理任何递归的成员类。</li><li>然后他会去看该类有没有使用@PropertySources，有的话就进行处理。</li><li>接着它看该类有没有使用@ComponentScans或者@ComponentScan。</li><li>然后就是处理任何标注了@Import注解的</li><li>处理标注了@ImportResource</li><li>接着去处理单个的@Bean方法</li><li>处理接口上的默认方法</li><li>处理父类（如果有）</li></ul><h4 id="2-将所有的BeanPostProcessor给注册进容器"><a href="#2-将所有的BeanPostProcessor给注册进容器" class="headerlink" title="2. 将所有的BeanPostProcessor给注册进容器"></a>2. 将所有的BeanPostProcessor给注册进容器</h4><p>至于怎么去将所有的BeanPostProcessor给注册进容器，主要看容器刷新十二大步中的<strong>registerBeanPostProcessors(beanFactory);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它其实也是调用我们的PostProcessorRegistrationDelegate来代理执行。</p><p>在这个方法里面，它的整体流程其实和BeanFactoryPostProcessor的注册流程有相同之处。只不过在registerBeanPostProcessor方法中，它只会去将所有的BeanPostProcessor保存在容器中，并不会去执行它们的回调方法。</p><p><strong>步骤：</strong></p><ol><li><p>获取到容器中所有的 BeanPostProcessorName； Bean的后置处理器的名字。</p></li><li><p>将这些BeanPostProcessor进行分类，同样是PriorityOrdered、Order、未实现任何排序接口这三个大类。</p></li><li><p>将这些后置处理器根据名字从容器中获取，如果容器中没有，就进行创建，并将其注册到容器中。</p></li><li><p>所谓的注册流程，其实就是添加到<strong>beanPostProcessors</strong>中。</p></li><li><p>同时，<strong>如果当前的后置处理器实现了MergedBeanDefinitionPostProcessor接口，还会额外添加到internalPostProcessors中，它是一个List。</strong></p></li><li><p>在注册完所有的BeanPostProcessor之后，他会将所有的<strong>internalPostProcessors</strong>进行一个排序，然后重新注入到容器中。</p></li><li><p>至此所有我们的BeanPostProcessor已经注册完毕，但是还剩下一步：那就是new一个后置增强器，将其添加到beanPostProcessors中的末尾位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="hljs-comment">//moving it to the end of the processor chain (for picking up proxies etc).</span><br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(applicationContext));<br></code></pre></td></tr></table></figure></li></ol><p><img src="image-20220417102039557.png" alt="image-20220417102039557"></p><p>至此该小节分析结束，它的主要流程其实就是<strong>工厂提前保存所有Bean的增强器，方便在后面创建bean的时候直接使用</strong>。</p><p><img src="image-20220417105843086.png" alt="image-20220417105843086"></p><h4 id="3-predictBeanType的执行时机"><a href="#3-predictBeanType的执行时机" class="headerlink" title="3. predictBeanType的执行时机"></a>3. predictBeanType的执行时机</h4><p>当我们看到registerListeners方法的时候，首先肯定想到它是用来注册监听器的，Spring事件监听机制在这里开始初始化，那么它和我们的SmartInstantiationAwareBeanPostProcessor.predictBeanType( )，决定当前初始化的组件类型，有什么关系呢？</p><p>在这个方法中，它会根据类型获取ApplicationListener在IOC容器中注册的所有bean的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>而就是在这个方法中，就会有机会执行predictBeanType方法。</p><p>在经过一系列的判断之后，它执行的核心方法其实是：<code>doGetBeanNamesForType</code>。在这个方法中，它会遍历所有的beanDefinitionNames，然后挨个判断该beanName所对应的类型是否是ApplicationListener。</p><p>在这里先说一下<strong>Spring如何在容器中按照类型找组件</strong>。它其实是非常笨的，具体如下图所示：</p><p><img src="image-20220417120834166.png" alt="image-20220417120834166"></p><p>明明容器中有很多的bean的定义信息，为什么执行的时候只有Cat和Dog会调用SmartInstantiationAwareBeanPostProcessor.predictBeanType( )？：</p><p><img src="image-20220417120948642.png" alt="image-20220417120948642"></p><p>一种简单的语义理解就是：<strong>这些beanDefinitionNames中，前面的这些Processor其实早就创建好实例了，也就是说它们的类型其实早就被决定好了，而Cat和Dog它们还并没有创建实例，因此还可以通过predictBeanType方法来修改它们的BeanType。这就导致了在容器想要获取所有的ApplicationListen所属于的bean的时候，在遍历过程中，它会去看看容器中的那些还未创建好实例的beanName它们的类型在经过predictBeanType改变之后，是否为它所想要的类型</strong>&#x2F;</p><p>也就是说：<strong>在组件对象创建之前还有机会改变一下它的类型。基本上之后每一次如果调用getBeanNamesForType方法的时候，都会去判断一下。</strong></p><p>而对于这次的调试来说，我们接着往下执行，来到容器刷新十二大步中的最重要的一步：<strong>finishBeanFactoryInitialization</strong>，即BeanFactory初始化，它会完成容器中所有的bean创建。而在这个方法中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-comment">// 给工厂设置好 ConversionService【负责类型转换的组件服务】，</span><br>    <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;<br>        beanFactory.setConversionService(<br>            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>    &#125;<br><br>    <span class="hljs-comment">// 注册一个默认的值解析器（&quot;$&#123;&#125;&quot;）</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;<br>        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));<br>    &#125;<br><br>    <span class="hljs-comment">// LoadTimeWeaverAware；aspectj：加载时织入功能【aop】。 Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br>    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;<br>        getBean(weaverAwareName); <span class="hljs-comment">//从容器中获取组件，有则直接获取，没则进行创建</span><br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>它会有一些前置操作，而其中就有一个，获取beanFactory中所有的<strong>LoadTimeWeaverAware</strong>类型的名字，然后依次进行创建。在这个步骤的执行过程中，同样也会去调用<code>doGetBeanNamesForType</code>，然后里面会再次对Cat和Dog进行一个类型检查。</p><h4 id="4-其它的后置处理器对bean的生命周期的干预过程"><a href="#4-其它的后置处理器对bean的生命周期的干预过程" class="headerlink" title="4. 其它的后置处理器对bean的生命周期的干预过程"></a>4. 其它的后置处理器对bean的生命周期的干预过程</h4><p>在<strong>finishBeanFactoryInitialization</strong>中，执行完上述的一些基本流程之后，它会执行它里面的核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化所有的非懒加载的单实例Bean</span><br>beanFactory.preInstantiateSingletons();<br></code></pre></td></tr></table></figure><p>它会拿到beanDefinitionNames中的所有的bean的名字，然后依次遍历这些beanName，根据名字获取到它的RootBeanDefinition，并且判断它不是抽象的，是单实例的，不是懒加载的，然后就可以对这个RootBeanDefinition分类讨论，FactoryBean和普通的Bean分为两种方式进行创建。</p><p>如果不是FactoryBean，并且是普通的单实例非懒加载bean的创建，就会执行方法：**getBean(beanName);**，它里面会调用doGetBean方法。</p><p>在doCreateBean方法中，</p><ol><li>它会先去检查容器中有有没有单实例bean的缓存，第一次获取肯定是没有的</li><li>然后它就会拿到当前beanFactory的父工厂，看看有没有父工厂，会尝试去父工厂中获取组件。</li><li>如果没有父工厂，就会先标记当前的beanName它的bean已经被创建了，接下来就走创建流程</li><li>它会去获取当前beanName的RootBeanDefinition，然后看当前的mdb有没有依赖其它的Bean，如果依赖了就会去挨个递归获取，如果没有就继续。</li><li>后续的大致流程就是判断bean的类型，如果是单例的，就执行单例的流程；如果是多例的，就走原型模式创建；如果都不是，就走其它的流程创建。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建bean的实例；Create bean instance.</span><br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);  <span class="hljs-comment">//创建bean对象的实例</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>            <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>            <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>            destroySingleton(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>    &#125;); <span class="hljs-comment">//看当前bean是否是FactoryBean</span><br>    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>在开始创建该Bean之前，他会将该beanName添加到singletonsCurrentlyInCreation中。创建Bean之后，会将该beanName从singletonsCurrentlyInCreation池中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们重点看调用的lamda表达式中的内容，它会真正的创建对象。即<strong>createBean(beanName, mbd, args)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>    <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    .......<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//提前给我们一个机会，去返回组件的代理对象。</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br>    ......<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//Spring真正自己创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>就在这个方法中，它会先去给我们一个机会，看看我们会不会自己返回对象。而这个方法的内部实现，其实就是调用<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>方法，<strong>如果我们自己创建了对象返回。Spring则不会帮我们创建对象，用我们自己创建的对象，而且这个对象同样是单实例的，并且如果当前方法的确返回了对象， 还会立马去执行它的postProcessAfterInstantiation方法，接着当前beanName的bean创建过程就结束了。</strong></p><p>但是其实我们很少去干预bean的创建，因此一般都是直接返回null，然后交由Spring自动帮我们创建对象。</p><p>在Spring帮我们创建对象的过程中，它会给我们一个机会，让我们去决定当前bean使用哪个构造器，即调用<code>SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors()</code>方法，<strong>返回我们要使用的构造器候选列表。如果返回的不是null，就使用构造器方式的自动装配创建bean。否则就默认使用无参构造器</strong></p><p>此时Cat算是被创建出来了，与此同时，Spring还允许后置处理器再来修改下beanDefinition，这里用的是：<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>。</p><p><img src="image-20220417142818168.png" alt="image-20220417142818168"></p><p><img src="image-20220417143023418.png" alt="image-20220417143023418"></p><p>接下来Spring就会给创建好的对象的每个属性进行赋值，**@Autowired就发生在这里面，即populateBean方法**</p><p>在populateBean方法中，在属性真正的赋值之前，它可以调用<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</code>来初始化之前进行处理，如果该方法返回false，就直接中断初始化行为。一个典型的例子就是<strong>Spring的自动装配后置处理器在这里工作，但是它并没有做什么其余的操作，只是返回了true。</strong></p><p>它还可以使用<code>InstantiationAwareBeanPostProcessor中的postProcessProperties</code>方法，对pvs进行处理。<strong>比如Spring的自动装配后置处理器AutowiredAnnotationBeanPostProcessor就会在这里工作，它会找到自动装配的元数据信息，然后执行自动装配工作。</strong></p><p>在处理完这些后置处理器的方法之后，Spring就会为当前bean设置属性，把以前处理好的PropertyValues给bean里面设置一下。主要是上面步骤没有给bean里面设置的属性，通过反射的方式进行赋值。</p><p><img src="image-20220417144543682.png" alt="image-20220417144543682"></p><p>接下来就执行bean的初始化流程：<code>initializeBean(beanName, exposedObject, mbd)</code></p><p><img src="image-20220417150629886.png" alt="image-20220417150629886"></p><p>注意上图没有MergedBeanDefinitionPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization流程，因为这两个方法其实是MergedBeanDefinitionPostProcessor实现了BeanPostProcessor接口之后，BeanPostProcessor接口中的两个方法， 它们的执行流程就和BeanPostProcessor的执行流程完全一致。</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h4><p>在Spring中有很多的后置增强器，其中有工厂增强器和bean增强器。在Spring的启动过程中， 在他的工厂创建好了之后，就可以调用工厂增强器对创建好的工厂进行增强。接着Spring会在工厂中提前保存所有的Bean增强器，方便在后续的bean创建过程中直接使用。之后其实就是在bean的创建前后，各种PostProcessor发挥作用。</p><p>具体流程如下图所示：</p><p><img src="image-20220417151316059.png" alt="image-20220417151316059"></p><h3 id="2-10-Bean的初始化流程（GetBean的详细逻辑）"><a href="#2-10-Bean的初始化流程（GetBean的详细逻辑）" class="headerlink" title="2.10 Bean的初始化流程（GetBean的详细逻辑）"></a>2.10 Bean的初始化流程（GetBean的详细逻辑）</h3><p>我们以**finishBeanFactoryInitialization刷新步骤中的beanFactory.preInstantiateSingletons()，初始化所有的非懒加载的单实例Bean;**为起点，进行初始化流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br>    <span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// 创建出所有的单实例Bean；Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName); <span class="hljs-comment">//开始解析文件的时候每一个bean标签被解析封装成一个BeanDefinition</span><br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123; <span class="hljs-comment">//如果是FactoryBean则执行下面逻辑</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName); <span class="hljs-comment">//得到HelloFactory</span><br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br>                    <span class="hljs-type">boolean</span> isEagerInit;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                        isEagerInit = AccessController.doPrivileged(<br>                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>                            getAccessControlContext());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                        getBean(beanName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//不是FactoryBean则执行这个,普通的单实例非懒加载bean的创建</span><br>                getBean(beanName); <span class="hljs-comment">//</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 post-initialization 逻辑；</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>        <span class="hljs-comment">// 如果当前的bean实现了SmartInitializingSingleton接口，就执行下面步骤</span><br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">smartInitialize</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.beans.smart-initialize&quot;</span>)<br>                .tag(<span class="hljs-string">&quot;beanName&quot;</span>, beanName);<br>            <span class="hljs-type">SmartInitializingSingleton</span> <span class="hljs-variable">smartSingleton</span> <span class="hljs-operator">=</span> (SmartInitializingSingleton) singletonInstance;<br>            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>                    smartSingleton.afterSingletonsInstantiated();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                smartSingleton.afterSingletonsInstantiated();<br>            &#125;<br>            smartInitialize.end();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>还是之前熟悉的流程，Spring会遍历所有容器中所有的BeanName进行创建获取，<strong>在所有的bean创建完成之后，Spring会再次遍历所有的beanName，然后取出它们已经创建好的实例，如果该实例实现了SmartInitializingSingleton接口，就执行它们的afterSingletonsInstantiated( )方法。</strong></p><p>让我们将目光重新聚焦到一开始，也就是Spring遍历所有容器中所有的BeanName进行挨个创建，如上述代码所示，Spring会在获取到该beanName对应的RootBeanDefinition之后，会去判断当前Bean满不满足：单实例、非抽象、非懒加载，如果满足就会判断当前bean是否是工厂Bean。</p><p><strong>如果是工厂bean：</strong></p><ol><li>工厂Bean在Spring容器中一开始保存的是工厂本身。</li><li>第一次获取Hello组件（HelloFactory能产生的对象）的时候，即getBean方法会在底层所有组件挨个遍历找到哪个组件的类型是Hello</li><li>找到HelloFactory发现它是工厂，类型就被决定为Hello</li><li>调用工厂方法（getObject）创建Hello对象</li><li>如果是普通的单实例，就会保存在singletonObject里面。</li><li>如果是工厂产生的bean则缓存在factoryBeanCache，下一次直接从这里拿，所有工厂Bean默认还是单实例。</li></ol><p><strong>如果是普通bean，就会调用getBean(beanName)方法，它实际上调用的是doGetBean方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name); <span class="hljs-comment">//转换Bean名字</span><br>    Object beanInstance;<br><br>    <span class="hljs-comment">// 先检查单实例bean的缓存 第一次查找的时候都是没有的</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName); <br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        ......<br>        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//默认第一次获取组件都会进入else环节</span><br>......<br>        <span class="hljs-comment">// 拿到整个beanFactory的父工厂；看父工厂有没有，从父工厂先尝试获取组件； </span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123; <span class="hljs-comment">//以下开始从父工厂获取组件</span><br>            ......<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName); <span class="hljs-comment">//标记当前beanName的bean已经被创建</span><br>        &#125;<br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanCreation</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>            &#125;<br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">//看当前Bean有没有依赖其他Bean Guarantee initialization of beans that the current bean depends on.</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        getBean(dep); <span class="hljs-comment">//依赖了其他bean，就先获取其他的哪些bean</span><br>                    &#125;<br>                    ......<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 创建bean的实例；Create bean instance.</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                <span class="hljs-comment">// ⭐真正的核心方法</span><br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);  <span class="hljs-comment">//创建bean对象的实例</span><br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;); <span class="hljs-comment">//看当前bean是否是FactoryBean</span><br>                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br>            <span class="hljs-comment">// 该bean是多实例的</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>                ......<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ......<br>            &#125;<br>        &#125;<br>        ......<br>    &#125;<br>    <span class="hljs-comment">//转Object为Bean的T类型</span><br>    <span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码所示，它会先看有没有父工厂，并且父工厂有没有这个组件，然后看当前bean有没有依赖于其它的bean，如果有了就去依次创建它所依赖的组件，否则就进入接下来的创建过程，即<strong>执行getSingleton方法</strong>。</p><p>在这个方法中，它会先锁住整个单例池，然后会再次从一级缓存singletonObjects中尝试获取到该beanName所属于的Bean，如果拿到了就直接返回该对象，如果没拿到就继续去创建。</p><p>在创建之前，Spring会将该beanName添加到<strong>singletonsCurrentlyInCreation</strong>中，即会把当前正在创建的beanName给保存起来。在创建之后，会将beanName从该容器中删除。<strong>并且如果当前beanName是第一次创建，还会将该bean添加到singletonObjects中，然后将其从singletonFactories和earlySingletonObjects中移除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<br>        <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>        <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>        <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在bean创建过程中，它会调用lambda表达式，<code>singletonObject = singletonFactory.getObject();</code>去真正的创建对象。</p><p>接下来的流程其实就是参考上一个小节：Spring中各种后置增强器的执行顺序和流程（即Bean的生命周期）。在这个过程中，会有各种各样的Bean的后置增强器在bean的创建过程中进行干预和增强。</p><p><img src="bean%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.jpg" alt="bean初始化流程"></p><h3 id="2-11-注解版容器刷新12大步"><a href="#2-11-注解版容器刷新12大步" class="headerlink" title="2.11 注解版容器刷新12大步"></a>2.11 注解版容器刷新12大步</h3><h4 id="0-容器刷新的前置操作"><a href="#0-容器刷新的前置操作" class="headerlink" title="0. 容器刷新的前置操作"></a>0. 容器刷新的前置操作</h4><p>考虑到以后用SpringBoot，都是使用注解用的多，因此本次分析流程主要分析注解版容器的刷新流程。</p><p>我们的启动类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用的其实是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    register(componentClasses);<br>    refresh(); <span class="hljs-comment">//容器完整刷新（创建出所有组件，组织好所有功能）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在分析容器的刷新流程之前，先看看它前面的两个步骤是干嘛的，首先来看this()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StartupStep</span> <span class="hljs-variable">createAnnotatedBeanDefReader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);<br>    <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br>    createAnnotatedBeanDefReader.end();<br>    <span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>reader用来读取beanDefinition，而创建的AnnotatedBeanDefinitionReader，后续就是为了加载底层功能组件的后置处理器。</li><li>scanner用来扫描需要导入的所有bean信息，该方法里面其实就是准备了环境变量等一些信息。</li></ul><p>其中在创建reader的过程内部，它先是注册一个注解配置的处理器，即<code>AnnotationConfigApplicationContext</code>。然后创建一个<code>ConditionEvaluator</code>，它在@Conditional执行过程中起到作用。接着就会<strong>给工厂中注册一些核心组件，比如：</strong>ConfigurationClassPostProcessor【处理配置类】、<strong>AutowiredAnnotationBeanPostProcessor【自动装配功能后置处理器】</strong>、CommonAnnotationBeanPostProcessor【普通JSR250注解处理，支持@PostConstruct、@PreDestroy、@Resource相关注解】、EventListenerMethodProcessor【事件方法的后置处理器】、DefaultEventListenerFactory【事件工厂】</p><p><strong>注意的是，当前仅仅只是将这些组件添加到DefaultListableBeanFactory的beanDefinitionNames和beanDefinitionMap中，并没有进行初始化</strong></p><p><img src="image-20220417201226445.png" alt="image-20220417201226445"></p><p><img src="image-20220417201612260.png" alt="image-20220417201612260"></p><p><strong>在执行完this之后，接下来就得执行register(mainConfig)。</strong></p><p>在这个方法中，我们之前在this里面注册好的reader就排上用场了，它会遍历注册当前所有的主配置类，即new AnnotationConfigApplicationContext中传入的参数。它会先创建当前主配置类的BeanDefinitioni信息，然后调用<code>AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</code>来完善主配置类的BeanDefinition，即解析@Lazy、@Primary、@DependsOn、@Description等相关注解。紧接着就是将主配置类的定义信息给注册进容器中去。</p><p><img src="image-20220417202219613.png" alt="image-20220417202219613"></p><h4 id="1-prepareRefresh：准备上下文环境"><a href="#1-prepareRefresh：准备上下文环境" class="headerlink" title="1. prepareRefresh：准备上下文环境"></a>1. prepareRefresh：准备上下文环境</h4><p>它其实并没有做什么，它里面先执行了一个<code>initPropertySources();</code>但是这个方法里面其实什么都没有实现，这是模板模式的体现，它会交给其它的子容器自行实现，自行在此处加载一些自己感兴趣的信息。</p><p>然后就是执行<code>getEnvironment().validateRequiredProperties();</code>，准备一些环境变量信息。</p><p>后续就是存储子容器早期运行的一些监听器，比如earlyApplicationListeners，然后还会初始化earlyApplicationEvents。</p><h4 id="2-obtainFreshBeanFactory-：创建工厂"><a href="#2-obtainFreshBeanFactory-：创建工厂" class="headerlink" title="2. obtainFreshBeanFactory()：创建工厂"></a>2. obtainFreshBeanFactory()：创建工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title function_">obtainFreshBeanFactory</span><span class="hljs-params">()</span> &#123;<br>    refreshBeanFactory(); <span class="hljs-comment">//刷新整个BeanFactory,注解模式下就是准备工厂，创建工厂，设置工厂id；xml模式下会解析xml</span><br>    <span class="hljs-keyword">return</span> getBeanFactory(); <span class="hljs-comment">// 调用this.beanFactory获取</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-prepareBeanFactory-beanFactory-：给工厂里面设置好必要的工具"><a href="#3-prepareBeanFactory-beanFactory-：给工厂里面设置好必要的工具" class="headerlink" title="3. prepareBeanFactory(beanFactory)：给工厂里面设置好必要的工具"></a>3. prepareBeanFactory(beanFactory)：给工厂里面设置好必要的工具</h4><p>该方法给容器中注册了环境信息作为单实例Bean方便后续自动装配；放了一些后置处理器处理（监听、xxAware功能）</p><p>比如给容器中添加一个后置处理器：<code>ApplicationContextAwareProcessor</code>，这个就是2.6章节中，用来处理Aware接口的后置处理器。</p><p><img src="image-20220417210033156.png" alt="image-20220417210033156"></p><h4 id="4-postProcessBeanFactory-beanFactory"><a href="#4-postProcessBeanFactory-beanFactory" class="headerlink" title="4. postProcessBeanFactory(beanFactory);"></a>4. postProcessBeanFactory(beanFactory);</h4><p>同样也是留给子类的模板方法，允许子类继续对工厂执行一些处理。</p><h4 id="5-【大核心】invokeBeanFactoryPostProcessors-beanFactory"><a href="#5-【大核心】invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="5. 【大核心】invokeBeanFactoryPostProcessors(beanFactory);"></a>5. 【大核心】invokeBeanFactoryPostProcessors(beanFactory);</h4><p>执行所有的BeanFactory后置增强器，利用后置增强器对工厂进行修改或增强，<strong>配置类会在这里进行解析</strong></p><p>上述章节对该方法以及进行过解析了，这里不再赘述。</p><p><img src="image-20220417210727525.png" alt="image-20220417210727525"></p><h4 id="6-【核心】registerBeanPostProcessors：注册所有的Bean的后置处理器"><a href="#6-【核心】registerBeanPostProcessors：注册所有的Bean的后置处理器" class="headerlink" title="6. 【核心】registerBeanPostProcessors：注册所有的Bean的后置处理器"></a>6. 【核心】registerBeanPostProcessors：注册所有的Bean的后置处理器</h4><p>它会将所有的BeanPostProcessor给保存到容器中，上述有章节也讲过，这里再说一句的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重新注册一下这个后置处理器 Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="hljs-comment">// 把他放到后置处理器的最后一位； moving it to the end of the processor chain (for picking up proxies etc).</span><br>beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(applicationContext));<br></code></pre></td></tr></table></figure><h4 id="7-initMessageSource-：初始化国际化功能"><a href="#7-initMessageSource-：初始化国际化功能" class="headerlink" title="7. initMessageSource()：初始化国际化功能"></a>7. initMessageSource()：初始化国际化功能</h4><ol><li>看容器中是否有MessageSource的定义信息</li><li>如果没有就注册一个默认的</li><li>把国际化组件（MessageSource）放到单例池中</li></ol><h4 id="8-initApplicationEventMulticaster：初始化事件多播功能（事件派发）"><a href="#8-initApplicationEventMulticaster：初始化事件多播功能（事件派发）" class="headerlink" title="8. initApplicationEventMulticaster：初始化事件多播功能（事件派发）"></a>8. initApplicationEventMulticaster：初始化事件多播功能（事件派发）</h4><ol><li>看容器中是否有applicationEventMulticaster的定义信息，按照id去找</li><li>如果没有就注册一个默认的</li><li>把事件多播器组件（ApplicationEventMulticaster）放到单例池中</li></ol><h4 id="9-onRefresh（）"><a href="#9-onRefresh（）" class="headerlink" title="9. onRefresh（）"></a>9. onRefresh（）</h4><p>留给子类继续增强处理逻辑</p><h4 id="10-registerListeners：注册监听器"><a href="#10-registerListeners：注册监听器" class="headerlink" title="10. registerListeners：注册监听器"></a>10. registerListeners：注册监听器</h4><ol><li>获取容器中定义的所有ApplicationListener</li><li>把这些ApplicationListener保存起来</li></ol><h4 id="11-【大核心】finishBeanFactoryInitialization：完成工厂初始化"><a href="#11-【大核心】finishBeanFactoryInitialization：完成工厂初始化" class="headerlink" title="11. 【大核心】finishBeanFactoryInitialization：完成工厂初始化"></a>11. 【大核心】finishBeanFactoryInitialization：完成工厂初始化</h4><p>参考Bean的初始化流程，所有的BeanPostProcessor开始工作，进行单个组件的功能增强，也会去执行所有后初始化操作。</p><h4 id="12-finishRefresh：最后的一些清理、事件发送等"><a href="#12-finishRefresh：最后的一些清理、事件发送等" class="headerlink" title="12. finishRefresh：最后的一些清理、事件发送等"></a>12. finishRefresh：最后的一些清理、事件发送等</h4><h4 id="13-完整流程图展示"><a href="#13-完整流程图展示" class="headerlink" title="13. 完整流程图展示"></a>13. 完整流程图展示</h4><p><img src="image-20220417193438277.png" alt="image-20220417193438277"></p><h2 id="第三章-循环依赖"><a href="#第三章-循环依赖" class="headerlink" title="第三章 循环依赖"></a>第三章 循环依赖</h2><h3 id="3-1-具体流程"><a href="#3-1-具体流程" class="headerlink" title="3.1 具体流程"></a>3.1 具体流程</h3><p>首先得知道的是，在Spring中，解决循环依赖问题，需要三级缓存。分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一级缓存，也叫单例池，存放已经经历了完整生命周期的Bean对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">// 第三级缓存，存放可以生成Bean的工厂</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">// 第二级缓存，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完成）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><ol><li>先想要对A进行实例化，调用getSingleton(beanName)依次从一级、二级、三级缓存中进行查询，但是都没有，返回null</li><li>调用getSingleton(beanName)的重载方法，该方法将该A的beanName添加到singletonsCurrentlyInCreation集合中之后，调用createBean方法中的doCreateBean方法， 先利用默认的无参构造器创建出A的实例，但是此时A并没有被初始化。<strong>然后将其先添加到【三级缓存】中（addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))）。注意的是，这里其实不是将A给放到三级缓存中，而是将一个工厂方法给传进去，到时候获取对象的时候，可以直接通过工厂方法返回早期暴露出来的Bean引用</strong>。</li><li>接着调用populateBean，想对A进行属性填充，此时<code>AutowiredAnnotationBeanPostProcessor</code>感知到A需要自动装配B，于是开始调用getBean来获取B。</li><li>和上述流程一样，一开始getSingleton(beanName)依次查找之后发现容器中并没有B，然后就将B的beanName添加到singletonsCurrentlyInCreation集合中，接着就会创建B，将其添加到【三级缓存】中。此时又发现B依赖于A，就又调用getBean方法来获取A。</li><li>它同样会去容器中查找A，从一级到二级到三级，发现三级中存在A的工厂方法，并且调用这个工厂来获取到A早期暴露出来的引用，然后将A给添加到二级缓存中，并且从三级缓存中删除A。</li><li>这样B就获取到了A的依赖，于是B就顺利的完成了赋值和初始化，然后会将B从singletonsCurrentlyInCreation集合中删除。并且将B给添加到【一级缓存】中，并且删掉二级和三级缓存中的B（如果存在的话）。</li><li>随后继续完成A的属性填充工作，将B给填充进去之后，A也完成了创建，随后继续执行，将A放到【一级缓存】中，并且删掉二级和三级缓存中的B（如果存在的话）。</li></ol><p><img src="image-20210924154224430.png" alt="循环依赖"></p><p><img src="%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg" alt="循环依赖"></p><h3 id="3-2-为什么需要二级缓存earlySingletonObjects"><a href="#3-2-为什么需要二级缓存earlySingletonObjects" class="headerlink" title="3.2 为什么需要二级缓存earlySingletonObjects"></a>3.2 为什么需要二级缓存earlySingletonObjects</h3><blockquote><p>如果只有一级缓存其实也能解决循环依赖问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); //三级缓存中的Bean也会被后置处理来增强，</span><br>addSingleton(beanName, getEarlyBeanReference(beanName, mbd, bean));<br></code></pre></td></tr></table></figure><p>我们修改源代码，让早期暴露出来的bean直接放入一级缓存中，然后最终发现其实也可以解决A和B的循环依赖问题。</p><p><strong>没有代理的情况下（getEarlyBeanReference返回原对象）去创建A</strong>：</p><ol><li>创建A的实例，放入一级缓存。</li><li>初始化A的时候发现需要依赖注入B，就去获取B的实例</li><li>创建B的实例并放入一级缓存。</li><li>初始化B的时候发现需要A，就去一级缓存中拿。</li><li>完成B的初始化，放入一级缓存中（此时A还只是实例化，未完成属性赋值和初始化）</li><li>回到第2步，A初始化完成，放入一级缓存。</li></ol><p><strong>那为什么还需要三级缓存呢？</strong></p><p>首先我们从单一职责的角度来说，如果我们将完整的和不完整的Bean都放入同一个集合中，就可能会引发未知的错误。因此就需要将他们给分离开来。</p><p>我们都知道，针对于A实例化之后，会将他放入到三级缓存singletonFactories中，保存的是以A的beanName为key，以一个执行getEarlyBeanReference方法的lambda表达式为value的map中。如果我们的A中的方法使用到了AOP，那么实际上单例池中保存的其实就是A的代理对象。 于是我们重新以AOP代理A的视角来看循环依赖。</p><p>还是一样的流程，一开始我们去容器中找A，发现找不到，就会去创建A，然后给三级缓存中添加了数据。在赋值过程中，发现依赖于B，于是去创建B，同样给三级缓存中放入B。然后在B创建过程中，发现需要A，就去容器中找，发现三级缓存中有，就会调用之前存入的lambda表达式，由该表达式创建A，然后将A放入到二级缓存，删除三级缓存中的A。但是如果没有二级缓存，也就是说我们每次获取A的时候都会从那个三级缓存中去执行getEarlyBeanReference方法。<strong>而这个方法在执行过程中，其实是调用了所有的SmartInstantiationAwareBeanPostProcessor的getEarlyBenaReference方法，正好AOP相关增强器就重写了这个方法，它会返回一个A的代理类对象，然后交给B。但问题就出现在这里，其实每次调用这个三级缓存中的方法的时候，都会去创建一个新的代理类对象，这就导致了A不是单例的。</strong>因此二级缓存尤为重要。</p><p>也可以看看这一篇博客：<a href="https://blog.csdn.net/weixin_45727359/article/details/114696668">(34条消息) 面试题：Spring 为何需要三级缓存解决循环依赖，而不是二级缓存？_公众号:肉眼品世界的博客-CSDN博客</a></p><h2 id="第四章-AOP源码分析"><a href="#第四章-AOP源码分析" class="headerlink" title="第四章 AOP源码分析"></a>第四章 AOP源码分析</h2><h3 id="4-0-动态代理原理"><a href="#4-0-动态代理原理" class="headerlink" title="4.0 动态代理原理"></a>4.0 动态代理原理</h3><h4 id="JDKProxy"><a href="#JDKProxy" class="headerlink" title="JDKProxy"></a>JDKProxy</h4><p>测试源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDKProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActionService</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getOrderCount</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActionServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionService</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrderCount</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;get order count...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ActionServiceImpl</span> <span class="hljs-variable">actionService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionServiceImpl</span>();<br><br>        <span class="hljs-type">ActionService</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (ActionService)Proxy.newProxyInstance(JDKProxyTest.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ActionService.class&#125;, (p, method, param) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;before....&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(actionService, param);<br>            System.out.println(<span class="hljs-string">&quot;after....&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;);<br><br>        System.out.println(proxyInstance.getOrderCount());<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Arthas反编译代理类得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$Proxy0</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JDKProxyTest</span>.ActionService &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-built_in">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);<br>            m3 = Class.forName(<span class="hljs-string">&quot;top.noaharno.springcache.JDKProxyTest$ActionService&quot;</span>).getMethod(<span class="hljs-string">&quot;getOrderCount&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;object&#125;);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m2, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m0, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrderCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(throwable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但其实对于JDK自带的动态代理来说，它其实并没有在运行期间生成这些代码，而是直接通过asm来生成字节码，上述代码是我们将字节码反编译得到的。</p><h3 id="4-1-配置调试环境"><a href="#4-1-配置调试环境" class="headerlink" title="4.1 配置调试环境"></a>4.1 配置调试环境</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span> <span class="hljs-comment">//开启自动代理</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopOpenConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//切面存在的化就会返回代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloService</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;HelloService....&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好：&quot;</span>+name;<br>System.out.println(result);<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> name.length();<br><span class="hljs-keyword">return</span> result + <span class="hljs-string">&quot;---&quot;</span> + length;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//切面也是容器中的组件</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">//说明这是切面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogAspect</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//前置通知  增强方法/增强器</span><br>    <span class="hljs-meta">@Before(&quot;execution(* com.atguigu.spring.aop.HelloService.sayHello(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logStart</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        System.out.println(<span class="hljs-string">&quot;logStart()==&gt;&quot;</span>+name+<span class="hljs-string">&quot;....【args: &quot;</span>+ Arrays.asList(joinPoint.getArgs()) +<span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//返回通知</span><br>    <span class="hljs-meta">@AfterReturning(value = &quot;execution(* com.atguigu.spring.aop.HelloService.sayHello(..))&quot;,returning = &quot;result&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logReturn</span><span class="hljs-params">(JoinPoint joinPoint,Object result)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        System.out.println(<span class="hljs-string">&quot;logReturn()==&gt;&quot;</span>+name+<span class="hljs-string">&quot;....【args: &quot;</span>+ Arrays.asList(joinPoint.getArgs()) +<span class="hljs-string">&quot;】【result: &quot;</span>+result+<span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//后置通知</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.atguigu.spring.aop.HelloService.sayHello(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logEnd</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        System.out.println(<span class="hljs-string">&quot;logEnd()==&gt;&quot;</span>+name+<span class="hljs-string">&quot;....【args: &quot;</span>+ Arrays.asList(joinPoint.getArgs()) +<span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">//异常</span><br>    <span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring.aop.HelloService.sayHello(..))&quot;,throwing = &quot;e&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logError</span><span class="hljs-params">(JoinPoint joinPoint,Exception e)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        System.out.println(<span class="hljs-string">&quot;logError()==&gt;&quot;</span>+name+<span class="hljs-string">&quot;....【args: &quot;</span>+ Arrays.asList(joinPoint.getArgs()) +<span class="hljs-string">&quot;】【exception: &quot;</span>+e+<span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br>    <span class="hljs-comment">//AOP,原理测试</span><br>    <span class="hljs-type">HelloService</span> <span class="hljs-variable">helloService</span> <span class="hljs-operator">=</span> applicationContext.getBean(HelloService.class);<br>    helloService.sayHello(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-系统中如何添加AOP功能？"><a href="#4-2-系统中如何添加AOP功能？" class="headerlink" title="4.2 系统中如何添加AOP功能？"></a>4.2 系统中如何添加AOP功能？</h3><p>我们先点开@EnableAspectJAutoProxy，可以看到它其实导入了一个类：<code>@Import(AspectJAutoProxyRegistrar.class)</code>。在容器刷新十二大流程中的工厂增强环境，<strong>ConfigurationClassPostProcessor</strong>会进行工作，它解析所有的配置类，比如这里它开始解析AopOpenConfig，然后发现它上面有一个@Import注解，就会调用loadBeanDefinitionsFromRegistrars方法来处理@Import注解。<strong>最终就会调用Import上的AspectJAutoProxyRegistrar中的registerBeanDefinitions方法</strong>。因为AspectJAutoProxyRegistrar其实是实现了ImportBeanDefinitionRegistrar接口。</p><p>在AspectJAutoProxyRegistrar中的registerBeanDefinitions方法中，它的核心方法其实就是<code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</code>注册切面的基于注解的自动代理的创建器。它的内部其实就是注册了一个类：<strong>AnnotationAwareAspectJAutoProxyCreator。</strong>它的类图如下图所示：</p><p><img src="image-20220418134537802.png" alt="image-20220418134537802"></p><p>从这个图就可以看到，AnnotationAwareAspectJAutoProxyCreator其实就i是一个BeanPostProcessor，它会干预到 Bean的创建流程中。</p><p><img src="image-20220418133651905.png" alt="image-20220418133651905"></p><h3 id="4-3-AnnotationAwareAspectJAutoProxyCreator运行流程"><a href="#4-3-AnnotationAwareAspectJAutoProxyCreator运行流程" class="headerlink" title="4.3 AnnotationAwareAspectJAutoProxyCreator运行流程"></a>4.3 AnnotationAwareAspectJAutoProxyCreator运行流程</h3><p>首先AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor，它会在容器刷新十二步中的registerBeaenPostProcessor中被创建出来。然后调用<strong>initialBean</strong>方法进行初始化的时候，正好这个后置处理器<strong>实现了BeanClassLoaderAware、BeanFactoryAware接口，就会进行一个Aware执行：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(String beanName, Object bean)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>            ((BeanNameAware) bean).setBeanName(beanName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bcl</span> <span class="hljs-operator">=</span> getBeanClassLoader();<br>            <span class="hljs-keyword">if</span> (bcl != <span class="hljs-literal">null</span>) &#123;<br>                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后它就会执行BeanFactoryAware的setBeanFactory方法，而且值得注意的是，<strong>BeanFactoryAware的实现类AbstractAdvisorAutoProxyCreator它重写了该方法，并且在里面调用了initBeanFactory方法，同时，它的子类也会继续重写该方法，最终就是执行了我们的AnnotationAwareAspectJAutoProxyCreator的initBeanFactory方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-comment">// BeanFactoryAware 来的。 当前后置处理器初始化创建对象的时候回调的</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-built_in">super</span>.initBeanFactory(beanFactory);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.aspectJAdvisorFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.aspectJAdvisorFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveAspectJAdvisorFactory</span>(beanFactory); <span class="hljs-comment">//准备一个ReflectiveAspectJAdvisorFactory</span><br>    &#125;<br>    <span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryAspectJAdvisorsBuilderAdapter</span>(beanFactory, <span class="hljs-built_in">this</span>.aspectJAdvisorFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它会给这个后置增强器添加aspectJAdvisorFactory和aspectJAdvisorsBuilder。</p><p>至此，我们的这个AnnotationAwareAspectJAutoProxyCreator就创建完成并放入容器中了。</p><p>然后就会接着走后续的初始化整个beanFactory流程。我们之前的章节在分析bean的创建过程的时候，即调用createBean方法的时候，Spring会给我们一个机会去返回该组件的代理对象，也就是<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>它执行的就是<strong>InstantiationAwareBeanPostProcessor</strong>后置处理器中的postProcessBeforeInstantiation方法，如果这个方法返回的结果不是null，Spring就不会帮我们去创建组件，而是去使用这个方法返回的组件。</p><p>同时我们又知道，我们的AnnotationAwareAspectJAutoProxyCreator实现了AbstractAutoProxyCreator接口，而该接口又实现了InstantiationAwareBeanPostProcessor接口，并且对postProcessorBeforeInstantiation方法进行了重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(beanClass, beanName);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123; <span class="hljs-comment">//已经分析过的组件内</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-comment">//所有增强了的组件会被缓存在advisedBeans，如果我们需要增强的bean，我们就放在缓存中</span><br>        <span class="hljs-comment">// ⭐重点是下面这两个方法，放到接下来去分析</span><br>        <span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>            <span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//创建个代理 Create proxy here if we have a custom TargetSource.</span><br>    <span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span><br>    <span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span><br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> getCustomTargetSource(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (targetSource != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>            <span class="hljs-built_in">this</span>.targetSourcedBeans.add(beanName);<br>        &#125;<br>        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>        <span class="hljs-built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个postProcessBeforeInstantiation方法内部调用了<code>isInfrastructureClass(beanClass)</code>方法，这个方法它由AnnotationAwareAspectJAutoProxyCreator进行了重写，<strong>主要作用是判断当前的bean是否是一个切面，即判断当前类它是否被@Aspect注解所标注</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> &#123;<br>    <span class="hljs-comment">// 判断是否切面</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">super</span>.isInfrastructureClass(beanClass) ||<br>            (<span class="hljs-built_in">this</span>.aspectJAdvisorFactory != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));<br>&#125;<br></code></pre></td></tr></table></figure><p>除了当前bean标注了Aspect注解用以表明它是一个切面，如果它不是一个切面，就继续<strong>判断是否需要跳过当前类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//判断是否需要跳过当前类</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span><br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();  <span class="hljs-comment">//找到候选的增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>在判断该类是否需要跳过的时候，它会先去找到所有的候选的增强器，也就是执行<code>findCandidateAdvisors</code>方法，在这个方法里面，它会去调用父类的findCandidateAdvisors方法，一般而言，我们在对bean挨个创建的时候，第一次进来的时候它返回的都是null。接着如果此时aspectJAdvisorsBuilder不为null（注意，这个aspectJAdvisorsBuilder在执行BeanFactoryAware的时候就已经被设置进去了），他就会往advisors中进行添加。具体如下面方法所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//找到候选的增强器。</span><br><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title function_">findCandidateAdvisors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules. 判断这个bean是否需要增强只需要找到他的所有增强器</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-built_in">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// 构建增强器？？？？ Build Advisors for all AspectJ aspects in the bean factory.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//增强器的构建器只要有</span><br>        advisors.addAll(<span class="hljs-built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行构建的时候，即执行<code>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</code>的时候，如果它是第一次进来，Spring就会获取容器中所有的Object类型的组件，然后挨个判断它是否是切面，即是否有@Aspect，然后将是切面的组件放到一个集合中，紧接着就会遍历所有的切面， 将它们内部的增强器都添加到一个集合中。</p><p>也就是说，在初始化完AnnotationAwareAspectJAutoProxyCreator后置处理器之后，进入到beanFactory的初始化流程中，然后在第一个bean初始化过程中，我们就已经将所有的切面都添加到了容器中，并且进行了增强器（advisor）的构建，即哪些切面中有哪些方法什么时候运行。在advisorsCache（Map&lt;String, List&lt; Advisor&gt;&gt;）中保存了增强器（通知方法）。</p><p><strong>⭐至于如何在第一次bean初始化过程中构建增强器，再来详细讲述：</strong></p><ol><li>拿到容器中所有的beanNames，然后依次遍历</li><li>获取当前beanName所属于的类型，然后判断该类是否标注了@Aspect注解，如果没有就continue，判断下一个beanName。</li><li>如果当前beanName的beanType有@Aspect注解的话，首先将其添加到this.aspectBeanNames中，即该容器中保存了所有的切面的类的beanName。</li><li>然后就利用当前类中的beanFactory和切面的beanName构建一个BeanFactoryAspectInstanceFactory，利用这个factory来获取到这个切面中的所有的增强器。</li><li>然后将获取到的所有的增强器都添加到advisorsCache中进行保存，方便后续使用。</li></ol><p><strong>⭐再来详细讲述如何从一个切面中获取到它里面的所有的增强器：</strong></p><ol><li>利用反射获取当前切面中的所有的方法</li><li>看当前方法是否是通知方法：<code>Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</code></li><li>将每个通知方法都封装成Advisor即增强器。</li><li>每个增强器都是InstantiationModelAwarePointcutAdvisorImpl。</li></ol><h3 id="4-4-如何创建需要被增强的方法所属的类？"><a href="#4-4-如何创建需要被增强的方法所属的类？" class="headerlink" title="4.4 如何创建需要被增强的方法所属的类？"></a>4.4 如何创建需要被增强的方法所属的类？</h3><p>在我们本次案例中，针对HelloService类中的sayHello进行了代理增强。那么在Spring的容器中，HelloService是以什么样的形式存在的呢？</p><p>对于HelloService的创建，在它创建之前，它会去执行<code>AbstractAutoProxyCreator(实现了InstantiationAwareBeanPostProcessor接口).postProcessBeforeInstantiation</code>后置处理器的处理方法，在这个方法中，它会去判断HelloService是否是切面（false）、判断是否可以跳过，在判断跳过的逻辑中，它先去获取到所有切面的所有增强器（这个在我们第一次创建bean的时候就已经将所有的增强器给放入到advisorsCache中了），然后看这个类是否属于特殊类。结果HelloService都不满足，因此返回null，也就是什么都没做。</p><p>后续的流程其实顺风顺水，AnnotationAwareAspectJAutoProxyCreator其实并没有过多的干预，但是等到HelloService初始化完之后，执行<strong>BeanPostProcessor.postProcessAfterInitialization。</strong>即在initializeBean方法的末尾执行该后置增强器，然后就会返回代理对象。当然，当这个方法执行完毕之后，singletonFactories中的lambda表达式还是没有执行，还得看后续流程。当整体创建完成之后，Spring会去判断当前的组件是否是新建的，显而易见是的，因此就会将上述使用initialBean创建好的代理对象给放入一级缓存单例池中，然后删掉三级缓存中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>它内部的所有实现细节其实就是挨个判断所有的增强器的正则是否能够切入这个helloService对象，然后将结果添加到eligibleAdvisors（合适的增强器）集合中。紧接着它就会想要创建一个<code>ExposeInvocationINterceptor拦截器</code>，并将其添加到eligibleAdvisors中的最开始的位置，添加完之后对整个集合进行排序，最终eligibleAdvisors中保存的元素如下图所示：</p><p><img src="image-20220418201402660.png" alt="image-20220418201402660"></p><p>这时候所有的增强器就返回了，也就是eligibleAdvisors，但是postProcessAfterInitialization还未结束。然后就会拿着能适用于HelloService的增强器，创建HelloService的代理对象。由于HelloService并没有实现什么接口，因此使用CGlib来创建代理对象。最终代理对象如下图所示：</p><p><img src="image-20220418202338136.png" alt="image-20220418202338136"></p><p>最终我们的Spring容器中的单例池中就保存了helloService，只不过它所对于的value是一个代理对象。</p><h3 id="4-5-AOP链式执行流程"><a href="#4-5-AOP链式执行流程" class="headerlink" title="4.5 AOP链式执行流程"></a>4.5 AOP链式执行流程</h3><p>对于我们创建好的helloService，它保存的是代理对象，于是我们在执行helloService.sayHello(“zhangsan”);方法的时候，整体流程和平时不太一样。</p><p>在我们执行sayHello方法的时候，其实调用的是CglibAopProxy中的DynamicAdvisedInterceptor类中的intercept方法，至于为什么调用这个方法，是因为在我们使用cglib进行增强的时候，设置了CallBack，而CallBack其实传入的是一个MethodInterceptor，正好我们的DynamicAdvisedInterceptor就实现了MethodInterceptor。</p><p>这个interccept方法首先利用目标方法和目标类将上一步在创建需要被增强的方法所属的类中创建出的helloService的五个增强器给转换为拦截器，即把所有的增强器再转换为真正的拦截器，这是因为增强器中只是保存了信息，而拦截器是能够真正执行目标方法。最终构建好的五个拦截器如下图所示：</p><p><img src="image-20220418212517570.png" alt="image-20220418212517570"></p><p>创建好拦截器之后，首先将所有的信息封装成一个CglibMethodInvocation类，<code>new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)</code>，包括helloService的代理、真实对象、增强器链、当前方法、使用的参数等等，这就是<strong>FilterChain类</strong></p><p>当创建好这个类之后，就调用它的proceed方法进行执行。后续的流程如下图所示：</p><p><img src="AOP%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="AOP链式调用过程"></p><h2 id="第五章-监听器（事件原理）"><a href="#第五章-监听器（事件原理）" class="headerlink" title="第五章 监听器（事件原理）"></a>第五章 监听器（事件原理）</h2><h3 id="5-1-环境准备"><a href="#5-1-环境准备" class="headerlink" title="5.1 环境准备"></a>5.1 环境准备</h3><p>监听器使用：</p><ol><li>自定义组件装配ApplicationContext或者ApplicationEventMulticaster可以派发事件。</li><li>自定义组件实现ApplicationListener或者使用@EventListener标注在方法上可以接受事件。</li><li>publish的Object对象会被认为是自定义事件，也可以定义事件（通过实现ApplicationEvent）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事件监听器；为什么一个注解就能监听来事件。。。。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppEventListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AppEventListener</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AppEventListener...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@EventListener(MessageEvent.class)</span> <span class="hljs-comment">//监听事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenMessage</span><span class="hljs-params">(MessageEvent event)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Message事件到达...&quot;</span>+event+<span class="hljs-string">&quot;；已发送邮件....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@EventListener(ChangeEvent.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenChange</span><span class="hljs-params">(ChangeEvent event)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Change事件到达...&quot;</span>+event+<span class="hljs-string">&quot;；已同步状态....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@EventListener(PayloadApplicationEvent.class)</span> <span class="hljs-comment">//感知任意对象事件的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenPayload</span><span class="hljs-params">(PayloadApplicationEvent&lt;A&gt; event)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Payload事件到达...&quot;</span>+event.getPayload()+<span class="hljs-string">&quot;；已进行处理....&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 事件发布器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppEventPublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventPublisherAware</span> &#123;<br><br>    ApplicationEventPublisher eventPublisher;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AppEventPublisher</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AppEventPublisher....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;<br>        <span class="hljs-built_in">this</span>.eventPublisher = applicationEventPublisher;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(ApplicationEvent applicationEvent)</span>&#123;<br>        eventPublisher.publishEvent(applicationEvent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 事件需要实现序列化接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">private</span> String state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ChangeEvent</span><span class="hljs-params">(Object source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChangeEvent</span><span class="hljs-params">(Object source,String state)</span>&#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ChangeEvent&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;state=&#x27;&quot;</span> + state + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, source=&quot;</span> + source +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 事件需要实现序列化接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageEvent</span><span class="hljs-params">(String source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MessageEvent&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;, source=&quot;</span> + source +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);<br><br>    <span class="hljs-comment">//测试事件</span><br>    <span class="hljs-type">AppEventPublisher</span> <span class="hljs-variable">eventPublisher</span> <span class="hljs-operator">=</span> applicationContext.getBean(AppEventPublisher.class);<br>    <span class="hljs-comment">//    eventPublisher.publish(new A());</span><br>    eventPublisher.publish(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageEvent</span>(<span class="hljs-string">&quot;hello，你好&quot;</span>));<br>    eventPublisher.publish(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeEvent</span>(eventPublisher,<span class="hljs-string">&quot;sending...&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h3><p>首先IOC容器在this()阶段， 其实往容器的beanDefinitionMap中添加了一些原生的定义信息，这里面就包含了两个事件有关的后置处理器：<strong>EventListenerMethodProcessor和DefaultEventListenerFactory</strong></p><p><img src="image-20220418215230755.png" alt="image-20220418215230755"></p><p>可以看到，我们的EventListenerMethodProcessor其实是实现了两种接口：<strong>SmartInitializingSingleton和BeanFactoryPostProcessor</strong>，这就表明了<strong>它会在工厂后置处理环节执行，用来执行工厂增强；还会在所有的Bean都创建完之后，循环挨个判断这些bean是否实现了SmartInitializingSingleton接口，如果实现了就调用该接口的afterSingletonsInstantiated方法。</strong></p><p>在工厂后置增强环节，它会把容器中所有的DefaultEventListenerFactory拿来排个序并保存。</p><p>在最后的初始化环节：</p><ol><li>拿到容器中所有组件</li><li>处理这个组件<ol><li>找到组件中所有@EventListener标注的方法</li><li>遍历每个方法，先拿到所有的DefaultEventListenerFactory，然后把当前方法，beanName等封装到<strong>适配器</strong>中，即<code>ApplicationListenerMethodAdapter(beanName,beanType,method)</code>。为每个方法都创建一个适配器（ApplicationListenerMethodApdater）。</li><li>把这个适配器（它也是监听器）放到了容器（applicationListeners）中和事件多播器（applicationEventMulticaster）中。</li></ol></li><li>事件派发给的是适配器，适配器利用反射调用自己组件的事件监听方法。</li></ol><p><img src="image-20220418220751089.png" alt="image-20220418220751089"></p><p><img src="image-20220418221041589.png" alt="image-20220418221041589"></p><p><strong>在事件的派发过程中，即eventPublisher.publish(new MessageEvent(“hello，你好”))方法，它会按照发送的事件的类型，如果它是实现了ApplicationEvent接口，就将该事件转换为ApplicationEvent。如果该对象没有实现该接口，就将其用PayloadApplicationEvent进行封装，最后执行的时候，它会拿到事件多播器，用它来发送事件。至于怎么发送事件，它会利用观察者模式（for遍历），将符合event和type的ApplicationListenerMethodAdapter拿来，然后依次调用它们的invokeListener方法即可。</strong></p><p><img src="image-20220418213441154.png" alt="image-20220418213441154"></p><h2 id="第六章-事务"><a href="#第六章-事务" class="headerlink" title="第六章 事务"></a>第六章 事务</h2><h3 id="6-1-环境准备"><a href="#6-1-环境准备" class="headerlink" title="6.1 环境准备"></a>6.1 环境准备</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并且配置文件中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://192.168.235.123:3306/enjoy_applet?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><h3 id="6-2-EnableTransactionManagement"><a href="#6-2-EnableTransactionManagement" class="headerlink" title="6.2 EnableTransactionManagement"></a>6.2 EnableTransactionManagement</h3><p>使用该注解，就相当于引入了spring事务相关的功能，它内部其实是通过Import注解引入了<strong>TransactionManagementConfigurationSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;TransactionManagementConfigurationSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTransactionManagement &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 默认是代理模式，当然也可以选择ASPECTJ</span><br>    AdviceMode <span class="hljs-title function_">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY;<br><span class="hljs-comment">// 代表它在初始化的时候的顺序</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">2147483647</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220921114729168.png" alt="image-20220921114729168"></p><p>而在我们引入的Selector类中，核心看下面的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;<br>    <span class="hljs-keyword">switch</span> (adviceMode) &#123;<br>        <span class="hljs-keyword">case</span> PROXY:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),<br>                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;<br>        <span class="hljs-keyword">case</span> ASPECTJ:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，其实它内部导入了<strong>AutoProxyRegistrar和ProxyTransactionManagementConfiguration</strong>两个类，当然，现在并不是说直接引入了bean，而是将它们的名称返回，以待后续向容器中添加它们的beanDefinition，然后后续再实例化操作。</p><p>对于<strong>AutoProxyRegistrar</strong>来说，它其实是获取@EnableTransactionManagement注解中的mode属性和proxyTargetClass属性的值，然后<strong>向容器中注入InfrastructureAdvisorAutoProxyCreator</strong>，它其实实现了BeanPostProcessor接口，所有的bean后面在初始化的时候会执行相应的处理器。</p><p>这一步流程其实和AOP的实现差不多一致，同样是向容器中注入对应的后置处理器。 但是也只是暂时将其对应的beanDefinition注册到bean工厂中。</p><p>而对于<strong>ProxyTransactionManagementConfiguration</strong>来说，它其实也是向容器中注入了一些事务相关的bean，比如：</p><ul><li>事务增强器：BeanFactoryTransactionAttributeSourceAdvisor，事务增强器，包含了切面组件和标签解析器</li><li>标签解析器：TransactionAttributeSource，@Transaction注解标签解析器</li><li>事务拦截器Bean：TransactionInterceptor，这个类是Spring事务拦截器的核心业务实现，AOP调用链最终也是触发它的invoke方法。保存了事务属性信息，事务管理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTransactionManagementConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title function_">transactionAdvisor</span><span class="hljs-params">(</span><br><span class="hljs-params">        TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> &#123;<br><br>        <span class="hljs-type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();<br>        <span class="hljs-comment">// 注入事务配置属性Bean</span><br>        advisor.setTransactionAttributeSource(transactionAttributeSource);<br>        advisor.setAdvice(transactionInterceptor); <span class="hljs-comment">// 注入依赖的拦截器</span><br>        <span class="hljs-comment">// 设置切面的顺序</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableTx != <span class="hljs-literal">null</span>) &#123;<br>            advisor.setOrder(<span class="hljs-built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> advisor;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title function_">transactionAttributeSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTransactionAttributeSource</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br>    <span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title function_">transactionInterceptor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;<br>        <span class="hljs-type">TransactionInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>();<br>        interceptor.setTransactionAttributeSource(transactionAttributeSource);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.txManager != <span class="hljs-literal">null</span>) &#123;<br>            interceptor.setTransactionManager(<span class="hljs-built_in">this</span>.txManager);<br>        &#125;<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总览设计模式</title>
    <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%80%BB%E8%A7%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%80%BB%E8%A7%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="第零章-总览"><a href="#第零章-总览" class="headerlink" title="第零章 总览"></a>第零章 总览</h2><p><img src="image-20211219120505207.png" alt="image-20211219120505207"></p><p><strong>设计模式的七大原则</strong></p><ol><li>开闭原则（Open Closed Principle）：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension, but closed for modification）；合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范；<strong>扩展新类而不是修改旧类</strong></li><li>里氏替换原则（Liskov Substitution Principle）：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）；<strong>继承父类而不去改变父类</strong></li><li>合成复用原则（Composite Reuse Principle）：又叫组合&#x2F;聚合复用原则（Composition&#x2F;Aggregate Reuse Principle）；软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现；<strong>优先组合，其次继承</strong></li><li>迪米特法则（Law of Demeter）：最少知识原则（Least Knowledge Principle）；只跟你的直接朋友交谈，不跟陌生人说话（Talk only to your immediate friends and not to strangers）；<strong>无需直接交互的两个类，如果需要交互，使用中间者</strong>；过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低</li><li>接口隔离原则（Interface Segregation Principle）：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）；<strong>各个类建立自己的专用接口，而不是建立万能接口</strong></li><li>依赖倒置原则（Dependence Inversion Principle）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions）；<strong>面向接口编程，而不是面向实现类</strong></li><li>单一职责原则（Single Responsibility Principle）：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）；<strong>每个类只负责自己的事情，而不是变成万能</strong></li></ol><h2 id="第一章-创建型模式"><a href="#第一章-创建型模式" class="headerlink" title="第一章 创建型模式"></a>第一章 创建型模式</h2><p><strong>为什么用创建型模式？</strong></p><ul><li>创建型模式关注点<strong>怎样创建出对象</strong></li><li><strong>将对象的创建与使用分离</strong></li><li>降低系统的耦合度</li><li>使用者无需关注对象的创建细节<ul><li>对象的创建由相关的工厂来完成：工厂模式</li><li>对象的创建由一个建造者来完成：建造者模式</li><li>对象的创建由原来对象克隆完成：原型模式</li><li>对象始终在系统中只有一个实例：单例模式</li></ul></li></ul><h3 id="1-1-单例（Singleton）模式"><a href="#1-1-单例（Singleton）模式" class="headerlink" title="1.1 单例（Singleton）模式"></a>1.1 单例（Singleton）模式</h3><p>一个单一的类，负责创建自己的对象，同时确保系统中只有单个对象被创建。</p><p>单例特点：</p><ul><li>某个类只能有一个实例：构造器私有</li><li>它必须自行创建这个实例：自己编写实例化逻辑</li><li>它必须自行向整个系统提供这个实例：对外提供实例化方法</li></ul><p>应用场景：</p><ul><li>多线程中的线程池</li><li>数据库中的连接池</li><li>系统环境信息</li><li>上下文（ServletContext）</li><li>…</li></ul><p>面试问题：</p><ul><li>系统环境信息（System.getProperties()）？</li><li>Spring中怎么保持组件单例的</li><li>ServletContext是什么？是单例吗？怎么保证的？</li><li>ApplicationContext是什么？</li><li>数据库连接池一般是怎么创建出来的，怎么保证单例？</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Person instance;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Personn</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 构造器私有化u</span><br>&#125;<br><br><span class="hljs-comment">// 提供给外部的方法</span><br><span class="hljs-comment">// 1、锁加载方法上，但是锁太大，效率低</span><br><span class="hljs-comment">// 2、双重检查锁 + 内存可见性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">synchronized</span> (Person.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-原型（Prototype）模式"><a href="#1-2-原型（Prototype）模式" class="headerlink" title="1.2 原型（Prototype）模式"></a>1.2 原型（Prototype）模式</h3><ol><li>原型模式是用于创建重复的对象，同时又能保证性能</li><li>本体给外部提供一个克隆体进行使用</li><li>使用场景：<ul><li>资源优化</li><li>性能和安全要求</li><li>一个对象多个修改者的场景</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以考虑使用原型模式拷贝多个对象供调用者使用</li><li>深拷贝和浅拷贝</li></ul></li></ol><p>使用场景模拟：如果我们要自己写一个自己的mybatis框架，考虑到在进行查询的时候，在大多数情况下，我们查询到的数据应该是不怎么改变的。例如，如果我们查询一种商品信息：new Product(“…”)，然后需要查询一千次的话，系统里面就会有一千个内容相同的product对象，浪费内存；</p><p>因此就可以使用原型模式来解决，也就是可以使用缓存，将查过的数据进行保存，如果再查相同的数据，就拿到原来的原型对象的克隆对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    <span class="hljs-comment">// 也可以使用其余的更加高效的方式实现克隆</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUsername(username);<br>        user.setAge(age);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLFMybatis</span> &#123;<br>    <span class="hljs-comment">// 缓存user</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, User&gt; userCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!userCache.containsKey(username)) &#123;<br>            <span class="hljs-comment">// 查询数据库</span><br>            user = getUserFromDb(username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从缓存种直接拿数据的话会造成脏缓存问题</span><br>            <span class="hljs-comment">// 拿到原型，但是不能直接给，应该给克隆体</span><br>            user = userCache.get(username);<br>            user = (User) userr.clone();<br>        &#125;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> User <span class="hljs-title function_">getUserFromDb</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUsername(username);<br>        <span class="hljs-comment">// 给缓存中放一个clone，不然第一次查询数据库的时候返回的对象是原型</span><br>        userCache.put(username, (User) user.clone());<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-工厂（Factory）模式"><a href="#1-3-工厂（Factory）模式" class="headerlink" title="1.3 工厂（Factory）模式"></a>1.3 工厂（Factory）模式</h3><p>工厂模式提供了一种创建对象的最佳方式。我们不必关系对象的创建细节，只需要根据不同情况获取不同产品即可。</p><p>应用场景：</p><ul><li>NumberFormat、SimpleDateFormat</li><li>LoggerFactory</li><li>SqlSessionFactory</li><li>BeanFactory：Spring中的，就是为了造出bean</li></ul><h4 id="1-3-1-简单工厂（Simple-Factory）"><a href="#1-3-1-简单工厂（Simple-Factory）" class="headerlink" title="1.3.1 简单工厂（Simple Factory）"></a>1.3.1 简单工厂（Simple Factory）</h4><p>比如我们有一个能生产van和mini两种车的工厂，就可以通过这个工厂来创建对应的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type  如果使用Class进行反射: 好像具有扩展性，但是没有解决实际问题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> AbstractCar <span class="hljs-title function_">newCar</span><span class="hljs-params">(String type)</span>&#123;<br><br>    <span class="hljs-comment">//核心方法：一切从简</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;van&quot;</span>.equals(type))&#123;<br>        <span class="hljs-comment">// 如果后续还得用钣金、喷漆、放发动机、申请环保，因此class也不太好使</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VanCar</span>();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;mini&quot;</span>.equals(type))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCar</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//.....</span><br><br>    <span class="hljs-comment">//更多的产品，违反开闭原则。应该直接扩展出一个类来造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20211219203456018.png" alt="image-20211219203456018"></p><p>缺点：违背开闭，扩展不易；如果想要该工厂创建更多的类，就得不停的使用if和else</p><h4 id="1-3-2-工厂方法（Factory-Method）"><a href="#1-3-2-工厂方法（Factory-Method）" class="headerlink" title="1.3.2 工厂方法（Factory Method）"></a>1.3.2 工厂方法（Factory Method）</h4><p><img src="image-20211219203608238.png" alt="image-20211219203608238"></p><p>如图所示，我们可以将工厂给抽象出来，然后给每种类都分别创建一个单独的工厂，这样扩展性增加。</p><p>缺点：系统复杂度增加，产品单一。每想要增加一个类，就得多一个工厂。</p><h4 id="1-3-3-抽象工厂（Abstract-Factory）"><a href="#1-3-3-抽象工厂（Abstract-Factory）" class="headerlink" title="1.3.3 抽象工厂（Abstract Factory）"></a>1.3.3 抽象工厂（Abstract Factory）</h4><p>如果我们想要生产手机、汽车、口罩等等，而且手机有小米手机、华为手机等，汽车有货车、私家车等。</p><p><img src="image-20211219204303827.png" alt="image-20211219204303827"></p><p>其实还可以进行抽象，WuLinFactory下面有WulinMaskFactory和WulinCarFactory，然后每种工厂都生产各自的东西。</p><p><img src="image-20211219204813862.png" alt="image-20211219204813862"></p><p><strong>工厂模式的退化</strong></p><p>当抽象工厂模式中的<strong>每一个具体工厂类只创建一个产品对象</strong>，也就是只存在一个产品等级结构时，<strong>抽象工厂模式退化成工厂方法模式</strong>；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，<strong>工厂方法模式退化成简单工厂模式</strong>。</p><h3 id="1-4-建造者（Builder）模式"><a href="#1-4-建造者（Builder）模式" class="headerlink" title="1.4 建造者（Builder）模式"></a>1.4 建造者（Builder）模式</h3><p>每一个建造小细节都可以传入，但是都不是必须；<strong>如果是必须，就构造器强制。</strong></p><p>创建的东西细节复杂，还必须暴露给使用者。<strong>屏蔽过程而不屏蔽细节</strong></p><p><img src="image-20211219211043722.png" alt="image-20211219211043722"></p><p>如果我们想要创建手机实例，就可以不通过new Phone的方式创建，而是通实现AbstractPhoneBuilder来创建实例。因为不同种类的手机有不同的实现细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象构造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBuilder</span> &#123;<br>    Phone phone;<br>    <span class="hljs-keyword">abstract</span> AbstractBuilder <span class="hljs-title function_">customCpu</span><span class="hljs-params">(String cpu)</span>;<br>    <span class="hljs-keyword">abstract</span> AbstractBuilder <span class="hljs-title function_">customMem</span><span class="hljs-params">(String mem)</span>;<br>    <span class="hljs-keyword">abstract</span> AbstractBuilder <span class="hljs-title function_">customDisk</span><span class="hljs-params">(String disk)</span>;<br>    <span class="hljs-keyword">abstract</span> AbstractBuilder <span class="hljs-title function_">customCam</span><span class="hljs-params">(String cam)</span>;<br><br>    <span class="hljs-comment">// 获取创建好的phone</span><br>    <span class="hljs-comment">// 实际上返回的应该是不同的对象</span><br>    Phone <span class="hljs-title function_">getProduct</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phone;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 具体构造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoMiBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractBuilder</span> &#123;<br>    <span class="hljs-comment">// 具体的细节暂不考虑，比如通过这个builder返回所有phone都将是同一对象，应该修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">XiaoMiBuilder</span><span class="hljs-params">()</span> &#123;<br>        phone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    AbstractBuilder <span class="hljs-title function_">customCpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>        phone.cpu = cpu;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    AbstractBuilder <span class="hljs-title function_">customMem</span><span class="hljs-params">(String mem)</span> &#123;<br>        phone.mem = mem;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    AbstractBuilder <span class="hljs-title function_">customDisk</span><span class="hljs-params">(String disk)</span> &#123;<br>        phone.disk = disk;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    AbstractBuilder <span class="hljs-title function_">customCam</span><span class="hljs-params">(String cam)</span> &#123;<br>        phone.cam = cam;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AbstractBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoMiBuilder</span>();<br>    <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> builder.customCpu(<span class="hljs-string">&quot;骁龙8个8&quot;</span>)<br>        .customCam(<span class="hljs-string">&quot;2亿&quot;</span>)<br>        .customDisk(<span class="hljs-string">&quot;1T&quot;</span>)<br>        .customMem(<span class="hljs-string">&quot;16G&quot;</span>)<br>        .getProduct();<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，LomBok提供了@Builder注解给我们使用，用的就是建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加了注解之后就可以直接使用该类.builder()</span><br><span class="hljs-type">Phone</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> Phone.builder()<br>    .cpu(<span class="hljs-string">&quot;1&quot;</span>)<br>    .mem(<span class="hljs-string">&quot;2&quot;</span>)<br>    .cam(<span class="hljs-string">&quot;3&quot;</span>)<br>    .disk(<span class="hljs-string">&quot;4&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>StringBuilder中的append</li><li>Swagger-ApiBuilder</li><li>快速实现。LomBok - Builder模式</li></ul><h2 id="第二章-结构型模式"><a href="#第二章-结构型模式" class="headerlink" title="第二章 结构型模式"></a>第二章 结构型模式</h2><p><strong>为什么使用结构型模式？</strong></p><ul><li>结构型模式关注点“怎样组合对象&#x2F;类？”，所以我们关注下类的组合关系</li><li>类结构型模式关系类的组合，由多个类可以组合成一个更大的（继承）</li><li>对象结构模式关系类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象（组合）</li><li>根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</li></ul><p><strong>结构型模式分类</strong></p><ul><li>适配器模式：两个不兼容接口之间适配的桥梁</li><li>桥接模式：相同功能抽象化与实现化解耦，抽象与实现可以独立升级</li><li>过滤器模式：使用不同的标准来过滤一组对象</li><li>组合模式：相似对象进行组合，形成树形结构</li><li>装饰器模式：向一个现有的对象添加新的功能，同时又不改变其结构</li><li>外观模式：向现有的系统添加一个接口，客户端访问此接口来隐藏系统的复杂性</li><li>享元模式：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</li><li>代理模式：一个类代表另一个类的功能</li></ul><h3 id="2-1-适配器（Adapter）模式"><a href="#2-1-适配器（Adapter）模式" class="headerlink" title="2.1 适配器（Adapter）模式"></a>2.1 适配器（Adapter）模式</h3><p>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，适配器模式分为类结构型模式（继承）和对象结构型模式（组合）两种，前者（继承）类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>别名也可以是Wrapper，包装器。</p><p>适配器模式包含以下主要角色</p><ul><li>目标接口：可以是抽象类或接口。客户希望直接用的接口</li><li>适配者：隐藏的转换接口</li><li>适配器：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口。</li></ul><p>通俗点就是说，比如我想看英文电影，然后还有一个翻译机。就可以通过通过一个适配器，让英文电影和翻译机联系起来，让我们能看懂英文电影</p><p><img src="image-20211219215034009.png" alt="image-20211219215034009"></p><p>对象适配器模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JPMoviePlayerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-comment">// 组合的方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Translator</span> <span class="hljs-variable">translator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zh_JPTranslator</span>();<br>    <span class="hljs-keyword">private</span> Player target; <span class="hljs-comment">// 被适配的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JPMoviePlayerAdapter</span><span class="hljs-params">(Player target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> target.play();<br>        <span class="hljs-comment">// 转换字母，增强逻辑</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">translate</span> <span class="hljs-operator">=</span> translator.translate(play);<br>        System.out.println(<span class="hljs-string">&quot;日文：&quot;</span> + translate);<br>        <span class="hljs-keyword">return</span> play;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用适配器增强player</span><br>        <span class="hljs-type">JPMoviePlayerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPMoviePlayerAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MoviePlayer</span>());<br>        adapter.play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类适配：Adapter进行实现或者继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JPMoviePlayerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Zh_JPTranslator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Player</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Player target;<span class="hljs-comment">//被适配对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JPMoviePlayerAdapter</span><span class="hljs-params">(Player target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> target.play();<br>        <span class="hljs-comment">//转换字幕</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">translate</span> <span class="hljs-operator">=</span> translate(play);<br>        System.out.println(<span class="hljs-string">&quot;日文：&quot;</span>+translate);<br>        <span class="hljs-keyword">return</span> play;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ul><li>Tomcat如何将Request流转为标准Request？<ul><li>tomcat &#x3D;&#x3D;&#x3D; CopyteAdapte &#x3D;&#x3D; ServletRequest</li></ul></li><li>SpringAOP中的AdvisorAdapter是什么：增强的适配器</li><li>SpringMVC中经典的HandlerAdapter是什么？<ul><li>HelloController.hello()方法，通过HandlerAdapter来调用底层的Servlet.doGet()</li></ul></li><li>SpringBoot中的WebMvcConfigurerAdapter为什么存在又取消？</li></ul><h3 id="2-2-桥接（Bridge）模式"><a href="#2-2-桥接（Bridge）模式" class="headerlink" title="2.2 桥接（Bridge）模式"></a>2.2 桥接（Bridge）模式</h3><ul><li>将抽象与实现解耦，使两者都可以独立变化。</li><li>在现实生活中，某些类具有两个或多个维度的变化，如图形即可按形状分，又可按颜色分。如何设计类似于Photoshop这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式的话，m种形状和n种颜色的图形就有m * n种，不但对应子类很多，而且扩展困难。</li><li><strong>桥接将继承转换为关联，降低类之间的耦合度，减少代码量。</strong></li><li><strong>真正会引起此类变化的一个维度直接抽取出来，通过组合的方式接起来</strong></li></ul><p>桥接模式包含以下主要角色：</p><ul><li>系统设计期间，如果这个类里面的一些东西，会扩展很多，这个东西就应该分离出来</li><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li></ul><p><img src="image-20211220091933738.png" alt="image-20211220091933738"></p><p><strong>应用场景</strong></p><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时</li><li>InputStreamReader桥接模式。An InputStreamReader is a bridge from byte streams to character streams;</li><li>InputStreamReader 桥接+ 适配器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如我们的重点是手机，然后手机有小米手机和苹果手机等等</span><br><span class="hljs-comment">// 而每种手机又有线上和线下两种销售模式</span><br><span class="hljs-comment">// 如果不使用桥接模式的话，就需要创建2 * 2个类</span><br><span class="hljs-comment">// 使用了桥接模式 只需要2 + 2个类了。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPhone</span> &#123;<br>    <span class="hljs-comment">// 将会引起变化的销售模式给抽取出来</span><br>    AbstractSale sale; <span class="hljs-comment">// 【桥接的关注点】</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSale</span><span class="hljs-params">(AbstractSale sale)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sale = sale;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSale</span> &#123;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">private</span> Integer price;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">// AbstractPhone的实现类</span><br>    <span class="hljs-type">IPhone</span> <span class="hljs-variable">iPhone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IPhone</span>();<br>    <span class="hljs-comment">// 销售模式</span><br>    iPhone.setSale(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentSale</span>(<span class="hljs-string">&quot;学生&quot;</span>,<span class="hljs-number">1</span>));<br><br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> iPhone.getPhone();<br>    System.out.println(phone);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-装饰器（Decorator-x2F-Wrapper（包装））模式"><a href="#2-3-装饰器（Decorator-x2F-Wrapper（包装））模式" class="headerlink" title="2.3 装饰器（Decorator&#x2F;Wrapper（包装））模式"></a>2.3 装饰器（Decorator&#x2F;Wrapper（包装））模式</h3><ul><li>适配器是连接两个类，可以增强一个类；而装饰器是增强一个类</li><li>向一个现有的对象添加新的功能，同时又不改变其结构，属于对象结构型模式</li><li>创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</li></ul><p><img src="image-20211220105640201.png" alt="image-20211220105640201"></p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象</li><li>具体构建（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><p><strong>使用场景</strong></p><ul><li>SpringSession中如何进行session与redis关联？HttpRequestWrapper</li><li>MybatisPlus提取了Querywrapper，这是为什么</li><li>Spring中的BeanWrapper是做什么的？包装了Bean，bean的功能增强？</li><li>SpringWebflux中的WebHandlerDecorator</li><li>已存在的类，某一天在某个功能使用的时候发现不够，就可以使用装饰类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象构建</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ManTikTok</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体构件角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZhangTikTok</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ManTikTok</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;张三，tiktok.... &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象装饰角色</span><br><span class="hljs-comment">// 给抖音直播增加新的功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TiktokDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ManTikTok</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">enable</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 美颜装饰器</span><br><span class="hljs-comment"> *      装饰谁？</span><br><span class="hljs-comment"> *  装饰器只关系增强这个类的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MeiYanDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TiktokDecorator</span>&#123;<br><br>    <span class="hljs-keyword">private</span> ManTikTok manTikTok;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MeiYanDecorator</span><span class="hljs-params">(ManTikTok manTikTok)</span>&#123;<br>        <span class="hljs-built_in">this</span>.manTikTok = manTikTok;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//开启美颜，新增的功能</span><br>        enable();<br>        <span class="hljs-comment">//我开始直播</span><br>        manTikTok.tiktok();<br>    &#125;<br><br><br><span class="hljs-comment">// 定义的增强功能</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enable</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;看这个美女.....&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;花花花花花花花花花花花&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 核心：想要不改变原来接口方法的情况下扩展新功能，或者增强方法.....</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//被装饰对象</span><br>        <span class="hljs-type">ManTikTok</span> <span class="hljs-variable">manTikTok</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeiTikTok</span>();<br>        <span class="hljs-comment">// 适配器</span><br>        <span class="hljs-type">MeiYanDecorator</span> <span class="hljs-variable">decorator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeiYanDecorator</span>(manTikTok);<br>        decorator.tiktok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-代理（Proxy）模式"><a href="#2-4-代理（Proxy）模式" class="headerlink" title="2.4 代理（Proxy）模式"></a>2.4 代理（Proxy）模式</h3><p>代理模式，给某一个对象提供一个代理，并由代理对象控制对原对象的引用。对象结构型模式。</p><ul><li>Subject：抽象主体角色（抽象类或接口）</li><li>Proxy：代理主体角色（代理对象类）</li><li>RealSubject：真实主体角色（被代理对象类）</li></ul><p><strong>应用场景</strong></p><ul><li>Mybatis中的mapper到底是什么？怎么生成的？<ul><li>动态代理</li><li>UserMapper、CityMapper，mybatis帮我们写实现MapperProxy</li></ul></li><li>Seata的DataSourceProxy是什么</li><li>DruidDataSource存在的Proxy模式：监控链…</li></ul><p><strong>区别–装饰器、代理</strong></p><ul><li>装饰器和代理之间的区别很细微，可以认为装饰器是代理的一个子集</li><li>静态代理就是装饰器的方式</li></ul><h4 id="2-4-1-静态代理（static）"><a href="#2-4-1-静态代理（static）" class="headerlink" title="2.4.1 静态代理（static）"></a>2.4.1 静态代理（static）</h4><p>静态代理和装饰器模式差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 抽象主体。被代理角色能干什么 */</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ManTikTok</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/** Subject  主体 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeiTikTok</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ManTikTok</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;雷丰阳，tiktok.... &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理一般都是和被代理对象属于同一个接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiMingTiktokProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ManTikTok</span>&#123;<br><br>    <span class="hljs-keyword">private</span> ManTikTok manTikTok; <span class="hljs-comment">//被代理对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LiMingTiktokProxy</span><span class="hljs-params">(ManTikTok manTikTok)</span>&#123;<br>        <span class="hljs-built_in">this</span>.manTikTok = manTikTok;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//增强功能</span><br>        System.out.println(<span class="hljs-string">&quot;渲染直播间....&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;课程只要666，仅此一天....&quot;</span>);<br>        manTikTok.tiktok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-动态代理（dynamic）"><a href="#2-4-2-动态代理（dynamic）" class="headerlink" title="2.4.2 动态代理（dynamic）"></a>2.4.2 动态代理（dynamic）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 还是选择抖音卖货</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ManTikTok</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeiTikTok</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ManTikTok</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktok</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;直播卖课啦，快来买&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果这里面有自己定义的方法，而不是实现接口的方法</span><br>    <span class="hljs-comment">// JDK动态代理将不能代理该本类自己的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代理类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDKTiktokProxy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocaationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> T target;<br>    <span class="hljs-comment">// 接受被代理的对象</span><br>    JDKTiktokProxy(T target) &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取被代理的对象的代理对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        ClassLoader loader：当前被代理对象的类加载器</span><br><span class="hljs-comment">        Class&lt;?&gt;[] interfaces：当前被代理对象所实现的所有接口</span><br><span class="hljs-comment">        InvocationHandler h</span><br><span class="hljs-comment">        当前被代理对象执行目标方法的时候我们可以使用h可以定义拦截增强方法</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">return</span> (T)Proxy.newProxyInstance(<br>        t.getClass().getClassLoader(),<br>            t.getClass().getInterfaces(), <span class="hljs-comment">//必须为接口</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">JDKTiktokProxy</span>(t));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 定义目标方法的拦截逻辑；每个方法都会进来的</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy,</span><br><span class="hljs-params">                        Method method,</span><br><span class="hljs-params">                        Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 反射执行，可以给方法添加新的功能</span><br>        System.out.println(<span class="hljs-string">&quot;真正执行被代理对象的方法&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;我是增强逻辑&quot;</span>);<br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ManTikTok</span> <span class="hljs-variable">leiTikTok</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeiTikTok</span>();<br>    <span class="hljs-type">ManTikTk</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> JDKTiktokProxy.getProxy(leiTikTok);<br>    proxy.tiktok();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用代理对象执行本类的接口，将会出现以下错误：</p><div style="color :red">Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to com.atguigu.design.structural.proxy.dynamic.LeiTikTok    at com.atguigu.design.structural.proxy.dynamic.MainTest.main(MainTest.java:29)</div><h4 id="2-4-3-Cglib代理"><a href="#2-4-3-Cglib代理" class="headerlink" title="2.4.3 Cglib代理"></a>2.4.3 Cglib代理</h4><p>首先需要添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它和JDK动态代理的好处就是可以代理本类自己的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Subject  主体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeiTikTok</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tiktokHaha</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;雷丰阳，tiktok.... haha....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用cglib帮我们创建出代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; T <span class="hljs-title function_">createProxy</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-comment">// 1、创建一个增强器</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 2、设置要增强哪个类的功能，增强器为这个类动态创建一个子类</span><br>        enhancer.setSuperClass(t.getClass());<br>        <span class="hljs-comment">// 3、设置回调</span><br>        <span class="hljs-comment">// 为了能获取到原方法的一些元数据信息</span><br>        enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -&gt; &#123;<br>            <span class="hljs-comment">// 编写拦截的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;cglib上场了&quot;</span>);<br>            <span class="hljs-comment">// 也可以通过method参数获取到当前方法的相应信息</span><br>            <span class="hljs-keyword">return</span> proxy.invokSuper(obj, args);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> (T)enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">man</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-type">LeiTikTok</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> CglibProxy.createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LeiTikTok</span>());<br>    proxy.tiktokHaha();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-组合（Composite）模式"><a href="#2-5-组合（Composite）模式" class="headerlink" title="2.5 组合（Composite）模式"></a>2.5 组合（Composite）模式</h3><p>组合模式就是把一组相似的对象当作一个单一的对象。如树形菜单</p><p><img src="image-20211221115100969.png" alt="image-20211221115100969"></p><h3 id="2-6-外观（Facade）模式"><a href="#2-6-外观（Facade）模式" class="headerlink" title="2.6 外观（Facade）模式"></a>2.6 外观（Facade）模式</h3><p>又叫做门面模式，是一种通过<strong>为多个复杂的子系统提供一个一致的接口</strong>，而使这些子系统更加容易被访问的模式。</p><p><img src="image-20211221115249590.png" alt="image-20211221115249590"></p><p><strong>使用场景</strong></p><ul><li>去医院看病，可能要去挂号、门诊、取药等等，让患者和家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便</li><li>JAVA的三层开发模式</li><li>分布式系统的网关</li><li>Tomcat源码中的RequestFacade</li></ul><h3 id="2-7-享元（Flyweight）模式"><a href="#2-7-享元（Flyweight）模式" class="headerlink" title="2.7 享元（Flyweight）模式"></a>2.7 享元（Flyweight）模式</h3><ul><li><strong>运用共享技术有效地支持大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。对象结构型</li><li>在享元模式中<strong>可以共享的相同内容称为内部状态（IntrinsicState）</strong>，而那些需要外部环境来设置的<strong>不能共享的内容称为外部状态（ExtrinsicState）</strong>，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的</li><li>在享元模式中通常会出现工厂模式，而创建一个<strong>享元工厂来负责维护一个享元池</strong>（Flyweight Pool）用于存储具有相同内部状态的对象</li><li>享元模式包含以下角色：<ul><li>Flyweight：抽象享元类Connection</li><li>ConcreteFlyweight：具体享元类 ConnectionImpl（user, pwd, url）</li><li>UnsharedConcreteFlyweight：非共享具体享元类ConnectionImpl（state）</li><li>FlyweightFactory：享元工厂类；简单工厂，产品就一个Connection</li></ul></li></ul><p><img src="image-20211221121625676.png" alt="image-20211221121625676"></p><p><strong>使用场景</strong></p><ul><li>数据库连接池</li><li>所有的池化技术</li><li>享元和原型模式有什么区别？享元是预先准备好的对象进行复用，原型没法确定预先有哪些。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可共享和不可共享状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractWaitressFlyweight</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">canService</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 能否服务</span><br>    <span class="hljs-comment">// 正在服务。享元的不可共享属性留给外部进行改变的接口</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 服务完成。</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCanService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> canService;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体享元类</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeautifulWaitress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractWaitressFlyweight</span> &#123;<br>    String id;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// 以上是不变的</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;工号：&quot;</span>+id+<span class="hljs-string">&quot;；&quot;</span>+name+<span class="hljs-string">&quot; &quot;</span>+age+<span class="hljs-string">&quot; 正在为您服务...&quot;</span>);<br>        <span class="hljs-comment">//改变外部状态</span><br>        <span class="hljs-built_in">this</span>.canService = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;工号：&quot;</span>+id+<span class="hljs-string">&quot;；&quot;</span>+name+<span class="hljs-string">&quot; &quot;</span>+age+<span class="hljs-string">&quot; 服务结束...请给五星好评&quot;</span>);<br>        <span class="hljs-built_in">this</span>.canService = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 足道店：这相当于享元工厂</span><br><span class="hljs-comment"> *      店里面很多服务员。</span><br><span class="hljs-comment"> * 享元和原型</span><br><span class="hljs-comment"> * 1、享元返回的是这个本人。</span><br><span class="hljs-comment"> * 2、原型返回的是克隆人。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZuDao</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,AbstractWaitressFlyweight&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//享元，池子中有对象</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">BeautifulWaitress</span> <span class="hljs-variable">waitress</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeautifulWaitress</span>(<span class="hljs-string">&quot;1111&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);<br>        <span class="hljs-type">BeautifulWaitress</span> <span class="hljs-variable">waitress2</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeautifulWaitress</span>(<span class="hljs-string">&quot;9527&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">20</span>);<br>        pool.put(waitress.id,waitress);<br>        pool.put(waitress2.id,waitress2);<br>    &#125;<br>    <span class="hljs-comment">// 向池子中添加对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWaitress</span><span class="hljs-params">(AbstractWaitressFlyweight waitressFlyweight)</span>&#123;<br>        pool.put(UUID.randomUUID().toString(),waitressFlyweight);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractWaitressFlyweight <span class="hljs-title function_">getWaitress</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-type">AbstractWaitressFlyweight</span> <span class="hljs-variable">flyweight</span> <span class="hljs-operator">=</span> pool.get(name);<br>        <span class="hljs-keyword">if</span>(flyweight == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (AbstractWaitressFlyweight value : pool.values()) &#123;<br>                <span class="hljs-comment">//当前共享对象能否是否</span><br>                <span class="hljs-keyword">if</span>(value.isCanService())&#123;<br>                    <span class="hljs-keyword">return</span> value;<br>                &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flyweight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//1、我</span><br>    <span class="hljs-type">AbstractWaitressFlyweight</span> <span class="hljs-variable">waitress</span> <span class="hljs-operator">=</span> ZuDao.getWaitress(<span class="hljs-string">&quot;&quot;</span>);<br>    waitress.service();<br>    System.out.println(waitress);<br>    <span class="hljs-comment">//2、佟老师</span><br>    <span class="hljs-type">AbstractWaitressFlyweight</span> <span class="hljs-variable">waitress1</span> <span class="hljs-operator">=</span> ZuDao.getWaitress(<span class="hljs-string">&quot;&quot;</span>);<br>    waitress1.service();<br>    System.out.println(waitress1);<br><br>    waitress1.end();<br>    <span class="hljs-comment">//3、刘佳林</span><br>    <span class="hljs-type">AbstractWaitressFlyweight</span> <span class="hljs-variable">waitress2</span> <span class="hljs-operator">=</span> ZuDao.getWaitress(<span class="hljs-string">&quot;&quot;</span>);<br>    System.out.println(waitress2);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-过滤器（Filter）模式"><a href="#2-8-过滤器（Filter）模式" class="headerlink" title="2.8 过滤器（Filter）模式"></a>2.8 过滤器（Filter）模式</h3><p>使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。结合多个标准来获得单一标准。</p><p><a href="https://www.runoob.com/design-pattern/filter-pattern.html">https://www.runoob.com/design-pattern/filter-pattern.html</a></p><p><img src="image-20211221122333684.png" alt="image-20211221122333684"></p><h2 id="第三章-行为型模式"><a href="#第三章-行为型模式" class="headerlink" title="第三章 行为型模式"></a>第三章 行为型模式</h2><ul><li>行为型模式关注点<strong>怎样运行对象&#x2F;类</strong>，所以我们关注下类&#x2F;对象的运行时流程控制</li><li>行为型模式用于描述程序在运行时复杂的流程控制</li><li>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</li><li>行为型模式分为类行为模式和对象行为模式，前者采用继承•机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“<strong>合成复用原则</strong>”，所以对象行为模式比类行为模式具有更大的灵活性。</li></ul><p><strong>行为型模式分类</strong></p><ul><li>模板方法（Template Method）模式：父类定义算法骨架，某些实现放在子类</li><li>策略（Strategy）模式：每种算法独立封装，根据不同情况使用不同算法策略</li><li>状态（State）模式：每种状态独立封装，不同状态内部封装了不同行为</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开</li><li>职责链（Chain of Responsibility）模式：所有处理者封装为链式结构，依次调用</li><li>备忘录（Memento）模式：把核心信息抽取出来，可以进行保存</li><li>解释器（Interpreter）模式：定义语法解析规则</li><li>观察者（Observer）模式：维护多个观察者依赖，状态变化通知所有观察者</li><li>中介者（Mediator）模式：取消类&#x2F;对象的直接调用关系，使用中介者维护</li><li>迭代器（Iterator）模式：定义集合数据的遍历规则</li><li>访问者（Visitor）模式：分离对象结构，与元素的执行算法</li></ul><p>除了模板方法模式和解释器模式是类行为模式，其他的都属于对象行为模式</p><h3 id="3-1-模板方法（Template-Method）模式"><a href="#3-1-模板方法（Template-Method）模式" class="headerlink" title="3.1 模板方法（Template Method）模式"></a>3.1 模板方法（Template Method）模式</h3><p>在该模式中，一个抽象类公开定义了执行它的方法的方式模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方法进行。</p><p><img src="image-20211221124450298.png" alt="image-20211221124450298"></p><p><strong>使用场景</strong></p><ul><li>Spring的整个继承体系都基本用到模板方法：BeanFactory.getBean</li><li>JdbcTemplate、RedisTemplate都允许我们再扩展</li><li>我们自己的系统也应该使用模板方法组织类结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、定义模板</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookTemplate</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义算法：  定义好了模板</span><br><span class="hljs-comment">     * 父类可以实现某些步骤</span><br><span class="hljs-comment">     * 留关键给子类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cook</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//定义算法步骤</span><br>        heating();   <span class="hljs-comment">//v</span><br>        addfood();<br>        addsalt();<br>        stirfry();   <span class="hljs-comment">//v</span><br>        end();      <span class="hljs-comment">//v</span><br>    &#125;<br><br>    <span class="hljs-comment">//加热方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heating</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开火...&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">//添加食物</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addfood</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//加盐</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addsalt</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//翻炒</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">stirfry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;翻炒中...&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">//出锅</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;出锅....&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 实现父类留给子类自定义的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoCookMachine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CookTemplate</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addfood</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放了三个小白菜&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addsalt</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放了三勺盐&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AutoCookMachine</span> <span class="hljs-variable">cookMachine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoCookMachine</span>();<br>        cookMachine.cook();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-策略（Strategy）模式"><a href="#3-2-策略（Strategy）模式" class="headerlink" title="3.2 策略（Strategy）模式"></a>3.2 策略（Strategy）模式</h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式</p><p><img src="image-20211221124858117.png" alt="image-20211221124858117"></p><p><strong>主要角色</strong></p><ul><li>抽象策略类：公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>具体策略类：实现了抽象策略定义的接口，提供具体的算法实现。</li><li>环境类：持有一个策略类的引用，最终给客户端调用。</li></ul><p><strong>应用场景</strong></p><ul><li>使用策略模式可以避免使用多重条件语句，如if else语句、switch</li><li>什么是Spring中的InstantiationStrategy</li><li>线程池拒绝策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 游戏策略 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GameStrategy</span> &#123;<br>    <span class="hljs-comment">//战斗策略</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">warStrategy</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GameStrategy</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warStrategy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;大乱斗...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 稳健运营策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SteadyStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GameStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warStrategy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;各路小心...及时支援...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环境类，也可以通过构造函数强行让其指定策略</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeamGNR</span> &#123;<br><br>    <span class="hljs-comment">//抽取游戏策略算法，并进行引用</span><br>    <span class="hljs-keyword">private</span> GameStrategy gameStrategy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGameStrategy</span><span class="hljs-params">(GameStrategy gameStrategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gameStrategy = gameStrategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGame</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;游戏开始.....&quot;</span>);<br>        <span class="hljs-comment">//游戏策略</span><br>        gameStrategy.warStrategy();<br>        System.out.println(<span class="hljs-string">&quot;win......&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TeamGNR</span> <span class="hljs-variable">gnr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeamGNR</span>();<br>        gnr.setGameStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomStrategy</span>());<br>        gnr.startGame();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-状态（State）模式"><a href="#3-3-状态（State）模式" class="headerlink" title="3.3 状态（State）模式"></a>3.3 状态（State）模式</h3><p>对有状态的对象，把复杂的”判断逻辑“提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p><p><img src="image-20211221125524010.png" alt="image-20211221125524010"></p><p><strong>重点是状态的流转</strong></p><p><strong>应用场景</strong></p><ul><li>状态模式核心<strong>需要具体状态类能在必要的时候切换状态</strong>，和策略模式不一样</li><li>流程框架和状态机</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** * 抽象状态*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TeamState</span> &#123;<br>    <span class="hljs-comment">//玩游戏</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//切换到下一个状态</span><br>    TeamState <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 竞赛状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TeamState</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;全力以赴打比赛....&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//状态模式的核心</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> TeamState <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VocationState</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 休假状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VocationState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TeamState</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;三亚旅游真舒服....饿了...不玩游戏&quot;</span>);<br>        <span class="hljs-comment">//状态流转</span><br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> TeamState <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeafNodleState</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 吃牛肉面状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeafNodleState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TeamState</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;饱饱的一顿牛肉面......中了诅咒，输了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> TeamState <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchState</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>环境类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SKTTeam</span> &#123;<br>    <span class="hljs-keyword">private</span> TeamState teamState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTeamState</span><span class="hljs-params">(TeamState teamState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.teamState = teamState;<br>    &#125;<br><br>    <span class="hljs-comment">//开始游戏</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGame</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//状态不同会导致不同的游戏结果</span><br>        teamState.playGame();<br>    &#125;<br><br>    <span class="hljs-comment">//下一个状态 可以通过环境类调，也可以直接使用抽象状态的next方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextState</span><span class="hljs-params">()</span>&#123;<br>        teamState = teamState.next();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 状态切换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">SKTTeam</span> <span class="hljs-variable">sktTeam</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SKTTeam</span>();<br>        <span class="hljs-type">TeamState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VocationState</span>();<br>        sktTeam.setTeamState(state);<br>        sktTeam.startGame();<br><br>        <span class="hljs-comment">//        sktTeam.startGame();</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//        sktTeam.nextState();</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//        sktTeam.startGame();</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//        sktTeam.nextState();</span><br>        <span class="hljs-comment">//        sktTeam.startGame();</span><br><br>        state = state.next();<br>        sktTeam.setTeamState(state);<br>        sktTeam.startGame();<br><br>        <span class="hljs-comment">//状态需要维护自己的切换逻辑</span><br>        state = state.next();<br>        sktTeam.setTeamState(state);<br>        sktTeam.startGame();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-中介者（Mediator）模式"><a href="#3-4-中介者（Mediator）模式" class="headerlink" title="3.4 中介者（Mediator）模式"></a>3.4 中介者（Mediator）模式</h3><p><img src="image-20211221130132252.png" alt="image-20211221130132252"></p><p>中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，减少对象间混乱的依赖关系，从而使其耦合松散，而且可以独立地改变它们之间的交互。对象行为模式</p><p>如上图所示，用一个塔台来管理所有的飞机，在飞机想要降落的时候，就看塔台允不允许降落；飞机想要起飞的时候，就看塔台允不允许起飞。</p><p><img src="image-20211221131311183.png" alt="image-20211221131311183"></p><p><strong>应用场景</strong></p><ul><li>SpringMVC中的DispatcherServlet是一个中介者，他会提取Controller、Model、View来进行调用。而无需Controller直接调用view之类的渲染方法</li><li>分布式系统中的网关</li><li>迪米特发法则的一个典型应用</li><li>中介者和外观（门面）模式区别：中介者双向操作，门面偏向于封装某一方</li></ul><h3 id="3-5-观察者（Observer）模式"><a href="#3-5-观察者（Observer）模式" class="headerlink" title="3.5 观察者（Observer）模式"></a>3.5 观察者（Observer）模式</h3><p>定义对象间的一种<strong>一对多依赖关系</strong>，使得每<strong>当一个对象状态发生改变</strong>时，其相关<strong>依赖对象皆得到通知</strong>并被<strong>自动更新</strong>。观察者模式又叫做<strong>发布-订阅</strong>（Publisher&#x2F;Subscribe）模式、模型-视图模式、源-监听器模式或从属模式。对象行为模式</p><p><img src="image-20211221131950615.png" alt="image-20211221131950615"></p><p><strong>应用场景</strong></p><ul><li>Spring事件机制如何实现</li><li>Vue的双向绑定核心</li><li>响应式编程核心思想</li></ul><h3 id="3-6-备忘录（Memento）模式"><a href="#3-6-备忘录（Memento）模式" class="headerlink" title="3.6 备忘录（Memento）模式"></a>3.6 备忘录（Memento）模式</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫<strong>快照模式</strong>。对象行为型模式</p><p><img src="image-20211221135327385.png" alt="image-20211221135327385"></p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><p><strong>应用场景</strong></p><ul><li>游戏存档</li><li>数据库保存点事务（savepoint）</li><li>session活化钝化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 游戏记录。需要保存的内部状态信息，</span><br><span class="hljs-comment"> *      也叫备忘录信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRecord</span> &#123;<br>    Integer id; <span class="hljs-comment">//代表生成记录的id</span><br>    Integer coin;<span class="hljs-comment">//剩余金币</span><br>    Integer hp;<span class="hljs-comment">//血量</span><br>    Integer mp;<span class="hljs-comment">//蓝量</span><br>    Integer level;<span class="hljs-comment">//等级</span><br><br>    <span class="hljs-comment">//获取当前备忘录信息</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCurrent</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;coin：&quot;</span>+coin+<span class="hljs-string">&quot;；\t&quot;</span>+<span class="hljs-string">&quot;hp：&quot;</span>+hp+<span class="hljs-string">&quot;；\t mp：&quot;</span>+mp);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当前游戏信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 游戏者： 游戏发起人</span><br><span class="hljs-comment"> * 当前游戏信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeiGamer</span>  &#123;<br>    Integer coin;<span class="hljs-comment">//剩余金币</span><br>    Integer hp;<span class="hljs-comment">//血量</span><br>    Integer mp;<span class="hljs-comment">//蓝量</span><br>    Integer level;<span class="hljs-comment">//等级</span><br>    <span class="hljs-comment">//以上的是内部状态，我们需要记录保存的信息</span><br><br>    <span class="hljs-type">GameServer</span> <span class="hljs-variable">gameServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameServer</span>();<br><br>    <span class="hljs-comment">//保存游戏记录</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveGameRecord</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在保存当前记录....&quot;</span>);<br>        <span class="hljs-type">GameRecord</span> <span class="hljs-variable">gameRecord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GameRecord</span>();<br>        <span class="hljs-comment">//当前游戏信息保存到备忘录</span><br>        BeanUtils.copyProperties(gameRecord,<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//</span><br>        gameServer.add(gameRecord);<br>    &#125;<br><br>    <span class="hljs-comment">//从备忘录获取游戏历史存档</span><br>    LeiGamer <span class="hljs-title function_">getFromMemento</span><span class="hljs-params">(Integer id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取历史存档信息....&quot;</span>);<br>        <span class="hljs-type">LeiGamer</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> gameServer.getRecord(id);<br>        <span class="hljs-keyword">return</span> record;<br>    &#125;<br><br>    <span class="hljs-comment">//玩游戏</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt();<br>        System.out.println(<span class="hljs-string">&quot;......(〃&#x27;▽&#x27;〃)......&quot;</span>+i);<br>        coin = i;<br>        hp = i;<br>        mp = i;<br>        level = i;<br>    &#125;<br><br>    <span class="hljs-comment">//退出游戏</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">exitGame</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;退出&amp;存档&quot;</span>);<br>        saveGameRecord();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>游戏服务器，存储游戏信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 游戏服务器</span><br><span class="hljs-comment"> * 管理者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameServer</span> &#123;<br><br>    <span class="hljs-comment">//管理备忘录信息的</span><br>    Map&lt;Integer,GameRecord&gt; records = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(GameRecord gameRecord)</span>&#123;<br>        gameRecord.setId(i++);<br>        records.put(gameRecord.id,gameRecord);<br>    &#125;<br><br>    LeiGamer <span class="hljs-title function_">getRecord</span><span class="hljs-params">(Integer id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GameRecord</span> <span class="hljs-variable">gameRecord</span> <span class="hljs-operator">=</span> records.get(id);<br>        <span class="hljs-comment">//获取到备忘录里面的内容以后还要逆转</span><br>        <span class="hljs-type">LeiGamer</span> <span class="hljs-variable">leiGamer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeiGamer</span>();<br><span class="hljs-comment">//        leiGamer.setCoin(gameRecord.getCoin());</span><br>        <span class="hljs-comment">//BeanUtils：工具类，属性对拷</span><br>        BeanUtils.copyProperties(leiGamer,gameRecord);<br>        <span class="hljs-keyword">return</span>  leiGamer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-解释器（Interpreter）模式"><a href="#3-7-解释器（Interpreter）模式" class="headerlink" title="3.7 解释器（Interpreter）模式"></a>3.7 解释器（Interpreter）模式</h3><p>给<strong>分析对象定义一个语言，并定义该语言的文法表示</strong>，再<strong>设计一个解释器</strong>来<strong>解释语言中的句子</strong>。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。类行为模式</p><p><strong>主要角色</strong>：</p><ul><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret（）</li><li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以i通过环境角色间接访问解释器的解释方法</li></ul><p><img src="image-20211221140524951.png" alt="image-20211221140524951"></p><p><strong>应用场景</strong></p><ul><li>Spring的表达式解析：#{}</li><li>Thymeleaf等模板引擎的语法解析</li><li>编译原理</li><li>编译器</li><li>execution( * top.noaharno.. (int,..))</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 身份信息表达式</span><br><span class="hljs-comment"> * 表达式的解析</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDCardExpression</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义解析逻辑</span><br><span class="hljs-comment">     * 假设我们需要解析的信息格式为：</span><br><span class="hljs-comment">     *      上海市：张文宏-医生</span><br><span class="hljs-comment">     *      武汉市：雷丰阳-程序员</span><br><span class="hljs-comment">     *      北京市：宋宋-老人</span><br><span class="hljs-comment">     *  表达式中，“：”以前的是城市，“-”以后的是职业</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expression</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String expression)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 终结符表达式</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 多少种解析规则就需要定义多少种规则类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IDCardExpression</span> &#123;<br><br>    IDCardExpression childExp;<br><br>    Set&lt;String&gt; data;  <span class="hljs-comment">//免费数据</span><br>    String symbol; <span class="hljs-comment">//定义解析用的符号如  ： -</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TerminalExpression</span><span class="hljs-params">( Set&lt;String&gt;  data,String symbol)</span>&#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.symbol = symbol;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String expression)</span> &#123;<br>        <span class="hljs-comment">//上海市：张文宏-医生</span><br>        <span class="hljs-comment">//1、先按照指定符号分割</span><br>        String[] split = expression.split(symbol);<br><br>        <span class="hljs-comment">// 冒号：  上海市              张文宏-医生</span><br>        <span class="hljs-comment">// 短横线  上海市：张文宏       医生</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (String s : split) &#123;<br>            <span class="hljs-keyword">if</span>(data.contains(s))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;;<span class="hljs-comment">//说明是免费的信息里面的</span><br>        &#125;<br><br>        <span class="hljs-comment">//可以继续子解析</span><br><span class="hljs-comment">//        childExp.interpret(expression);</span><br><br>        <span class="hljs-comment">//不在免费行列</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非终结表达式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IDCardExpression</span> &#123;<br><br>    <span class="hljs-comment">//组合两个终结表达式。最终的判断结果是终结表达式判断出来的，这个表达式只是一个桥梁</span><br>    <span class="hljs-keyword">private</span> IDCardExpression cityExp;<br>    <span class="hljs-keyword">private</span> IDCardExpression typeExp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrExpression</span><span class="hljs-params">(IDCardExpression cityExp, IDCardExpression typeExp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cityExp = cityExp;<br>        <span class="hljs-built_in">this</span>.typeExp = typeExp;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(String expression)</span> &#123;<br><br>        <span class="hljs-comment">//定义所有终结表达式的合并逻辑</span><br>        <span class="hljs-keyword">return</span> cityExp.interpret(expression) || typeExp.interpret(expression);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环境类：</span><br><span class="hljs-comment"> * 风景区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Area</span> &#123;<br>    Set&lt;String&gt; city = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><br>    Set&lt;String&gt; type = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    IDCardExpression idCardReader;<span class="hljs-comment">//读卡器，表达式解析器</span><br><br>    <span class="hljs-comment">//环境类持有表达式</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//        &#123;&quot;武汉市&quot;,&quot;上海市&quot;&#125;;//免费城市</span><br><span class="hljs-comment">//        &#123;&quot;医生&quot;,&quot;老人&quot;,&quot;儿童&quot;&#125;;//免费人群</span><br>        city.add(<span class="hljs-string">&quot;武汉市&quot;</span>);<br>        city.add(<span class="hljs-string">&quot;上海市&quot;</span>);<br><br>        type.add(<span class="hljs-string">&quot;医生&quot;</span>);<br><span class="hljs-comment">//        type.add(&quot;老人&quot;);</span><br>        type.add(<span class="hljs-string">&quot;儿童&quot;</span>);<br>        <span class="hljs-comment">//最小解析</span><br>        <span class="hljs-type">TerminalExpression</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-built_in">this</span>.city, <span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-comment">//最小解析</span><br>        <span class="hljs-type">TerminalExpression</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-built_in">this</span>.type, <span class="hljs-string">&quot;-&quot;</span>);<br><br><br>        <span class="hljs-comment">//以上满足一个即可</span><br>        idCardReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrExpression</span>(city,type);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传入表达式，判断当前表达式是否指定为免费人群</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expression</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTicket</span><span class="hljs-params">(String expression)</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interpret</span> <span class="hljs-operator">=</span> idCardReader.interpret(expression);<br>        <span class="hljs-keyword">if</span>(interpret)&#123;<br>            System.out.println(<span class="hljs-string">&quot;恭喜你，免票通过....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;对不起，请2元购票....&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Area</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Area</span>();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  上海市：张文宏-医生</span><br><span class="hljs-comment">         *  武汉市:雷丰阳-程序员</span><br><span class="hljs-comment">         *  北京市：宋宋-老人</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;武汉市:雷丰阳-程序员&quot;</span>;<br><br>        area.getTicket(sr);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-命令（Command）模式"><a href="#3-8-命令（Command）模式" class="headerlink" title="3.8 命令（Command）模式"></a>3.8 命令（Command）模式</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理</p><p><strong>其实我们使用的controller、service、dao就是典型的命令模式</strong></p><p><strong>主要角色</strong></p><ul><li>抽象命令类角色：声明执行命令的接口，拥有执行命令的抽象方法execute</li><li>具体命令类角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者</li><li>调用者&#x2F;请求者角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><p><img src="image-20211221141517304.png" alt="image-20211221141517304"></p><p><strong>应用场景</strong></p><ul><li>mvc就是典型的命令模式</li><li>当系统需要执行一组操作时，命令模式可以定义宏命令（一个命令组合了多个命令）来实现该功能</li><li>结合备忘录模式还可以实现命令的撤销和恢复</li></ul><h3 id="3-9-迭代器（Iterator）模式"><a href="#3-9-迭代器（Iterator）模式" class="headerlink" title="3.9 迭代器（Iterator）模式"></a>3.9 迭代器（Iterator）模式</h3><p>提供一个对象（迭代器）来顺序访问聚合对象（迭代数据）中的一系列数据，而不暴露聚合对象的内部表示。对象行为型模式</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><p><img src="image-20211221141857171.png" alt="image-20211221141857171"></p><p><strong>应用场景</strong></p><ul><li>jdk容器接口的Iterator定义</li><li>现实开发中，我们几乎无需编写迭代器，基本数据结构链表、树、图的迭代器已经都有了。除非要重写迭代逻辑</li></ul><h3 id="3-10-访问者（Visitor）模式"><a href="#3-10-访问者（Visitor）模式" class="headerlink" title="3.10 访问者（Visitor）模式"></a>3.10 访问者（Visitor）模式</h3><p>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是类行为模式中最复杂的一种模式</p><p><strong>主要角色</strong></p><ul><li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li><li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ul><p><img src="image-20211221142741832.png" alt="image-20211221142741832"></p><p><strong>应用场景</strong></p><ul><li>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则</li><li>违反<strong>依赖倒置原则</strong>。访问者模式依赖了具体类，而没有依赖抽象类</li><li>破坏封装。访问者模式中具体元素对访问者公开细节</li><li>应用于对象结构相对稳定，但其操作算法经常变化的程序</li><li>Spring反射工具中的MethodVisitor是什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 硬件。      抽象元素类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hardware</span> &#123;<br>    String command;<span class="hljs-comment">//封装硬件的处理指令</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hardware</span><span class="hljs-params">(String command)</span>&#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-comment">//收到命令以后进行工作</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//定义接受软件升级包的方法。这个方法应该具体硬件去实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Vistor vistor)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hardware</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CPU</span><span class="hljs-params">(String command)</span> &#123;<br>        <span class="hljs-built_in">super</span>(command);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;CPU处理指令：&quot;</span>+command);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Vistor vistor)</span> &#123;<br>        <span class="hljs-comment">//给升级包提供一个改CPU指令等信息的办法</span><br>        vistor.visitCPU(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Disk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hardware</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Disk</span><span class="hljs-params">(String command)</span> &#123;<br>        <span class="hljs-built_in">super</span>(command);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Disk保存指令的历史记录：&quot;</span>+command);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Vistor vistor)</span> &#123;<br>        vistor.visitDisk(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>升级包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 升级包的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vistor</span> &#123;<br>    <span class="hljs-comment">//访问者能访问元素。</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDisk</span><span class="hljs-params">(Disk disk)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitCPU</span><span class="hljs-params">(CPU cpu)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 升级包可以更改指令</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdatePackage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vistor</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String ext;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-title function_">UpdatePackage</span><span class="hljs-params">(String ext)</span>&#123;<br>        <span class="hljs-built_in">this</span>.ext = ext;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitDisk</span><span class="hljs-params">(Disk disk)</span> &#123;<br>        disk.command += <span class="hljs-string">&quot; &gt;&gt;&gt; &quot;</span>+ext;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitCPU</span><span class="hljs-params">(CPU cpu)</span> &#123;<br>        <span class="hljs-comment">//改属性为例</span><br>        cpu.command += <span class="hljs-string">&quot;&gt;&gt;&gt;&gt; &quot;</span>+ext;<br>        <span class="hljs-comment">//装饰模式。改方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以理解为小爱机器人相对稳定，但是需要经常升级指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小爱机器人</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiaoAi</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CPU</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPU</span>(<span class="hljs-string">&quot;武汉天气&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Disk</span> <span class="hljs-variable">disk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Disk</span>(<span class="hljs-string">&quot;武汉天气&quot;</span>);<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">answerQuestion</span><span class="hljs-params">()</span>&#123;<br>        cpu.work();<br>        disk.work();<br>    &#125;<br><br>    <span class="hljs-comment">//接受升级包</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acceptUpdate</span><span class="hljs-params">(Vistor aPackage)</span> &#123;<br>        <span class="hljs-comment">//访问模式</span><br>        aPackage.visitCPU(cpu);<br>        aPackage.visitDisk(disk);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">XiaoAi</span> <span class="hljs-variable">xiaoAi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XiaoAi</span>();<br>        xiaoAi.answerQuestion();<br>        <span class="hljs-comment">//升级。cpu联网处理指令</span><br>        <span class="hljs-comment">//升级。disk保存到云存储</span><br>        <span class="hljs-type">UpdatePackage</span> <span class="hljs-variable">aPackage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdatePackage</span>(<span class="hljs-string">&quot;联网增强功能&quot;</span>);<br>        xiaoAi.acceptUpdate(aPackage);<br>        <span class="hljs-comment">//访问者</span><br>        xiaoAi.answerQuestion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-11-责任链（Chain-of-Responsibility）模式"><a href="#3-11-责任链（Chain-of-Responsibility）模式" class="headerlink" title="3.11 责任链（Chain of Responsibility）模式"></a>3.11 责任链（Chain of Responsibility）模式</h3><p>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连城一条链；当有请求发生时，可以将请求沿着这条链传递，直到有对象处理它为止</p><p><strong>主要角色</strong></p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><p><img src="image-20211221143204328.png" alt="image-20211221143204328"></p><p><strong>应用场景</strong></p><ul><li>Tomcat的Pipeline、Value</li><li>Filter链</li><li>Aop责任链</li></ul><p>自定义request和response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    String msg; <span class="hljs-comment">//请求内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Request</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> &#123;<br>    String content;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Response</span><span class="hljs-params">(String content)</span>&#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Request request,Response response,FilterChain chain)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//功能</span><br>        request.msg +=<span class="hljs-string">&quot; ====&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;CharacterFilter...doFilter之前&quot;</span>);<br>        <span class="hljs-comment">//放行</span><br>        chain.doFilter(request,response,chain);<br>        System.out.println(<span class="hljs-string">&quot;CharacterFilter...doFilter之后&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncodingFilter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> &#123;<br>        request.msg+=<span class="hljs-string">&quot; oooo&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;EncodingFilter...doFilter之前&quot;</span>);<br>        <span class="hljs-comment">//放行</span><br>        chain.doFilter(request,response,chain);<br>        System.out.println(<span class="hljs-string">&quot;EncodingFilter...doFilter之后&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//第一个filter的功能</span><br>        request.msg+=<span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;HttpFilter...doFilter之前&quot;</span>);<br>        <span class="hljs-comment">//放行</span><br>        chain.doFilter(request,response,chain);<br>        System.out.println(<span class="hljs-string">&quot;HttpFilter...doFilter之后&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义过滤链和目标执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标执行方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">My</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用my.hello()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 靠他维护链条</span><br><span class="hljs-comment"> * HandlerExecutionChain</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-comment">//记录当前执行的步骤</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//filter的链</span><br>    List&lt;Filter&gt; filtersChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//最终要执行的目标方法</span><br>    My target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(My target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> My <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-comment">//添加filter</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFilter</span><span class="hljs-params">(Filter filter)</span>&#123;<br>        filtersChain.add(filter);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//第一次执行第一个filter，一次往下</span><br>        <span class="hljs-comment">//游标小于总数量filter一直往下获取执行</span><br>        <span class="hljs-keyword">if</span>(cursor &lt; filtersChain.size())&#123;<br>            <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filtersChain.get(cursor);<br>            cursor++;<br>            <span class="hljs-comment">//执行filter</span><br>            filter.doFilter(request,response,chain);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//filter完了，该执行目标方法了</span><br>            target.hello();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1---2---3--my---3---2---1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FilterChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterChain</span>();<br><br>        <span class="hljs-comment">//web.xml =- filter</span><br>        <span class="hljs-type">HttpFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpFilter</span>();<br>        <span class="hljs-type">CharacterFilter</span> <span class="hljs-variable">characterFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterFilter</span>();<br>        <span class="hljs-type">EncodingFilter</span> <span class="hljs-variable">encodingFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodingFilter</span>();<br>        chain.addFilter(filter);<br>        chain.addFilter(characterFilter);<br>        chain.addFilter(encodingFilter);<br><br>        chain.setTarget(<span class="hljs-keyword">new</span> <span class="hljs-title class_">My</span>());<br><br>        <span class="hljs-comment">//filter如何链式执行。</span><br><br>        chain.doFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&quot;hello world&quot;</span>),<br>                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;adhkjasdhak&quot;</span>),chain);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统理论知识</title>
    <link href="/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"/>
    <url>/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-The-Byzantine-Generals-Problem"><a href="#1-The-Byzantine-Generals-Problem" class="headerlink" title="1. The Byzantine Generals Problem"></a>1. The Byzantine Generals Problem</h2><p>拜占庭将军问题。</p><h2 id="2-CAP"><a href="#2-CAP" class="headerlink" title="2. CAP"></a>2. CAP</h2><ul><li><strong>Consistency</strong>，严格的一致</li></ul><p>一致性指的是客户端的每次操作，不管访问哪个节点，要么读到的都是同一份最新写入的数据，要么读取失败。也就是说<strong>如果对某一个节点更新成功，其他节点必定也会更新成功。</strong></p><p>一致性强调的是数据正确。就比如有两个节点AB，然后客户端将A中的数据从1改为2，然后接着从节点B中读取数据，发现还是1，这就是数据不一致。但是如果A更新了数据之后，通过节点间的通讯，同时将AB两个节点的值都更新为2，这时候就是满足数据一致性了。</p><ul><li><strong>Availability</strong></li></ul><p>可用性说的是任何来自客户端的请求，不管是访问哪个非故障节点都能够得到响应数据（不是错误或者超时的响应），但<strong>不保证是同一份最新数据，强调的只是服务可用。</strong></p><p>举例来说，客户端分别向节点AB发起请求，此时节点A中的数据是2，节点B中的数据还未被同步，仍然是1，但是在可用性条件下，不管此时节点之间的数据是否一致，只要节点服务器收到请求就会响应。因此客户端的两次请求会返回不一样的数据。</p><ul><li><strong>Partition Tolerance</strong></li></ul><p>分区容错性表示当分布式系统出现网络分区的时候，仍然能够对外提供服务。或者说当节点之间出现任意数量的消息丢失或者高延迟的时候，系统仍然在继续工作。分布式系统告诉客户端，无论我内部出现了什么样的数据同步问题，我都会一直运行。<strong>强调的是集群对分区故障的容错能力</strong></p><p>对于分布式系统来说，它涉及到多节点之间的通讯和交互，因此节点之间的分区故障是必然的，所以<strong>在分布式系统中Partition Tolerance是必须要考虑的</strong></p><p>网络分区？指的是在分布式系统中，多个节点之前的网络本来是连通的，但是由于某些故障导致某些节点之间不连通了，整个网络就被分成了几个区域，这就叫网络分区。</p><p>对于分布式系统中CAP的选择，其实并不是简单的三选二。因为只要有网络交互，就一定会有网络延迟和数据丢失，因此这种情况是我们必须要去接受的，也就是我们节点之间的分区故障是必然发生的，<strong>Partition Tolerance是前提，必须要保证。</strong>因此我们只能从剩下的CA中二选一。也就是要么保证数据正确，要么保证服务可用。</p><ul><li>当选择了Consistency的时候，就一定会读取到最新的数据，但是如果因为消息丢失、延迟过高发生了网络分区，这个时候集群节点为了不破坏一致性，可能会因为无法响应最新的数据而返回出错信息。</li><li>如果选择avaliability的时候，系统将始终处理客户端的请求，返回特定信息。如果发生了网络分区，一些节点无法返回最新的特定信息，为了不破坏avaliability，只能返回自己当前对应的旧的特定信息。舍弃了一致性，达到了高可用。</li></ul><p>其实如果分布式系统中不存在网络分区，也就是正常运行的情况下，从逻辑上来看CA是可以共存的。</p><p>对于CP模型的KV存储来说，适合用于提供基础服务，保存少量数据，但是需要一致性。就比如zookeeper，任何时刻对zookeeper的读请求都能得到一致性的结果，但是zookeeper不保证每次请求的可用性，比如在Leader选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</p><p>对于AP模型的KV存储来说，适合查询量大，不要求数据的一致性，但是重点在于性能和吞吐量。即能够容忍可能的短暂的一致性延迟，广泛应用于分布式缓存系统。</p><p>nacos的配置中心就是使用的CP保证各节点配置强一致，注册中心使用的是AP</p><h2 id="3-Transaction"><a href="#3-Transaction" class="headerlink" title="3. Transaction"></a>3. Transaction</h2><p>其实对于单机的事务来说，满足ACID还是比较简单的，像我们的MySQL数据库其实就满足了ACID，支持事务。但是在分布式系统中，涉及到各个节点之间的操作，还是比较困难。</p><h3 id="3-1-2PC"><a href="#3-1-2PC" class="headerlink" title="3.1 2PC"></a>3.1 2PC</h3><p>分为两个阶段：<strong>准备阶段和提交阶段</strong>。</p><p>举个例子：假如我们要提交一个订单，需要订单服务、库存服务、用户服务等。</p><p><strong>准备阶段</strong>：</p><p>事务协调者发送消息询问各个服务，看他们能否执行相关的操作，事务参与者收到消息之后，就在本地各自执行自己的事务预操作，比如redo log、undo log等，但是注意<strong>此时并未提交事务</strong>。当事务参与者执行完相关的事务预操作之后，发送执行成功的消息给事务协调者，表示自己能够执行该事务。</p><p>事务协调者收到所有的事务参与者的消息，发现都是成功消息，就说明该事务是可以被提交的，就进入下一阶段。</p><p><strong>提交阶段</strong>:</p><p>事务协调者发送commit消息给事务参与者，表示该事务可以被提交了。事务参与者收到消息之后，就会将本地的事务进行提交，然后释放整个事务执行期间占用的所有的资源，并发送ACK消息给事务协调者。</p><p>事务协调者收到所有的ACK之后，就表示该分布式事务已经全部执行成功。</p><p>如果在准备阶段，订单服务发现执行自己的本地事务失败了，就会回复FAIL消息给事务协调者。于是事务协调者就会发送rollback消息给所有的事务参与者，告诉他们需要回滚自己在本地执行的事务操作，然后宣告本次分布式事务执行失败。</p><p><strong>故障分析</strong></p><p>在第二个阶段，如果执行的是回滚事务操作，事务协调者并没有收到库存服务回滚成功的消息，就会不断重试，直到所有参与者都回滚；如果执行的是提交事务操作，同样也是会不断重试，直到所有的事务参与者都提交成功。 </p><p>最后如果真的不行，那么就记录相应的日志，进行相应的补偿或者定时任务补偿，或者人工介入处理。</p><p><strong>缺点</strong></p><ul><li>2PC是一个<strong>同步阻塞协议</strong>，比如准备阶段中，事务协调者会等待所有的事务参与者都回复相应的消息之后，才会进入下一阶段，如果其中有某个事务参与者出现了网络阻塞导致消息到达时间较长，事务协调者就会等待较长时间。而且就算有超时机制，超时之后可以触发重试，如果重试次数多了之后就会判定事务失败，然后向所有的参与者发送回滚消息。</li><li><strong>容易造成数据不一致</strong>：如果由于网络原因，导致部分事务参与者收不到commit&#x2F;rollback消息的话，就会导致数据不一致。</li><li><strong>单点问题</strong>：如果事务协调者在第二阶段刚开始的时候突然宕机了，事务参与者就收不到commit&#x2F;rollback消息，就会一直卡在准备阶段。</li><li><strong>整个执行的流程时间耗时较长，就会造成资源被占用时间较长</strong></li></ul><h3 id="3-2-TCC（Try-Confirm-Cancel）"><a href="#3-2-TCC（Try-Confirm-Cancel）" class="headerlink" title="3.2 TCC（Try-Confirm-Cancel）"></a>3.2 TCC（Try-Confirm-Cancel）</h3><p>TCC分为三个阶段：</p><ul><li><strong>Try阶段（尝试）</strong>：完成业务检查，预留好必需的业务资源。</li><li><strong>Confirm阶段（确认）</strong>：确认执行，当所有事务参与者的Try阶段都执行成功之后就会执行Confirm。该阶段会处理Try阶段预留的业务资源。否则会执行Cancel。</li><li><strong>Cancel（取消）</strong>：取消执行，释放Try阶段预留的业务资源。</li></ul><p><a href="https://cloud.tencent.com/developer/article/1547147">分布式事务之解决方案（TCC） - 云+社区 - 腾讯云 (tencent.com)</a></p><h3 id="3-3-3PC"><a href="#3-3-3PC" class="headerlink" title="3.3 3PC"></a>3.3 3PC</h3><p>3PC分为三个阶段，相对于2PC来说，在事务协调者和事务参与者中都引入了<strong>超时机制</strong>（2PC中只有协调者拥有超时机制）；同时增加了一个阶段，用来保证在最后提交阶段之前各参与节点的状态是一致的，也就是说：<strong>将2PC的准备阶段拆分成两个阶段，询问，然后再锁资源，最后真正提交</strong>。</p><p><strong>CanCommit</strong>：</p><p>事务协调者向所有的参与者发送CanCommit请求，询问他们是否可以执行事务提交请求；</p><p>事务参与者收到CanCommit请求之后，在正常情况下，如果自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态，否则返回No。</p><p><strong>PreCommit</strong></p><p>事务协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。</p><ul><li>如果协调者收到所有的参与者的反馈都是Yes，那么就会继续往下执行，也就是发送预提交请求，参与者收到PreCommit请求之后，就会进行事务操作。如果参与者成功执行了事务操作，就返回ACK响应，同时等待最终指令。</li><li>如果有任何一个参与者发送了No响应，或者等待超时之后，那么就进入中断事务流程：事务协调者向所有参与者发送abort请求，参与者收到之后，就执行事务的中断。</li></ul><p><strong>DoCommit</strong></p><p>执行事务的真正提交。</p><p>如果事务协调者收到了来自所有参与者的ACK响应之后，就会进入提交状态，向所有参与则会发送doCommit请求。参与者收到之后就会执行真正的事务提交，完成事务并且释放所有事务资源。事务提交完成之后，参与者向协调者发送ACK响应。事务协调者收到所有的ACK之后，表明本次事务执行成功。</p><p>如果事务协调者没有收到来自参与者发送的ACK响应，或者收到的不是ACK响应，就会执行中断事务。</p><p><strong>缺点：在第三阶段中，参与者如果没有收到协调者的通知，超时之后就会执行Commit操作，这里就会出现数据不一致的情况</strong></p><p><strong>优点</strong>：相对于2PC来说，3PC主要解决单点故障问题，并减少了阻塞时间。一旦参与者无法及时收到来自协调者的信息之后，就会默认执行Commit操作，而不是一直持有事务资源并处于阻塞状态。</p><h2 id="4-BASE-Theory"><a href="#4-BASE-Theory" class="headerlink" title="4. BASE Theory"></a>4. BASE Theory</h2><p>BASE理论的内容：<strong>基本可用</strong>（Basically Available）、<strong>软状态</strong>（Soft State，是实现服务可用性的时候系统数据的一种过渡状态，也可以说是不同节点间，数据副本存在短暂的不一致）、<strong>最终一致性</strong>（Eventually Consistent），它可以理解为AP的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。因为AP其实是一个动态模型，目前没有现成的库或方案，它是基于业务场景特点妥协折中后设计实现的。不过可以借助BASE理论帮助你达成目的。</p><p><strong>什么是基本可用？如何实现基本可用？</strong></p><p>首先基本可用大概就是说当系统在出现不可预知的故障的时候，可以允许部分功能的可用性，保障核心功能的可用性，去适应外界的压力，防止强行要求强可用性最终导致系统崩溃。比如响应时间上的损失、系统功能上的损失。</p><p>假设系统出现了不可预知的故障，但是还是能用，相对于正常的系统而言：</p><ol><li>响应时间上的损失：正常情况下只需0.5秒便可返回结果给用户，而基本可用则可以在两秒作用返回结果。</li><li>功能上的损失：在大流量下，为了保护购物模块的稳定性，牺牲部分消费者，从而降级。</li></ol><p>实现基本可用可以有四种方案：</p><ol><li><strong>流量削峰：</strong>就拿12306来说，如果所有的抢票请求都集中在九点钟，服务器肯定就无法承受这么大的压力，于是我们就可以让不同地方的火车票在不同的时候售票。比如深圳发车的八点开抢，北京发车的九点开抢。</li><li><strong>延迟响应：</strong>还是购票，我们可以发现当我们提交了请求之后，12306并不是立刻给我们响应，而是等待几分钟或者几十分钟之后系统才进行处理。当系统在出现超出系统处理能力的突发流量的情况下，会通过牺牲响应时间的可用性来保证核心功能的运行。</li><li><strong>体验降级：</strong>比如突然系统中有大量的用户涌进来，系统过载导致大量图片因为网络超时无法显示，就可以进行体验降级，比如降低图片的清晰度和大小来提升系统的处理能力。</li><li><strong>过载保护：</strong>将接收到的请求放在指定的队列中进行处理，如果请求等待时间超时了，就可以直接拒绝超时请求。再比如如果队列直接满了就可以清除队列中的一定数量的排队请求或者直接拒绝后续的请求来让系统不过载，实现系统的基本可用。</li><li><strong>故障隔离：</strong>出现故障的时候要做到故障隔离，避免影响其他的服务。</li><li><strong>弹性扩容：</strong>基于Metric和Monitor实现系统态势感知，做到弹性伸缩。</li></ol><p><strong>什么是最终一致性？</strong></p><p>他强调的是在系统中的所有的数据副本，在经过一段时间的同步之后，最终能够达到一个一致的状态。本质是需要系统保证最终数据能够达到一致性而不是需要实时保证系统数据的强一致。</p><p>如何实现最终一致性？</p><ol><li><strong>读时修复：</strong>在写数据的时候不关心失败还是成功，在读取数据的时候，我们可以同时读取多个节点的同一份数据，然后按照一定的规则检测数据的不一致，比如以超过半数的数据为准，进行修复。极端情况下，如果所有节点的数据都不一样，应该听谁的呢？通过多次执行异步修复来实现一致性，待做。</li><li><strong>写时修复：</strong>在写入数据的时候，如果其中一个写失败了就会缓存起来，然后系统自动通过重试的手段进行修复。这种写时修复不需要进行数据对比，<strong>性能最好，推荐优先实现</strong>。本质是“失败-缓存-重传”的重试机制，不涉及到一致性对比</li><li><strong>异步修复：</strong>通过定时不同节点比对的方式，来对照数据是否需要修复，如果需要修复就进行同步。这种修复方式涉及到数据的对比，性能不是很好。定时对账检测副本数据的一致性。</li></ol><p><strong>总结：</strong></p><p>BASE理论其实是对CAP中一致性和可用性权衡的结果，它来源于对大规模互联网分布式系统实践的总结，是基于CAP定理逐步演化而来的。核心思想就是如果不是必须的话，不推荐事先事务或者强一致性，鼓励可用性和性能优先，根据业务的场景特点来实现非常弹性的基本可用，以及实现数据的最终一致性。</p><p>BASE理论在很大程度上解决了事务型系统在性能、容错、可用性等方面的痛点。</p><h2 id="5-Distributed-ID"><a href="#5-Distributed-ID" class="headerlink" title="5. Distributed ID"></a>5. Distributed ID</h2><h3 id="5-1-雪花算法"><a href="#5-1-雪花算法" class="headerlink" title="5.1 雪花算法"></a>5.1 雪花算法</h3><p>正常来说，Snowflake由64bit的二进制数字组成。</p><ul><li>第0位：符号位，表示正负。但是默认我们都是正数，因此默认是0</li><li>第1~41位：这41bit用来表示时间戳，但是并不推荐直接使用当前时间的时间戳，而是使用当前时间戳 - 固定的开始时间戳。这样就可以让其开始的值较小，然后最多可支撑2^41毫秒，大约69年。</li><li>第42~52位：一共10bit，一般前5位用来表示机房ID，后5位表示机器ID，当然可以灵活调整</li><li>第53~64位：共12bit，用来表示序列号，自增，代表单台机器每毫秒能够产生的最大ID数，也就是4096个。</li></ul><p>实际中，我们也会对Snowflake进行改造，比如将业务类型信息给加进去。</p><h2 id="6-Algorithm"><a href="#6-Algorithm" class="headerlink" title="6. Algorithm"></a>6. Algorithm</h2><h3 id="6-1-Paxos"><a href="#6-1-Paxos" class="headerlink" title="6.1 Paxos"></a>6.1 Paxos</h3><p>Paxos算法是基于消息传递且具有高度容错特性的<strong>共识性算法</strong>。</p><p>在我们常见的分布式系统中，总会发生通信异常、节点故障、网络分区等情况。Paxos算法需要解决的问题在于<strong>如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值（可以是一条日志，也可以是一条命令）达成共识性，并且保证不论发生以上任何异常，都不会破坏整个系统决议的共识机制</strong></p><p>在Paxos算法中，并不会去考虑拜占庭将军问题，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息。只要等待足够的时间，消息就会被传到。</p><p>但是需要考虑的是各种角色的计算速度可能不同，甚至可能因为宕机而终止运行，随后又被重启。在没有记录之前已选择的value的情况下，之前选择的value会丢失，因此需要记录之前已选择的value。</p><p>消息可以延时，可以重复，可以丢失，但是其内容无法被篡改。</p><p>Basic Paxos</p><p>对于Basic Paxos来说，它描述的是多节点之间如何就某个值（提案 value）达成共识。</p><p>在Basic Paxos中，一共有三种角色，每个节点都可以允许身兼数职。</p><ul><li>proposers提出提案，提案信息包括提案编号和提议的vlaue</li><li>acceptor收到提案之后可以接受（accept）提案，如果提案获得多数派的acceptors的接受，则该提案被批准（chosen）</li><li>learners只能学习被批准的提案，相当于一个存储备份</li></ul><p>划分角色之后就可以拥有更加精确的定义：</p><ol><li>决议（value）只能在被proposers提出之后才能被批准（未经批准的决议称为“提案proposal”）；、</li><li>在一次Paxos算法的执行实例中，只能chosen一个value；</li><li>learners只能获得被chosen的value。</li></ol><p>如果只有一个acceptor，有很多个proposer</p><p><img src="image-20220503212916439.png" alt="image-20220503212916439"></p><p>对于这种情况，要想保证共识其实很简答，我们只需要让整个acceptor只接受第一个proposer提出的value就可以了，后续的一概不接受。这种方案简单易懂，但是如果当前acceptor挂掉之后且无法恢复了，被选择的value也跟着丢失了，显然是符合要求的。</p><p>接下来只需考虑多个Proposer和多个Acceptor的情况。</p><blockquote><p><strong>P1：接受者必须接受它收到的第一个提案。</strong></p></blockquote><p>怎么去理解P1呢？加入不考虑系统故障或者消息丢失的情况，如果我们只有一个proposer和一个acceptor，并且当proposer发送提案给acceptor的时候，如果acceptor不接受这个提案，那么就永远无法选出多数派，因此acceptor就必须接受它收到的第一个提案，至于是否要更换，这得看后续的推导过程。</p><p>但是P1同样也引入了新的问题，因为多个proposer可能会提出不同的提案，然后多个acceptor都接受了不同的提案，这就导致没有任何一个值被接受者中的大多数所接受。因此结合P1来说，那么得到隐藏的条件：<strong>必须允许接受者接受不止一个提案</strong>。我们可以让每个提案由一个唯一的递增的提案编号和提案所对应的值组成。当一个带有某个值的提案被大多数的acceptor接受了之后，这个值就算被选定了。</p><blockquote><p>**P2：如果</p></blockquote><p><strong>上面是算法的推导过程，下面是算法的总结：</strong></p><p>通过一个决议分为两个阶段：</p><ol><li>prepare阶段：<ol><li>proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派</li><li>acceptor收到prepare消息之后，如果提案的编号大于它已经回复的所有prepare消息（回复消息表示accept），则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案。</li></ol></li><li>批准阶段：<ol><li>当一个proposer收到了多数acceptors对prepare的回复之后，就进入批准阶段。它要向prepare的请求的acceptors发送acceptor请求，包括编号n和</li></ol></li></ol><p><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">Paxos算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://www.yisu.com/zixun/500499.html">一致性算法Paxos解决了什么问题 - 大数据 - 亿速云 (yisu.com)</a></p><p><a href="https://juejin.cn/post/6844903450585595912#heading-3">Paxos原理（一）：Basic Paxos - 掘金 (juejin.cn)</a></p><h3 id="6-2-MapReduce"><a href="#6-2-MapReduce" class="headerlink" title="6.2 MapReduce"></a>6.2 MapReduce</h3><p><strong>概述：</strong>MapReduce是一个编程模型，用于处理和生成超大数据集的算法模型的相关实现。用户创建一个Map函数处理一个具有key&#x2F;value对的数据集合，并输出中间值，创建一个Reduce函数将具有相同中间key值的中间value值。</p><p>使用MapReduce就只需要关注如何分割大数据进行处理；如果管理大量计算机集群之间的调度和错误处理，以及消息通信。</p><p><img src="image-20220609081925095.png" alt="image-20220609081925095"></p><p><strong>执行步骤：</strong></p><ol><li>用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。（ It then starts up many copies of the program on a cluster of machines）</li><li>这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</li><li>被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key&#x2F;value pair，然后把key&#x2F;value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key&#x2F;value pair，并缓存在内存中。</li><li>缓存中的key&#x2F;value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key&#x2F;value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</li><li>当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li><li>Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</li><li>当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</li></ol><p><strong>容错</strong></p><ul><li><p>master会周期性的ping每个worker，如果约定的时间内没有收到worker返回的信息，就会认为这个worker失效。所有由这个worker执行完成的Map任务，或者正在执行的Map&#x2F;Reduce任务都会被重新设置为空闲，然后会将这些空闲任务交给其余的worker执行。</p><p>因为对于Map任务来说，它的中间结果存储在该Map所在的机器上面，而对于Reduce任务，它的输出结果存储在全局文件系统上，因此它的宕机并不影响已经完成了的Reduce任务。</p></li><li><p>如果master宕机了，为了避免全部重算，就可以使用checkpoint机制，也就是master周期性的将它的数据结构（里面存储了每一个Map和Reduce任务的状态和其他信息）写入磁盘。 就算master宕机了，就可以启动另一个master进程，然后从checkpoint开始重新执行MapReduce操作。</p></li></ul><p><strong>备用任务</strong></p><p>如果一台机器花费了很长时间才完成最后几个Map或Reduce任务，就会拖累整个MapReduce的操作效率。于是引入备用任务机制，当一个MapReduce操作接近完成的时候，master就会调度备用任务进程来执行剩下的处于处理中状态的任务。只要任何一个进程完成了任务，就会将这个任务标记为已完成。</p><p>参考资料：</p><ul><li><a href="https://developer.aliyun.com/article/31829">MapReduce论文中文翻译-阿里云开发者社区 (aliyun.com)</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">rfeet.qrk (mit.edu)</a></li><li></li></ul><h3 id="6-3-Raft"><a href="#6-3-Raft" class="headerlink" title="6.3 Raft"></a>6.3 Raft</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>paper地址：<a href="http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf">Raft-Extend</a></p><p>Raft是用来管理复制日志（replicated log）的共识算法。他将共识算法的关键性因素切分成三个部分：</p><ul><li>leader election 领导者选举，当现存的leader发生故障时，一个新的领导人需要被选举出来。</li><li>log replication 日志复制，领导人必须从客户端接受log entries然后复制到集群中的其他的节点，并强制要求其他节点的日志和自己保持一致。</li><li>safety 安全性，如果在任何的服务器节点已经应用了一个确定的log entires到它的状态机中，那么其他服务器节点不能在同一个索引位置应用一个不同的指令。</li></ul><p>同时，Raft还拥有几个新特性：</p><ul><li><strong>强领导人</strong>：相对于其他的算法，Raft使用了更强的领导形式。log entries只能从领导人发送给其他的服务器。</li><li><strong>领导选举</strong>：使用一个随机计时器来选举领导人。这种机制相对于其他共识算法的心跳机制来说，在解决冲突的时候会更加简单快捷。</li><li><strong>成员关系调整</strong>：Raft使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使集群在成员变换的时候依然可以继续工作。</li></ul><p><img src="raft-%E5%9B%BE2.png" alt="图 2"></p><p>上图的翻译如下所示：</p><p><strong>State</strong></p><p>所有服务器上的持久性状态（在响应RPC请求之前，已经更新到了稳定的存储设备）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的candidateId，如果没有投给任何候选人则为空</td></tr><tr><td>log[]</td><td>log entries，每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><p>所有服务器上的易失性状态</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知已提交的最高的日志条目的索引（初始值为0，单调递增）</td></tr><tr><td>lastApplied</td><td>已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p>领导人（服务器）上的易失性状态（选举后已经重新初始化）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>nextIndex[ ]</td><td>对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）</td></tr><tr><td>matchIndex[]</td><td>对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><h4 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h4><p>集群刚开始的时候，所有的节点都是Follower，然后就会立马开始选举。如果一个候选者赢得选举（大多数），他就会在接下来的任期中成为Leader。如果这一任任期中没有Leader出现，就会立马下一轮选举。</p><p>如果一个服务器发现自己的当前任期号比其他人小，就会更新自己的编号到较大的那一方的任期编号。如果一个候选者或者Leader发现自己的任期号过期了，那么就会立马变成跟随者。如果一个节点接收到了一个包含过期的任期号的请求，就会直接拒绝该请求。</p><p>服务器节点之间通过RPC通信：</p><ul><li>RequestVoteRPC在候选人选举期间发起</li><li>AppendEntriesRPC由领导人发起，用来复制日志和提供一种心跳机制。</li></ul><h4 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h4><p>领导人周期性的向所有跟随者发送心跳包，也就是不包含日志项内容的AppendEntriesRPC，来告诉其余的跟随者，自己是领导人，维护自己的权威。如果<strong>选举超时</strong>（一个跟随者在一段时间内没有接收到任何消息），那么该跟随者就会认为系统中没有可用的领导人，然后发起选举以选出新的领导人。</p><p>要开始一次选举过程，跟随者需要增加自己的任期然后将自己变成候选人，它向集群中的其他节点发送RequestVoteRPC。</p><ul><li>如果它获得了大部分票数，则自己成为领导者，然后向其他服务器发送心跳消息来阻止发起新的选举。</li><li>如果在投票期间候选人从其他服务器接收到声明它是领导人的AppendEntriesRPC。如果这个领导人的任期号（包含在此次的RPC中）不小于候选人当前的任期号，那么候选人就会承认该领导人合法并让自己变成跟随者。如果此时RPC中的任期号比自己小，就会拒绝这次RPC并继续保持自己的候选者状态</li><li>如果多个候选者既没有赢也没有输，就会导致每一个候选者都会超时，然后通过增加当前任期号来开始下一轮选举。Raft通过随机选举超时时间的方式来确保很少会发生选票瓜分的情况，就算发生也能很快解决。<strong>选举超时时间是从一个固定的区间随机选择（150-300ms）</strong>。这样就可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时。然后它赢得选举并在其他服务器超时之前发送心跳包。同样这种随机机制还会被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性</li></ul><p><strong>在 Raft 算法中，随机超时时间是有 2 种含义的</strong>：</p><ol><li>跟随者等待领导者心跳信息超时的时间间隔，是随机的；</li><li>如果候选人在一个随机时间间隔内，没有赢得过半票数，那么选举无效了，然后候选人发起新一轮的选举，也就是说，等待选举超时的时间间隔，是随机的。</li></ol><h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p>领导者被选出来之后，就开始为客户端提供服务。客户端每一个请求都包含一条被复制状态机执行的指令。领导人会将该指令作为新的log entry附加到日志中，然后并行发起AppendEntriesRPC给其他服务器，让他们复制这条日志条目。如果该条目被安全复制，领导人会应用这条日志条目到它的状态机中然后将执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，又或者网络丢包，领导人会不断重复尝试AppendEntriesRPC直到所有跟随者最终存储了所有日志条目。</p><p><img src="raft-%E5%9B%BE6.png" alt="图 6"></p><p>当领导人将创建的日志条目复制到大多数服务器上的时候，日志条目就会被提交。同时领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。</p><p>领导人会强制跟随者直接复制自己的日志来处理不一致的问题。<strong>领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。</strong>这些操作在进行AppendEntiresRPC的一致性检查的时候完成。</p><p>领导人针对每一个跟随者维护了一个nextIndex，表示下一个需要发送给跟随者的日志条目的索引地址。初始值为Leader的最后一条日志的index + 1。如果Follower的日志和Leader不一样，在下一次RPC的一致性检查的时候就会失败。被Follower拒绝之后Leader会减小nextIndex并进行重试。最终nextIndex会在某个位置检查成功。成功之后RPC就会成功，这时候就会将跟随者冲突的日志条目全部删除并加上Leader的日志。</p><ul><li>如果有Follower因为某些原因没有给Leader响应，那么Leader会不断重复发送AppendEntriesRPC，哪怕Leader已经回复了客户端</li><li>如果有Follower崩溃后恢复，这时候Raft追加条目的一致性检查生效，保证Follower能按顺序恢复崩溃后的缺失的日志。</li><li>Raft的一致性检查：Leader在每一个发往Follower的追加条目RPC中，会放入<strong>前一个日志条目的索引位置和任期号</strong>，如果Follower在它的日志中找不到前一个日志，那么它就会拒绝此日志，Leader收到Follower的拒绝之后会发送前一个日志条目，从而逐渐向前定位到Follower前一个缺失的日志。</li></ul><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p><strong>选举限制</strong>：如果候选人的日志至少和大多数服务器节点一样新，那么它一定持有了所有已经提交的日志条目。RequestVoteRPC有如下限制：RPC中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。Raft通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><p><strong>提交之前任期内的日志条目</strong></p><p>当Leader复制之前任期里的日志时，Raft会为所有日志保留原始的任期号。</p><h2 id="7-LoadBalance"><a href="#7-LoadBalance" class="headerlink" title="7. LoadBalance"></a>7. LoadBalance</h2><h3 id="7-1-升级版随机算法"><a href="#7-1-升级版随机算法" class="headerlink" title="7.1 升级版随机算法"></a>7.1 升级版随机算法</h3><p>对于普通的随机算法，实现其实是非常简单的，但是在实际情况中，其实每台服务器的性能都不太一样，因此每台服务器所能承受的压力就会不一样。<strong>而加权随机算法就是为了解决这个问题</strong></p><p>比如我们有A、B、C三台服务器，然后它们的权重分别是5、3、2。</p><p><strong>加权随机算法一：</strong>可以新建一个List，然后将每台服务器权重数量的值加到这个List里面，比如上述例子中List里面有5个A，3个B，2个C，然后根据List的长度做一个随机，看看最终落到哪个服务器上，因为权重越高的，随机概率也就越大。</p><p>但是实际上一个服务器的权重肯定不会是这么小的数，而且万一服务器很多，维护一个这么长的List对性能影响其实是比较大的。</p><p><strong>加权随机算法二：</strong>这个就比较巧妙了，我们只需要维护一个这几台服务器所有权重的大小和，比如上述例子中就是5+2+3&#x3D;10。然后对10进行一个随机，取出的值一个个去比较。比如随机值是7，发现7比5要大，所以肯定不是落在服务器A上，然后下一步就将7-5&#x3D;2，发现2小于3，就可以判断这次的请求是落在服务器B上的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getServer</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">totalWeight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)WEIGHT_LIST.values().stream().mapToInt(s -&gt; s).summaryStatistics().getSum();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(totalWeight);<br>    <span class="hljs-keyword">for</span> (String ip : WEIGHT_LIST.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> WEIGHT_LIST.get(ip);<br>        <span class="hljs-keyword">if</span> (pos &lt; weight) &#123;<br>            <span class="hljs-keyword">return</span> ip;<br>        &#125;<br>        pos -= weight;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; WEIGHT_LIST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">static</span> &#123;<br>    WEIGHT_LIST.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">5</span>);<br>    WEIGHT_LIST.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>);<br>    WEIGHT_LIST.put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-优秀的平滑加权轮询算法"><a href="#7-2-优秀的平滑加权轮询算法" class="headerlink" title="7.2 优秀的平滑加权轮询算法"></a>7.2 优秀的平滑加权轮询算法</h3><p>对于没有加权要求的轮询算法，实现简单，就是维护一个指针，然后每遍历一次就让这个指针加一，注意这里肯定要有个同步机制。</p><p>但是针对于加权轮询算法，依照上述的负载均衡算法，可以维护一个大List，也可以改造一下加权随机算法二，让pos的值从随机变成每次加一。</p><p>注意真实环境中，肯定不会去维护这么一个指针，而是利用请求的一个RequestId，进行取余后选择。</p><p>但是对于这种加权轮询方式，其实是有问题的，比如ABC权重分别是511，那么加权轮询的结果是AAAAABC，可以看到一开始会有大量的请求都打在服务器A上，明显是有问题的，如果结果变成AABACAA之类的，就会优化很多。</p><p>因此就有了<strong>平滑加权轮询算法</strong></p><p>一开始的时候A、B、C的currentWeight都是0，然后第一轮，让它们的currentWeight加上原来的权重，也就是currentWeight分别为5、1、1，从中选出最大的那个，也就是A，接着让5减去总和7变成-2，此时currentWeight分别为-2、1、1。然后第二轮接着循环，先加上原来的权重，变成3、2、2，再选出最大值中的那个服务器，以此类推。最终发现7次以后currentWeight又重新变成了000，开启下一个循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Weight&gt; weightMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getServer</span> <span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">totalWeight</span> <span class="hljs-operator">=</span> ServerIps.WEIGHT_LIST.values().stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br>    <span class="hljs-comment">// 初始化weightMap</span><br>    <span class="hljs-keyword">if</span> (weightMap.isEmpty()) &#123;<br>        ServerIps.WEIGHT_LIST.forEach((ip, weight) -&gt; &#123;<br>            weightMap.put(ip, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weight</span>(ip, weight, weight));<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 找到currentWeight中的最大值</span><br>    <span class="hljs-type">Weight</span> <span class="hljs-variable">maxCurrentWeight</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (Weight weight : weightMap.values()) &#123;<br>        <span class="hljs-keyword">if</span> (maxCurrentWeight == <span class="hljs-literal">null</span> || weight.getCurrentWeight() &gt; maxCurrentWeight.getCurrentWeight()) &#123;<br>            maxCurrentWeight = weight;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最大值减去总权重</span><br>    maxCurrentWeight.setCurrentWeight(maxCurrentWeight.getCurrentWeight() - totalWeight);<br>    <span class="hljs-comment">// 所有的IP的currentWeight都加上原始权重</span><br>    <span class="hljs-keyword">for</span> (Weight weight : weightMap.values()) &#123;<br>        weight.setCurrentWeight(weight.getCurrentWeight() + weight.getWeight());<br>    &#125;<br>    <span class="hljs-comment">// 返回之前的最大值所对应的IP</span><br>    <span class="hljs-keyword">return</span> maxCurrentWeight.getIp();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>        System.out.println(getServer());<br>    &#125;<br>    <span class="hljs-comment">// 输出结果为AABACAA</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-基于哈希环的一致性哈希算法"><a href="#7-3-基于哈希环的一致性哈希算法" class="headerlink" title="7.3 基于哈希环的一致性哈希算法"></a>7.3 基于哈希环的一致性哈希算法</h3><p>其实就是将每台服务器都映射到一个哈希环上的一个位置上，然后同时在环上还建立很多的虚拟节点，让服务器的分布尽量散列化。虚拟节点越多流量越均衡，哈希算法越散列流量也将越均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHash</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SortedMap&lt;Integer, String&gt; virtualNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">VIRTUAL_NODES</span> <span class="hljs-operator">=</span> <span class="hljs-number">160</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 对每个真实的节点都添加虚拟节点，虚拟节点会根据哈希算法进行散列。</span><br>        <span class="hljs-keyword">for</span> (String ip : ServerIps.LIST) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> getHash(ip + <span class="hljs-string">&quot;VN&quot;</span> + i);<br>                virtualNodes.put(hash, ip);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getServer</span><span class="hljs-params">(String client)</span> &#123;<br>        <span class="hljs-comment">// 获得客户端请求来的IP地址的哈希值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> getHash(client);<br>        <span class="hljs-comment">// 得到大于该Hash值的排好序的Map</span><br>        SortedMap&lt;Integer, String&gt; sortedMap = virtualNodes.tailMap(hash);<br>        <span class="hljs-comment">// 如果Map为null，就相当于环一样，找到第一个，否则找到sortedMap中的第一个</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> sortedMap.firstKey();<br>        <span class="hljs-keyword">if</span> (nodeIndex == <span class="hljs-literal">null</span>) &#123;<br>            nodeIndex = virtualNodes.firstKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sortedMap.get(nodeIndex);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHash</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">// 自定义哈希算法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-4-最小活跃数算法"><a href="#7-4-最小活跃数算法" class="headerlink" title="7.4 最小活跃数算法"></a>7.4 最小活跃数算法</h3><p>上述算法都是以客户端的眼光来看的，而最小活跃数是按照服务端的眼光来看，如果当前服务器的积压请求比较多，就少给它点请求；如果当前服务器积压请求比较少，就多给它点请求。</p><p>一开始所有服务器的活跃数都是0，然后每收到一个请求活跃数就加1，完成请求之后活跃数就减1。注意这里就不对服务器请求处理相关逻辑进行模拟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务器当前的活跃数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; ACTIVITY_LIST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Integer&gt;();<br><span class="hljs-keyword">static</span> &#123;<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.1&quot;</span>, <span class="hljs-number">2</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.2&quot;</span>, <span class="hljs-number">0</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.3&quot;</span>, <span class="hljs-number">1</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.4&quot;</span>, <span class="hljs-number">3</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.5&quot;</span>, <span class="hljs-number">0</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.6&quot;</span>, <span class="hljs-number">1</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.7&quot;</span>, <span class="hljs-number">4</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.8&quot;</span>, <span class="hljs-number">2</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.9&quot;</span>, <span class="hljs-number">7</span>);<br>    ACTIVITY_LIST.put(<span class="hljs-string">&quot;192.168.0.10&quot;</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeastActive</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getServer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 找出当前活跃数最小的服务器</span><br>        Optional&lt;Integer&gt; minValue = ServerIps.ACTIVITY_LIST.values().stream().min(Comparator.naturalOrder());<br>        <span class="hljs-keyword">if</span> (minValue.isPresent()) &#123;<br>            List&lt;String&gt; minActivityIps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            ServerIps.ACTIVITY_LIST.forEach((ip, activity) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (activity.equals(minValue.get())) &#123;<br>                    minActivityIps.add(ip);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">// 最小活跃数的ip有多个，则根据权重来选，权重大的优先</span><br>            <span class="hljs-keyword">if</span> (minActivityIps.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 过滤出对应的ip和权重</span><br>                Map&lt;String, Integer&gt; weightList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Integer&gt;();<br>                ServerIps.WEIGHT_LIST.forEach((ip, weight) -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (minActivityIps.contains(ip)) &#123;<br>                        weightList.put(ip, ServerIps.WEIGHT_LIST.get(ip));<br>                    &#125;<br>                &#125;);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">totalWeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">sameWeight</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果所有权重都相等，那么随机一个ip就好了</span><br>                Object[] weights = weightList.values().toArray();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weights.length; i++) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> (Integer) weights[i];<br>                    totalWeight += weight;<br>                    <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="hljs-number">0</span> &amp;&amp; !weight.equals(weights[i - <span class="hljs-number">1</span>])) &#123;<br>                        sameWeight = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                java.util.<span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Random();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">randomPos</span> <span class="hljs-operator">=</span> random.nextInt(totalWeight);<br>                <span class="hljs-keyword">if</span> (!sameWeight) &#123;<br>                    <span class="hljs-keyword">for</span> (String ip : weightList.keySet()) &#123;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> weightList.get(ip);<br>                        <span class="hljs-keyword">if</span> (randomPos &lt; value) &#123;<br>                            <span class="hljs-keyword">return</span> ip;<br>                        &#125;<br>                        randomPos = randomPos - value;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> (String) weightList.keySet().toArray()[<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Random().nextInt(weightList.size())];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> minActivityIps.get(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不存在最小的值，就从活跃的List中随机选择一个</span><br>            <span class="hljs-keyword">return</span> (String) ServerIps.ACTIVITY_LIST.keySet().toArray()[<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Random().nextInt(ServerIps.ACTIVITY_LIST.size())];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试话术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试话术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的系统设计题</title>
    <link href="/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="如何解决大文件上传问题"><a href="#如何解决大文件上传问题" class="headerlink" title="如何解决大文件上传问题"></a>如何解决大文件上传问题</h2><p>可以将大文件进行分片，前端将所有文件分片， 然后传给后端之后，然后上传到服务器上。</p><p>比如我们一开始选择一个文件，然后生成一个文件的唯一标识，然后检查服务器中该文件有没有上传过，如果上传过，并且该文件所有的分片都上传完毕了，就可以直接秒传。</p><p>如果该文件没有上传过，就将其进行分片上传，然后在服务器中将这些分片进行合并，此次文件上传结束。</p><p>如果该文件上传过，但是只是上传了部分分片，就可以将该文件的剩余的分片进行上传。</p><h2 id="如何设计秒杀系统"><a href="#如何设计秒杀系统" class="headerlink" title="如何设计秒杀系统"></a>如何设计秒杀系统</h2><p>其实秒杀的逻辑比较简单，就是生成订单，然后减库存，还有一些其余的操作，但是秒杀的难点就在于会有一瞬间的超高流量，也就是高并发，可能会导致很多问题。</p><p>也就是说，设计一个秒杀系统需要保证：<strong>高并发、高性能、高可用、一致性</strong>。</p><ul><li>首先对于热点数据，我们可以使用<strong>redis进行一个缓存</strong>，同时也最好在JVM中写入一份实例，并设置过期时间。因为存放在JVM中的数据访问速度肯定是比存在Redis中的数据效率要高的。但是还得注意如何保障Redis、MySQL、JVM中数据的一致性。</li><li>同时也可以使用<strong>验证码</strong>的方式来进行一个流量削峰。因为每个人输入验证码的速度是不一样的。</li><li>使用<strong>RabbitMQ</strong>来进行一个流量削峰。</li><li>搭建Redis集群，增强它的高可用。</li><li>可以使用Sentinal，提供流量控制、熔断降级、系统自适应保护等功能来保护系统的稳定性和可用性。 </li><li>进行一个库存预热，将秒杀的商品的数量放在Redis或JVM中，每秒杀一个商品就会减少一个库存。每一个秒杀请求都先去查看redis或JVM中还有没有库存，这样可以拦截很多请求，减少MySQL的压力。</li><li>使用MQ进行异步处理。比如我们秒杀成功的时候可以生成消息发送到MQ中，然后将消息发送给订单服务、支付服务、库存服务、短信服务等等。</li></ul><p>除了上述的性能优化，还得考虑系统的一致性，千万不能够出现超卖等现象。</p><p>可以在sql语句扣减库存的时候查询一下库存是否足够。而在redis扣减库存的时候，需要使用lua脚本保证原子性。</p><h2 id="如何设计一个排行榜"><a href="#如何设计一个排行榜" class="headerlink" title="如何设计一个排行榜"></a>如何设计一个排行榜</h2><p>可能第一眼看到这个系统设计，就想到了使用MySQL，然后配合ORDER BY关键字。对于用户数据量不大，并且排序需求不负责的项目倒是可以采用这种方法。好处就是实现简单，不用额外引入新的组件，成本较低。但是每次生成排行榜都比较消耗性能，无法适用于大数据量场景。</p><p>因此就可以使用Redis中的sorted set数据结构来实现排行榜功能。</p><h2 id="如何统计网站的访问量"><a href="#如何统计网站的访问量" class="headerlink" title="如何统计网站的访问量"></a>如何统计网站的访问量</h2><p>为每个页面都维护一个哈希表，网页ID + 日期作为key，value为这一天看过该网页的所有用户ID（set类型的数据结构）。每次访问页面的时候，都得去看看该用户当天是否已经访问过了该页面。在统计指定页面访问量的时候，可以求出set的大小就可以了。</p><p>但是这样消耗比较大，如果某网站一天之内的访问量非常大，比如一百万个不同的用户进行访问，就可能造成一个网页就得维护一个一百万的用户ID，还得不断判断指定用户当天是否访问过某页面。而且一个网站还不止一个页面。</p><p>因此就可以使用<strong>HyperLogLog</strong>（暂留）</p><h2 id="APP里未读消息已读、未读怎么设计？"><a href="#APP里未读消息已读、未读怎么设计？" class="headerlink" title="APP里未读消息已读、未读怎么设计？"></a>APP里未读消息已读、未读怎么设计？</h2><p>就拿微信或者钉钉中的群消息来说，发送者刚发出消息的时候群里其他群成员都是未读状态，陆陆续续有人看到了这个群消息，这时的消息变成x人已读，y人未读。每条消息对应一个唯一的messageId，每一个用户对应一个唯一的userId，应该如何保存这个消息对应的已读、未读状态呢？</p><p>简单粗暴的方法：</p><p>对于每一个messageId，存当前的readIds + unreadIds，当群成员A已读该消息的时候，就将A的userId从unreadIds中移除，然后写入到readIds中就可以了。</p><p>但是这肯定无法在面试的时候去说。</p><p>于是此时就可以使用bitmap去存，因为消息的已读和未读其实就是0&#x2F;1的状态。</p>]]></content>
    
    
    <categories>
      
      <category>面试话术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试话术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些常见面试题的回答</title>
    <link href="/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/"/>
    <url>/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="0-反问问题和自我介绍"><a href="#0-反问问题和自我介绍" class="headerlink" title="0. 反问问题和自我介绍"></a><strong>0. 反问问题和自我介绍</strong></h2><p><strong>反问问题：</strong></p><p>实习时间、实习生培养机制、部门技术栈</p><p>请问能不能谈谈你作为一个公司老员工对公司的感受？</p><p>我觉得我这次表现不是太好，你有什么建议或者评价给我吗？</p><p>接下来我会有一段时间的空档期，有什么值得注意的或者建议学习的吗？</p><p>未来如果我要加入这个团队，你对我的期望是什么？</p><h2 id="1-项目话术"><a href="#1-项目话术" class="headerlink" title="1. 项目话术"></a><strong>1. 项目话术</strong></h2><p>1、编写时间工具类的时候，使用的是SimpleDateFormat，但是多线程下，该类会出现问题，这就牵扯到使用threadlocal来进行更改。<strong>详情看笔记JUC进阶版第九章相关内容</strong></p><p>2、热点商品点赞计算器，点赞数加加统计，不要求实时精确。<strong>详情看笔记JUC进阶版8.5LongAdder相关内容</strong></p><p>3、问到项目的时候，可以说那个乐享小程序，用到了ThreadLocal的知识来结合JWT令牌和Spring拦截器获取当前用户的ID</p><p>4、字典树在项目中的应用：使用前缀树过滤黑白名单域名。</p><h3 id="1-1-线程池的应用"><a href="#1-1-线程池的应用" class="headerlink" title="1.1 线程池的应用"></a>1.1 线程池的应用</h3><p>在乐享平台中，对于进入活动详情页而言，我们需要查询一系列信息，包括：</p><ul><li>当前活动的基本信息，比如活动开始时间、结束时间、活动名称、活动地点、官方群等等，</li><li>而且还需要根据活动的publisherId查询活动发布者相关的信息，比如发布者的头像、名称、所属机构</li><li>当前用户是否收藏该活动，有一个中间表，一个用户可以收藏多个活动，一个活动可以被多个用户收藏</li><li>当前用户是否报名该活动，同样遵循第三范式，有一个中间表</li><li>是否关注该活动发布者，</li><li>考虑到每个活动方都会有自己额外的一些信息，不包括在基本信息之内的信息，用一张action_info表来管理，action_id、title、content。</li></ul><p>这些信息要去不同的表进行查询，而且相互之间关系不大，就可以试着使用线程池管理。</p><p>8核16G</p><table><thead><tr><th>压测前提</th></tr></thead><tbody><tr><td>固定actionID，随机userId，单次执行大约900ms；100 * 10压测下，吞吐量7.7&#x2F;sec，平均值</td></tr><tr><td>固定actionID，随机userId，单次执行大约300ms；100 * 10压测下，吞吐量6.6&#x2F;sec，线程池 20、200</td></tr><tr><td>加了索引，单次执行26左右（没用线程池），20左右（用了线程池）；压测下，</td></tr><tr><td>961\1006\1069</td></tr></tbody></table><p>技术参考：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)</a></p><p><strong>场景1】快速响应用户请求</strong></p><p>就比如用户要查看一个商品的信息，就需要将商品维度的一系列信息比如：从库存服务里面查找商品价格、库存服务里面查找商品库存、优惠券服务里面查找该商品所拥有的优惠券、商品服务里面查找商品的详细信息、SKU、SPU等等给聚合起来展示给用户。</p><p>从用户的体验来说，这个结果的响应越快越好。可以将各种服务的调用封装成任务异步并行的执行，最后再总的封装起来，这里就可以去使用<strong>CompletableFuture + 线程池</strong>的技术进行实现。<strong>这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务（采用同步队列SynchronousQueue），调高corePoolSize和maxPoolSize去尽可能创造更多的线程快速执行任务。</strong></p><p><strong>场景2】快速处理批量任务</strong></p><p>。。。。使用有界队列去缓冲大批量的任务，但是队列容量必须声明，防止任务无限制堆积。</p><p><strong>问题1】如何确定线程池的参数？</strong></p><p>我们应该怎么去确定线程池中的参数呢？最大线程数和核心线程数的值应该是多少呢？实际上在真正的业务中是很难合理预估的，</p><ul><li>一方面线程池的运行机制并不是很好理解，配置合理需要强依赖于开发人员的个人经验和知识；</li><li>另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异很大；</li><li>再者还可能受到硬件环境如CPU、内存、硬盘读写速度、网络状况等影响，</li></ul><p>这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p><p>注：<strong>可以说通用化公式以8核16线程cpu的服务器为例，核心线程设置为8，线程最大数量：可以调整为服务器线程x2</strong></p><p>但是为了更好的使用线程池，我们也可以去实现动态线程池（核心线程数、最大线程数、队列长度），将线程池的参数通过nacos等配置中心去进行配置。然后可以去设计一个系统去监控我们的项目中所有的线程池，在线程池中的线程数量即将达到阈值或者出现了RejectedException的时候，去触发警告，然后将警告信息推送到该服务相关负责人。负责人根据实际情况去通过nacos进行相关配置，降低故障发生的概率。</p><p><strong>不过还是存疑，具体仍然不知道实战中如何去使用它，以及到底是否真正的需要这种动态化线程池仍是一种未知。</strong></p><p><strong>【更多的核心线程数和最大线程数的配置见笔记7.3】</strong></p><p>面试时候可以将这些参数的选择理念说一说，然后如果说到具体的数据时，就说可以根据CPU核数*（1+IO耗时&#x2F;CPU耗时）来计算，但是其实还得考虑到具体的业务，和访问情况，需要不停的调整参数，考虑到这种因素，当时只是做了理论的实现</p><blockquote><p><strong>如果在线程池中的task中出现了没有捕获的异常会对当前线程有什么影响？对线程池有什么影响？</strong> </p></blockquote><p><a href="https://blog.csdn.net/weixin_37968613/article/details/108407774">https://blog.csdn.net/weixin_37968613/article/details/108407774</a></p><h3 id="1-2-Redis在项目中的应用"><a href="#1-2-Redis在项目中的应用" class="headerlink" title="1.2 Redis在项目中的应用"></a>1.2 Redis在项目中的应用</h3><p>购物车、不常用数据缓存、实现销量排行功能的时候，在第一个版本中，使用到了MySQL进行实现，并对访问次数进行索引建立。这里可以提一下在后续优化中，使用Redis实现排行榜的功能。</p><ul><li>List：展示活动最新评论中，就可以通过List实现</li><li>String：活动信息数据缓存、活动名额缓存，分布式锁解决缓存击穿问题</li></ul><h3 id="1-3-项目中的关于MySQL的优化"><a href="#1-3-项目中的关于MySQL的优化" class="headerlink" title="1.3 项目中的关于MySQL的优化"></a>1.3 项目中的关于MySQL的优化</h3><p>对商品的价格进行排序的时候，对商品价格建立了索引。同时当时是一次性将所有的数据都查出来了，然后进行优化，限制查询数据量。</p><h3 id="1-4-消息队列在项目中的应用"><a href="#1-4-消息队列在项目中的应用" class="headerlink" title="1.4 消息队列在项目中的应用"></a>1.4 消息队列在项目中的应用</h3><p>在订单服务的时候使用到了RabbitMQ，并且对MQ可靠性做了一定的保障。</p><h3 id="1-5-幂等性"><a href="#1-5-幂等性" class="headerlink" title="1.5 幂等性"></a>1.5 幂等性</h3><p>幂等性的特点就是多次相同的操作产生的影响均与一次执行的影响相同。</p><p><strong>场景1】唯一性索引</strong></p><p>一个电话号码只能注册一个用户，对于这种场景，就可以给用户表中的电话号码添加唯一性索引，就可以保证不会出现多个用户共用一个电话号码的情况。</p><p>比较适用于插入操作</p><p><strong>场景2】乐观锁</strong></p><ol><li>先查出当前要更新的数据的version</li><li>update table set name &#x3D; #xxx, version &#x3D; version + 1 where version &#x3D; #version</li></ol><p><strong>场景3】token令牌机制</strong></p><p><img src="image-20220427120006112.png" alt="image-20220427120006112"></p><ol><li>如果redis在第一次请求的时候挂掉了，都没有redis了就不用考虑后续流程了。</li><li>如果第一次请求删除缓存失败，就不会有操作数据库的行为</li><li>如果第一次请求删除操作非常长，但是redis的这种操作是单线程的，完全不用考虑此时另外一个请求的查询。</li><li>还有就是redis的确删除成功了，但是在返回的时候由于网络波动时间很长，然后在此期间另一个请求还是会发现redis中已经没有数据了，此次请求失败。</li></ol><h3 id="1-6-数据一致性"><a href="#1-6-数据一致性" class="headerlink" title="1.6 数据一致性"></a>1.6 数据一致性</h3><p>对于一致性要求高的业务，就可以采用<strong>异步更新缓存</strong>的方式去保证数据一致性：</p><ul><li><p>写操作会先去删除缓存，然后去更新数据库，之后通过使用canal中间件订阅binlog来异步更新缓存。</p></li><li><p>读操作先判断缓存中有没有，如果没有就去查询数据库，但是不会去将数据添加进redis进行缓存。</p></li><li><p>比如此时线程A执行写操作，它先删除缓存，然后在更新数据库的时候由于网络波动等各种原因耗时较长；线程B执行读操作，它会发现缓存中没有数据了，就去数据库读，但是此时数据库还没有更新完成，就读取的是旧数据，然后将旧数据返回。此时数据库并没有更新成功，因此不算数据不一致，没有出现问题。</p></li><li><p>然后A执行更新数据库成功之后，此时缓存中的数据就是脏数据了，就得马上将其删除，就可以通过canal订阅binlog的方式，去异步的删除掉redis中的缓存。</p></li></ul><p>也可以采用<strong>延时双删</strong>的方式，在更新完数据库之后，就可以sleep一段时间之后，再次去删除缓存，此时即使缓存中的数据是脏数据也会被删除。但是问题就是这个sleep的时间要根据具体的业务场景去设置，比较难以确定。而且要sleep一段时间，这会导致该更新方法的吞吐量下降。就可以采用<strong>异步删除</strong>的方式，将sleepM秒的操作和二次删除缓存的操作放到另一个线程里面，A线程在更新完数据库之后就直接结束。如果第二次删除缓存不成功，就可以采用重试的方式，直到删除成功。</p><p>而且对于StringRedisTemplate来说，使用delete操作会返回是否成功，如果失败了也可以选择抛出一个异常，然后对整个的更新方法进行一个事务回滚。更新操作都没了就不用谈数据不一致了。</p><p>对于我的商城项目来说，我缓存的是三级菜单，这种数据更新频率不高，而且对一致性要求并没有那么严格，因此出现短暂的数据不一致性是完全可以接受的。而且缓存并不是永久的，而是会有过期时间。</p><p><a href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">缓存和数据库一致性问题，看这篇就够了 | Kaito’s Blog (kaito-kidd.com)</a></p><blockquote><p><strong>如何保证本地缓存和分布式缓存的一致性？</strong></p></blockquote><p>比如Caffeine和Redis构成的二级缓存。</p><p>可以采用消息队列的方式：</p><ol><li>设置适当的过期时间，可以允许短暂的不一致，而达到最终一致性。</li><li>引入消息队列，保证消息的可靠性，但是增加了系统的复杂度</li></ol><h3 id="1-7-jwt"><a href="#1-7-jwt" class="headerlink" title="1.7 jwt"></a>1.7 jwt</h3><blockquote><p><strong>为什么使用cookie会导致csrf攻击？</strong></p></blockquote><blockquote><p><strong>为什么使用jwt能避免csrf攻击呢？</strong> </p></blockquote><h3 id="1-8-redis内存高利用"><a href="#1-8-redis内存高利用" class="headerlink" title="1.8 redis内存高利用"></a>1.8 redis内存高利用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestZsetFun</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ActionService actionService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        ZSetOperations&lt;String, String&gt; zSetOperations = redisTemplate.opsForZSet();<br>        ValueOperations&lt;String, String&gt; stringValueOperations = redisTemplate.opsForValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">301</span>; i++) &#123;<br>            <span class="hljs-type">Action</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> actionService.getById(i);<br>            stringValueOperations.set(<span class="hljs-string">&quot;actionInfo:&quot;</span> + i, JSON.toJSONString(action));<br>            zSetOperations.add(<span class="hljs-string">&quot;hot_actions&quot;</span>, String.valueOf(i), <span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">LFULogIncr</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.random();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">baseval</span> <span class="hljs-operator">=</span> score - <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span> (baseval &lt; <span class="hljs-number">0</span>) baseval = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>/(baseval +<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (r &lt; p) score++;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">LFUDecrAndReturn</span><span class="hljs-params">(<span class="hljs-type">double</span> score,Long idleTime)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">idle_periods</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(idleTime / <span class="hljs-number">15</span>);<br>        <span class="hljs-keyword">if</span> (idleTime &gt; <span class="hljs-number">0</span>)<br>            score = (idle_periods &gt; score) ? <span class="hljs-number">0</span> : score - idle_periods;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">idleTime</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            interval = (Long)redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt;<br>                                                   connection.idletime(key.getBytes()).getSeconds());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> interval;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Action <span class="hljs-title function_">getActionFromRedis</span><span class="hljs-params">(Long actionId,<span class="hljs-type">double</span> score)</span> &#123;<br>        ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue();<br>        ZSetOperations&lt;String, String&gt; opsForZSet = redisTemplate.opsForZSet();<br>        <span class="hljs-comment">// 获取访问间隔</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">idleSeconds</span> <span class="hljs-operator">=</span> idleTime(<span class="hljs-string">&quot;actionInfo:&quot;</span> + actionId);<br>        <span class="hljs-comment">// 衰减分数</span><br>        score = LFUDecrAndReturn(score,idleSeconds);<br>        <span class="hljs-comment">// 增长分数</span><br>        score = LFULogIncr(score);<br><br>        opsForZSet.add(<span class="hljs-string">&quot;hot_actions&quot;</span>,String.valueOf(actionId),score);<br>        <span class="hljs-type">Action</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> JSON.parseObject(opsForValue.get(<span class="hljs-string">&quot;actionInfo:&quot;</span> + actionId),Action.class);<br>        <span class="hljs-keyword">return</span> action;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Action <span class="hljs-title function_">getActionWithScoreAdapt</span><span class="hljs-params">(Long actionId)</span> &#123;<br>        ZSetOperations&lt;String, String&gt; opsForZSet = redisTemplate.opsForZSet();<br>        <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> opsForZSet.score(<span class="hljs-string">&quot;hot_actions&quot;</span>, actionId + <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Action</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> actionService.getById(actionId);<br>            <span class="hljs-keyword">return</span> action;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> getActionFromRedis(actionId,score);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//        for (int i = 1; i &lt; 1000; i++) &#123;</span><br>        <span class="hljs-comment">//            getActionWithScoreAdapt((long) (Math.random() * 300 + 1));</span><br>        <span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//        for (int i = 1; i &lt; 30000; i++) &#123;</span><br>        <span class="hljs-comment">//            getActionWithScoreAdapt((long) (Math.random() * 150 + 1));</span><br>        <span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//        while (true) &#123;</span><br>        <span class="hljs-comment">//            getActionWithScoreAdapt(96L);</span><br>        <span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//        getActionWithScoreAdapt(124L);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">300</span>; i++) &#123;<br>            getActionWithScoreAdapt(Long.parseLong(String.valueOf(i)));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-MySQL相关面试题"><a href="#2-MySQL相关面试题" class="headerlink" title="2. MySQL相关面试题"></a><strong>2. MySQL相关面试题</strong></h2><h3 id="2-1-最左匹配原则"><a href="#2-1-最左匹配原则" class="headerlink" title="2.1 最左匹配原则"></a>2.1 最左匹配原则</h3><p>以最左边的为起点任何连续的索引都能匹配上，同时遇到范围查询（&gt; &lt; between lilke）就会停止匹配。</p><p>比如我们创建了一个联合索引，idx_abc(a, b, c)。在组合索引中，最底层的叶子节点先按照a列从左到右递增排序，但是b列和c列是无序的，而b列只有在a列值相等的情况下，才会小范围内有序，同理，c列只有在a和b都相等的情况下，才会小范围内有序。</p><p>B+树会先比较a列，才能确定下一步到底是往左还是往右，如果查询条件没有a列，B+树就不知道应该从哪个节点查起。</p><h3 id="⭐2-2-什么是ACID，分别用什么来保证他们"><a href="#⭐2-2-什么是ACID，分别用什么来保证他们" class="headerlink" title="⭐2.2 什么是ACID，分别用什么来保证他们"></a>⭐2.2 什么是ACID，分别用什么来保证他们</h3><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系 - 美团技术团队 (meituan.com)</a></p><ul><li><strong>原子性</strong>：事务是最基本的一个单位，一个事务要么全部完成，要么全部不完成，<strong>MySQL使用undo log来解决</strong></li><li><strong>一致性</strong>：有了原子性、隔离性、持久性的保证之后，事务的一致性才能得到保证（执行事务前后，数据保持一致，比如转账业务中，无论事务是否执行成功，转账人和收款人的总额应该是不变的）</li><li><strong>隔离性</strong>：并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库是独立的。<strong>使用锁机制、MVCC来保障</strong></li><li><strong>持久性</strong>：一个事务被提交之后，它对数据库中数据的更改是持久的，即使数据库发生故障也不应该对其有任何影响。<strong>使用redo log来保障</strong></li></ul><h3 id="⭐2-3-一条慢sql怎么去优化"><a href="#⭐2-3-一条慢sql怎么去优化" class="headerlink" title="⭐2.3 一条慢sql怎么去优化"></a>⭐2.3 一条慢sql怎么去优化</h3><p>如果是问：<strong>怎么处理MySQL的慢查询</strong>，就可以多一句：</p><p><strong>开启慢查询日志，准确定位到哪个sql语句出现了问题。</strong></p><p>如果这条语句大部分情况下正常，偶尔很慢：</p><ul><li>数据库在刷新脏页，比如redo log写满了需要同步到磁盘</li><li>执行的时候遇到锁</li></ul><p>如果这条语句一直执行的缓慢：</p><ol><li>首先看这条sql有没有索引，如果有索引，就看该sql语句有没有索引失效；查看是否走全表扫描，如果索引区分度比较低可能造成全表扫描。</li><li>看看是否是不恰当的sql语句，比如select *，或者在大数据表中使用&lt; limit m，n&gt;（比如找出10到20的记录，就可以写成<code>select xxx from t where id &gt;= 10 limit 10</code>），以及对非索引字段进行排序。</li><li>如果对语句的优化已经无法进行，可以考虑对表中的数据量是否过大，如果是的话就可以进行分库分表。</li></ol><h3 id="⭐2-4-MySQL如何避免死锁"><a href="#⭐2-4-MySQL如何避免死锁" class="headerlink" title="⭐2.4 MySQL如何避免死锁"></a>⭐2.4 MySQL如何避免死锁</h3><p>MySQL中死锁产生的原因：MySQL默认是RR级别，且可以使用行锁。如果事务A给account表的id &#x3D; 1这一行添加上了排它锁：<code>select * from account where id = 1 for update</code>，并且事务B给id &#x3D; 2的行记录添加排它锁。再次之后，事务A想给id &#x3D; 2的记录添加排它锁，事务B想给id &#x3D; 1的记录添加排它锁，这就会造成mysql的死锁。</p><p>以上例子是为了理解，下面才是场景案例：</p><p>比如我们创建订单的时候需要做幂等性，就得先通过订单号查询该订单是否存在，如果不存在则新增订单记录。</p><p><img src="image-20220314103016841.png" alt="image-20220314103016841"></p><p>这是因为两个事务都加了排它锁，又因为order_no为非唯一索引，又是RR级别，所以select的加锁类型为gap lock，这里gap范围是4到正无穷。当我们想插入数据的时候，会在插入间隙上再次获取插入意向锁。它和gap lock是冲突的，需要等待其它事务释放gap lock之后，才能获取到插入意向锁。</p><p>解决办法：</p><ol><li><strong>设置超时时间，当一个事务的等待时间超过设置的某个阈值，就对这个事务进行回滚</strong></li><li>合理设计索引，尽量减少锁的范围</li><li>尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。</li><li><strong>将order_no设置为唯一索引，可以利用它的唯一性来保障订单记录不重复创建。</strong></li><li><strong>使用其它方式来代替数据库实现幂等性校验。</strong></li><li>在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导 致的死锁问题；</li><li>更新表时，尽量使用主键更新</li><li>避免长事务，尽量将长事务拆解。</li></ol><h3 id="⭐2-4-说一下并发事务带来的问题："><a href="#⭐2-4-说一下并发事务带来的问题：" class="headerlink" title="⭐2.4 说一下并发事务带来的问题："></a>⭐2.4 说一下并发事务带来的问题：</h3><ul><li><strong>脏读：</strong>一个事务正在访问数据库并对数据进行了修改，而这个修改暂时没有提交到数据库中，此时另一个事务读取了这个数据，然后使用了这个数据。因为这个数据是未提交的数据，那么另一个事务读取到的就是脏数据。<strong>简而言之，一个事务可以读取其它事务未提交的数据</strong></li><li><strong>丢失修改：</strong>一个事务读取一个数据，另一个事务也读取了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据，那么第一个事务的修改就被丢失了。比如一个数据为20，第一个事务将其-1，第二个事务也是-1，最终该数据为19，丢失了一次修改。</li><li><strong>不可重复读：</strong>在一个事务中，第一次读取的数据和第二次读取的数据不一致。比如第一个事务读取了一个数据，此时第二个事务对这个数据进行了修改，并且提交。而此时第一个事务再次读取整个数据，就会发现两次读取的数据不一致。</li><li><strong>幻读：</strong>和不可重复读类似。第一个事务读取了数据之后，第二个事务进行了数据的insert，然后第一个事务再次读取，发现行数不一致，这就是幻读。</li></ul><h3 id="⭐2-5-说一下事务的隔离级别以及他们的原理"><a href="#⭐2-5-说一下事务的隔离级别以及他们的原理" class="headerlink" title="⭐2.5 说一下事务的隔离级别以及他们的原理"></a>⭐2.5 说一下事务的隔离级别以及他们的原理</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ol><li><strong>读未提交</strong>：原理：直接读取数据，不能解决任何并发问题</li><li><strong>读已提交</strong>：读操作不加锁，写操作加排他锁，解决了脏读。原理：利用MVCC实现，每一句语句执行前都会生成Read View（一致性视图）</li><li><strong>可重复读</strong>：MVCC实现，只有事务开始时会创建Read View，之后事务里的其他查询都用这个Read View。解决了脏读、不可重复读，快照读（普通查询，读取历史数据）使用MVCC解决了幻读，当前读（读取最新提交数据）通过间隙锁解决幻读（lock in share mode、for update、update、detete、insert），间隙锁在可重复读下才生效。（<strong>默认隔离级别</strong>）</li><li><strong>可串行化</strong>：原理：使用锁，读加共享锁，写加排他锁，串行执行</li></ol><h3 id="2-6-如何判断事务提交了？"><a href="#2-6-如何判断事务提交了？" class="headerlink" title="2.6 如何判断事务提交了？"></a>2.6 如何判断事务提交了？</h3><p>InnoDB存储引擎对事务采用了WAL技术（write-ahead logging），这种技术的思想是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志指的是redo日志</p><h3 id="2-7-什么时候用表锁，什么时候用行锁"><a href="#2-7-什么时候用表锁，什么时候用行锁" class="headerlink" title="2.7 什么时候用表锁，什么时候用行锁"></a>2.7 什么时候用表锁，什么时候用行锁</h3><ul><li>首先我们肯定绝大部分情况下都应该使用行锁，毕竟事务和行锁往往是我们之所以选择InnoDB存储引擎的原因。</li><li>事务需要更新大部分或者全部数据，表又比较大，如果使用默认的行锁，会导致该事务效率低，并且可能造成其它事务长时间等待和锁冲突，这时候可以使用表锁</li><li>事务涉及多个表，比较复杂，可能造成死锁导致大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><h3 id="2-8-count-、count-1-、count-列名"><a href="#2-8-count-、count-1-、count-列名" class="headerlink" title="2.8 count(*)、count(1)、count(列名)"></a>2.8 count(*)、count(1)、count(列名)</h3><p><strong>从执行结果来说</strong>：</p><ol><li>前两者没有区别，他们都不会去过滤空值</li><li>count(列名)会过滤空值</li></ol><p><strong>从执行效率来说</strong></p><ol><li>如果以列为主键，count（列名）优于count（1）</li><li>如果表中存在主键，count（主键列名）效率最优</li><li>如果表中只有一列，count（*）最优</li><li>如果表有多列，且不存在主键，count（1）优于count（*）</li></ol><p>所谓的count（1）其实就是计算一共有多少符合条件的行。1并不是表示第一个字段，而是表示一个固定值。</p><p>count（*）执行时会把星号翻译成字段的具体名字，效果也是一样，只不过多个一个翻译的动作，比固定值的方式效率稍微低一些。 </p><h3 id="2-9-Memory存储引擎"><a href="#2-9-Memory存储引擎" class="headerlink" title="2.9 Memory存储引擎"></a>2.9 Memory存储引擎</h3><p>Memory存储引擎将所有的数据都放在内存中，默认的索引结构是<strong>哈希索引</strong>，每个memory存储引擎的表实际上对应一个磁盘文件，<strong>该文件只存储表的结构，而表的数据都存储在内存中。</strong></p><h3 id="⭐2-10-redo-log、bin-log、undo-log"><a href="#⭐2-10-redo-log、bin-log、undo-log" class="headerlink" title="⭐2.10 redo log、bin log、undo log"></a>⭐2.10 redo log、bin log、undo log</h3><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p>首先我们知道，mysql中的数据是以页为单位，查询的时候会将该记录所在的整个页数据都加载到Buffer Pool中。然后会将”在某个数据页做了什么修改“记录到<strong>重做日志缓存（redo log buffer）</strong>中，接着会刷盘到redo log文件里。</p><p>我们必须知道的是，InnoDB存储引擎会有<strong>一个后台线程，每隔1秒，就会将redo log buffer中的内容写进文件系统缓存（page cache），然后调用<code>fsync</code>刷盘</strong>。也就是说，一个没有提交事务的redo log记录，也会刷盘。</p><p><strong>除此之外，当redo log buffer占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程会主动刷盘。</strong></p><p>但是除此之外，还有三种刷盘策略：</p><ol><li><strong>每次事务提交时不进行刷盘策略</strong>：如果MySQL挂了或者宕机了可能会有1秒的数据丢失</li><li><strong>每次事务提交时都将进行刷盘策略（默认）：</strong>只要事务提交，redo log记录就一定在磁盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或者宕机了，这部分日志丢了，但是事务还没有提交，所以日志丢了也不会有任何损失。</li><li><strong>每次事务提交时都只把redo log buffer中的内容写到page cache：</strong>如果仅仅只是MySQL挂了将不会有任何损失，但是宕机可能会有一秒钟数据的丢失。</li></ol><h4 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h4><p>redolog是物理日志，记录内容是”某个数据页上做了什么修改“。而binlog是逻辑日志，记录的是语句的原始逻辑，属于MySQL Server层。不管什么引擎，只要发生了表数据更新，都会产生binlog日志</p><p><strong>binlog有两种格式：</strong></p><ul><li><strong>statement</strong>：记录的内容是SQL语句原文，但是如果该SQL语句中包含了像<code>update_time=now()</code>之类的函数，就会导致与原库中的数据不一致。</li><li><strong>row</strong>：该格式记录的内容不再是简单的SQL语句了，还包含操作的具体数据，以该格式记录的内容看不到详细信息，需要通过<code>mysqlbinlog</code>工具解析出来。但是这种格式需要更大的容量来记录，比较占用空间，恢复与同步时会更加消耗IO资源，影响执行速度。</li><li><strong>mixed</strong>：前两者的混合，MySQL会判断这条SQL语句是否可能引起数据不一致，如果是就用row，否则使用statement。</li></ul><p><strong>写入时机</strong></p><p>事务执行期间，会先把日志写进<code>binlog cache</code>中，事务提交的时候，再将binlog cache写到binlog文件中。</p><p><img src="04-20220305234747840.png" alt="img"></p><p><strong>write</strong>只是将日志写入到文件系统的page cache，并没有持久化到磁盘上，所以速度比较快</p><p><strong>fsync</strong>才是将数据持久化到磁盘的操作。</p><p>他们的时机可以通过参数**<code>sync_binlog</code>**来控制，默认是0；</p><ul><li>为0表示每次提交事务只是执行write，由系统自行判断什么时候执行fsync</li><li>为1表示每次提交事务都会执行fsync，就如同redolog刷盘流程一样</li><li>为N（N&gt;1），表示每次事务只执行write，但是积累N个事务之后再进行fsync</li></ul><h4 id="3-两阶段提交"><a href="#3-两阶段提交" class="headerlink" title="3. 两阶段提交"></a>3. 两阶段提交</h4><p>redolog让数据库拥有了崩溃恢复的能力，binlog让数据库保证了集群架构的数据一致性。他们的侧重点不同；</p><p>而且redolog是在事务过程中不断写入，binlog只有在事务提交的时候才会写入。写入的时机不一样。</p><p>但是如果这两部分日志逻辑不一致，会发生问题。比如在写完redolog之后，写入binlog的时候发生了异常，导致binlog没有写成功。当MySQL重启恢复数据的时候，就会发现数据不一致。</p><p>解决办法，<strong>两阶段提交：将redolog的提交拆分成两个部分，prepare和commit</strong>。</p><p><img src="04-20220305234956774.png" alt="IMG/面试话术.asserts/04-20220305234956774.png"></p><p>如果binlog发生了异常导致没有写成功，MySQL根据redolog日志恢复数据的时候，发现redolog还处于prepare阶段，并且没有对应的binlog，就会回滚事务：</p><p><img src="05-20220305234937243.png" alt="img"></p><p>如果redolog设置commit阶段发生了异常呢？这就可以看下图的右边框框的流程图了，因为此时binlog肯定是写入成功了，能通过事务id找到binlog日志，所以MySQL认为是完成的，就会提交事务恢复数据。</p><p><img src="06-20220305234907651.png" alt="img"></p><h4 id="4-undo-log"><a href="#4-undo-log" class="headerlink" title="4. undo log"></a>4. undo log</h4><p>如果想要保证事务的原子性，就需要在异常发生的时候，对已经执行的操作进行回滚，而回滚是通过undolog来实现的，<strong>所有的事务进行的修改会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</strong>。而且回滚日志先于数据持久化到磁盘中，这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库时，数据库还能通过查询回滚日志来回滚将之前未完成的事务。</p><h3 id="2-10-唯一索引一定比普通索引快吗？"><a href="#2-10-唯一索引一定比普通索引快吗？" class="headerlink" title="2.10 唯一索引一定比普通索引快吗？"></a>2.10 唯一索引一定比普通索引快吗？</h3><ul><li>不一定</li><li>首先对于唯一索引的查询来说，因为知道是唯一了，在找到那条数据之后就会立即返回该数据，而普通索引还会继续匹配下一条数据，因此查询中唯一索引要比普通索引快，但是也是微乎其微的。因为查询的时候会以页为单位，将数据页加载进内存，不需要一条记录一条记录读取磁盘。</li><li>而对于更新来说，普通索引只需要将更新的数据放到changeBuffer就行了，而对于唯一索引来说，它必须去判断该数据的唯一性，还得将缓冲中的数据读入内存看有没有数据冲突。因此性能相对于普通索引来说比较慢。</li></ul><p><strong>补充</strong>：普通索引若数据再内存中直接内存中更新，否则会将更新操作先记录到change buffer中，等下一次查询将数据读到内存中再进行change buffer里相关更新操作后将数据返回，这样一来，再<strong>写多读少的情况下就减少了磁盘IO</strong>，若写完就马上查询，就大可不必用change buffer，不但没提高多少效率还造成维护change buffer额外消耗</p><h3 id="2-11-索引下推？"><a href="#2-11-索引下推？" class="headerlink" title="2.11 索引下推？"></a>2.11 索引下推？</h3><p><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)</a></p><p>索引下推能够有效的利用联合索引减少回表的次数。</p><p>比如有一张user表，并且建了个联合索引（name、age）。执行下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where name = &#x27;张%&#x27; and age = 10;<br># 如果查出来的记录如下：<br>id name age school<br>1    张三    10 长理<br>2    张四    11    长理<br></code></pre></td></tr></table></figure><p>1、如果没有索引下推，那么存储引擎会先根据name索引找到id为1和2的记录，然后进行回表（两条记录两次回表），将id为1和2的完整的行记录查询出来交给server层，接着server层就会以age &#x3D; 10进行筛选。</p><p>2、如果有索引下推，就会在查询到id为1的记录时判断它的age是否&#x3D;10，符合条件；而查询id为2的时候，发现age不符合就直接给筛选掉了。这里就只需要回表id为1的行记录，只回表一次。</p><blockquote><p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<code>InnoDB</code>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p></blockquote><h3 id="2-12-char和varchar的区别"><a href="#2-12-char和varchar的区别" class="headerlink" title="2.12 char和varchar的区别"></a>2.12 char和varchar的区别</h3><ol><li>char适用于对存取速度要求比较高或者占据空间一致的场景</li><li><strong>占据空间不同</strong>：char的长度是不可变的（<strong>固定为创建表时声明的长度，当char值被存储的时候，他们被空格填充到特定的长度，检索char值时也需要删除尾随空格。</strong>），而varchar的长度是可变的</li><li><strong>存取速度不同</strong>：char的存取速度比varchar要快，因为其长度固定，方便程序的存储和查找</li><li><strong>存储方式不同</strong>：char是对英文字符占用1个字节，对汉字占用两个字节；而varchar的存储方式是对每个英文字符占用2个字符，汉字也是。</li></ol><h3 id="2-13-SQL注入原因？如何防止"><a href="#2-13-SQL注入原因？如何防止" class="headerlink" title="2.13 SQL注入原因？如何防止"></a>2.13 SQL注入原因？如何防止</h3><ul><li><strong>原因：</strong>开发过程中不注意规范书写sql语句对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</li><li><strong>防止措施：</strong><ol><li>开启配置文件中的magic_quotes_gpc和magic_quotes_runtime设置</li><li>过滤掉关键词：select、update、insert</li><li>提高数据库和字段的命名技巧，对一些重要的字段根据程序的特点命名，不易被猜到。</li></ol></li></ul><h3 id="2-14-MySQL一天五万条以上的数据增量，预计运维三年，怎么优化？"><a href="#2-14-MySQL一天五万条以上的数据增量，预计运维三年，怎么优化？" class="headerlink" title="2.14 MySQL一天五万条以上的数据增量，预计运维三年，怎么优化？"></a>2.14 MySQL一天五万条以上的数据增量，预计运维三年，怎么优化？</h3><ol><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引</li><li>主从读写分离</li><li>进行分库分表，减少单表中的数据量</li><li>添加缓存机制</li><li>书写高效的SQL，比如只返回部分字段。</li></ol><h3 id="2-15-表a是主键、b是普通索引、c没有索引，select-a-b-c-from-table-where-b-x3D-x-会用到索引吗？"><a href="#2-15-表a是主键、b是普通索引、c没有索引，select-a-b-c-from-table-where-b-x3D-x-会用到索引吗？" class="headerlink" title="2.15 表a是主键、b是普通索引、c没有索引，select a,b,c from table where b &#x3D;x 会用到索引吗？"></a>2.15 表a是主键、b是普通索引、c没有索引，select a,b,c from table where b &#x3D;x 会用到索引吗？</h3><p>正常情况下，mysql根据普通索引b来查询到对应的主键，然后会回表去找到该主键对应的记录。</p><p>但是当数据库b列相同的列到达一定的量之后，会发现mysql根本没有用到索引，而是会全表扫描。我估计是mysql的查询优化器会进行权衡判断这种情况要不要用索引。（可能是mysql觉得这个时候回表再查已经无意义，毕竟b的区分度已经不高了。</p><h3 id="2-16-为什么不建议使用外键约束"><a href="#2-16-为什么不建议使用外键约束" class="headerlink" title="2.16 为什么不建议使用外键约束"></a>2.16 为什么不建议使用外键约束</h3><p>使用外键约束可以保证数据的完整性和一致性；级联操作方便；将数据的完整性判断托付给了数据库完成，减少程序代码量。</p><ol><li><strong>性能问题：</strong>如果有一张表table里面有两个外键，每次向table插入数据的时候都得看那两个外键对应的表中有没有相应的数据，增加了查询过程。</li><li><strong>并发问题：</strong>在每次修改数据都需要到另外一个表检查数据，需要获取额外的锁。更容易造成死锁。</li><li><strong>扩展性问题：</strong>在水平拆分和分库的情况下，外键是无法生效的。</li></ol><h3 id="2-17-讲一下索引失效？"><a href="#2-17-讲一下索引失效？" class="headerlink" title="2.17 讲一下索引失效？"></a>2.17 讲一下索引失效？</h3><p><strong>根本原因：</strong></p><ul><li>全局扫描的效率高于建立索引</li><li>索引涉及强制的类型转换</li><li>索引上做相关的运算操作</li></ul><p><strong>具体表现：</strong></p><ol><li>组合索引未使用最左前缀</li><li>like未使用最左前缀，<code>where A like &#39;%China&#39;</code></li><li>搜索一个索引而在另一个索引上使用order by，<code>where A = a order by B</code>，只是用A上的索引，因为查询只使用一个索引。</li><li>or语句前后没有同时使用索引会使索引失效。<code>where A = a1 or A = a2（生效）、where A = a1 or B = b1（失效）</code></li><li>如果列类型是字符串，要使用引号。（否则会进行类型转换）</li><li>where中索引列有运算，或者索引列使用了函数</li><li>where中在索引字段上使用not、&lt;&gt;、!&#x3D;（不等于操作符是永远不会用到索引的，因为对它的处理只会产生全表扫描，优化方法：key&lt;&gt;0改为key&gt;0 or key &lt; 0）</li><li>在索引列上使用IS NULL 或 IS NOT NULL：索引是不索引空值的，所有这样的操作不能使用索引，可以将NULL值变成数字类型，或给字符串类型设置一个默认值，判断是否等于默认值即可。</li></ol><p><strong>没必要使用到索引的场景</strong></p><ol><li>唯一性差</li><li>频繁更新的字段不用</li><li>where中不用的索引</li><li>索引使用&lt;&gt;时，效果一般</li></ol><h3 id="2-18-分库分表"><a href="#2-18-分库分表" class="headerlink" title="2.18 分库分表"></a>2.18 分库分表</h3><p>1、<strong>RANGE（水平分表）</strong></p><p>可以指定一个数据范围来表示分表，比如每百万条数据放到一个表中，但是这个得用redis或者其余的工具来维护表的ID。</p><p>2、<strong>HASH取模</strong></p><p>根据用户的ID进行hash取模的方式，将数据放到不同的表中，但是如果要对MySQL服务器进行扩容，在数据迁移的时候就很麻烦，还得重新去计算hash值。<strong>这时候就可以使用一致性哈希</strong></p><p>3、<strong>垂直分表</strong></p><p>将经常用的数据独立出来成为一张新的表。</p><blockquote><p>分库分表的缺点</p></blockquote><p><strong>事务问题</strong>：只能使用分布式事务，而无法使用本地事务</p><p><strong>跨节点join问题</strong>：可以分为两次查询解决这个问题</p><p><strong>ID问题</strong>：无法使用数据库提供的主键自增，最简单的可以考虑UUID</p><p><strong>排序分页问题</strong></p><p><strong>跨节点的count、order by、group by</strong>：可以从各个节点上得到结果之后，在应用层进行合并</p><h3 id="2-19-MySQL脏页刷盘"><a href="#2-19-MySQL脏页刷盘" class="headerlink" title="2.19 MySQL脏页刷盘"></a>2.19 MySQL脏页刷盘</h3><p>首先对于MySQL来说，如果想要更新数据，都是会查询到指定的记录所在的数据页，然后将整个数据页都加载出来到BufferPool中。然后它在BufferPool中进行更新。这时候就会导致内存数据页和磁盘数据页的不一致，这种不一致的内存数据页就被称为脏页。等到该脏页写入到磁盘之后，数据一致性就得到了解决。</p><p>但是试想一下， 如果每更新一条记录就对该页进行一次刷盘，无疑是非常消耗性能的；如果到达一个阈值之后才进行一次刷盘，数据库突然宕机之后，这些数据都会被丢失。<strong>因此就可以引入redolog进行记录</strong>，将每个记录在哪个页做了什么修改进行记录。</p><p>虽然redolog的内存缓冲区中的日志写入日志文件中也需要进行磁盘IO，但是这个过程是顺序IO的，在磁盘文件的尾部追加即可。而IO刷盘是随机存储的（需要寻找刷新的磁盘位置）。所以redolog写入磁盘的速度远远快于数据的刷盘。</p><p><strong>刷脏页情景</strong>：</p><ul><li><p><strong>redo log写满了</strong>：停止所有更新操作，推动checkpoint向前移动，推进那部分日志的脏页更新到磁盘中</p></li><li><p><strong>系统内存不够用</strong>：将一部分数据页进行淘汰，如果是干净页就直接淘汰，如果是脏数据页就全部同步到磁盘。</p><p>MySQL采用缓冲池来管理内存，当要读取的数据页没有在内存中的时候，就会从缓冲池中申请一个数据页，如果此时缓冲池满了，就必须得按照LRU算法将最近最少使用的数据页从内存中淘汰。如果淘汰的是一个干净页，直接释放然后复用。如果淘汰的是一个脏页，就必须得先将脏页刷到磁盘里面。</p></li><li><p>MySQL自认为空闲时，也会试着去找机会刷新脏页。</p></li><li><p>MySQL正常关闭之前，会将所有的脏页都flush到磁盘上</p></li></ul><p>如果一个查询要淘汰的脏页个数太多就会导致查询的响应时间变长。而日志写满，更新全部堵住，也是无法接受的。 </p><blockquote><p>InnoDB刷脏页的控制策略</p></blockquote><p>我们首先使用innodb_io_capacity参数设置InnoDB所在机器的磁盘能力，该值越高代表机器磁盘能力越强，假设设置的过低，那么innoDB就会认为这个机器的性能就这么差，导致刷脏页的速度比生成脏页的速度还慢，就造成脏页积累。</p><p>但是磁盘能力不只是用来刷新脏页，还得服务用户请求。因此设置的值也无法全力去用来刷新脏页，还得需要一个R%来控制磁盘能力中用来刷脏页的能力。</p><p>什么时候需要控制刷盘的速度？一种是内存中的脏页太多，一种是redo log写满。</p><p>InnoDB会根据innodb_max_dirty_pages_pct（脏页比例上限，默认75%）计算出一个0-100之间的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">F1(M) &#123;<br>    <span class="hljs-keyword">if</span> M &gt;= innodb_max_dirty_pages_pct then<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> * M/innodb_max_dirty_pages_pct;<br>&#125;<br><span class="hljs-comment">// M表示当前的脏页比例</span><br></code></pre></td></tr></table></figure><p>然后也会根据当前写入redo log的序号跟checkpoint对应的序号之间的差值计算出另一个0-100之间的数字，差值越大，计算出来的数字也就越大。 </p><p>最后就根据计算得到的两个值，取其中较大的值记为R，然后存储引擎就可以按照innodb_io_capacity定义的能力和百分之R相乘，这就是控制刷脏页的速度。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">能力：innodb_io_capacity * <span class="hljs-built_in">max</span>(脏页比例M，当前写入的redolog序列号差值<span class="hljs-built_in">N</span>) / <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><blockquote><p>InnoDB中的“连坐”策略</p></blockquote><p>一个查询请求执行过程中，如果需要先flush一个脏页的话，可能导致这个查询要比平时慢。</p><p>同时，在准备刷新一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，也会将它一起刷掉，依次递归。在innodb中，使用innodb_flush_neighbors参数来控制这个行为，1表示有连坐机制。注意的是，在MySQL8的时候，就将默认值改为0了，也就是只刷自己。因为在以前使用机械硬盘的时候，这个可以减少很多随机IO从而提升性能。而现在的SSD这种硬盘，效率较高，所以重点只关注自己，可以更快的执行完必要的刷盘操作，从而提升查询语句的响应时间。</p><h3 id="2-20-RR下MVCC不能完全解决幻读"><a href="#2-20-RR下MVCC不能完全解决幻读" class="headerlink" title="2.20 RR下MVCC不能完全解决幻读"></a>2.20 RR下MVCC不能完全解决幻读</h3><p>对于快照读来说，在InnoDB的RR模式下，依靠与MVCC的确可以解决幻读。但是它<strong>并没有解决更新操作后的幻读</strong>。</p><p>比如一开始t表中只有一条记录A，事务2在第一次读取的时候发现表中只有记录A，然后会生成一个ReadView，接着事务1向其添加了记录B，事务2在第二次查看的时候，发现表中仍然只有记录A，这就解决了快照读下的幻读问题。可是如果此时事务2对记录B进行update操作，然后第三次查询，发现表中多了条记录B，这就没有解决幻读问题。</p><h3 id="2-21-讲一讲索引设计原则"><a href="#2-21-讲一讲索引设计原则" class="headerlink" title="2.21 讲一讲索引设计原则"></a>2.21 讲一讲索引设计原则</h3><p><strong>适合创建索引的情况：</strong></p><ol><li>字段的数值拥有唯一性的限制，比如学号、身份证号码</li><li>频繁作为where查询条件的字段</li><li>频繁作为group by和order by的列。</li><li>update、delete的where列。</li><li>distinct字段需要创建索引</li><li>多表连接的连接条件</li><li>使用字符串前缀创建索引。</li><li>尽量创建联合索引</li></ol><p><strong>不适合创建索引的情况</strong></p><ol><li>where中使用不到的字段。</li><li>数据量小的情况</li><li>大量重复数据的字段</li><li>经常更新的字段</li><li>不建议使用无序的值作为索引</li><li>删除不再使用或者很少使用的索引</li><li>不要定义冗余或重复的索引。</li></ol><h3 id="2-22-什么是页分裂"><a href="#2-22-什么是页分裂" class="headerlink" title="2.22 什么是页分裂"></a>2.22 什么是页分裂</h3><p>按照正常的流程来说，我们一般都会使用默认的自增主键，但是如果使用UUID作为主键就可能会造成页分裂。因为在InnoDB索引的设定中，要求主键索引是递增的，这样构建索引树的时候才方便，因为得保证下一个数据页中的所有行一定要比前一个数据页中的行的主键id要大。而UUID则是无序的，就可能导致页分裂，从而调整成为有序的。</p><p><strong>页分裂的目的就是保证：后一个数据页中的所有行主键值比前一个数据页中主键值大。</strong></p><ul><li>页分裂会导致申请新的数据页，然后挪动部分数据过去，这个过程会损耗性能。</li><li>除此之外，原本放在一个页中的数据，可能会被分到两个数据页中，影响数据页的利用率。</li><li>当相邻两个页由于删除了数据等，导致利用率很低之后，也会将数据页进行合并，合并的时候同样也会造成性能损耗</li></ul><h3 id="2-23-MySQL常见异常"><a href="#2-23-MySQL常见异常" class="headerlink" title="2.23 MySQL常见异常"></a>2.23 MySQL常见异常</h3><ul><li>Access denied for user ‘root‘@’localhost’ (using password: YES)。</li></ul><p>无权限，密码错误</p><ul><li>MySQL5.7 group by 新特性报错</li></ul><p>ONLY_FULL_GROUP_BY规定SELECT中的列必须在GROUP BY中。</p><ul><li>高版本的驱动类包出错。</li></ul><p>MySQL8.0使用的是com.mysql.cj.jdbc.Driver，而之前的是com.mysql.jdbc.Driver</p><h3 id="2-24-三大范式？"><a href="#2-24-三大范式？" class="headerlink" title="2.24 三大范式？"></a>2.24 三大范式？</h3><p>第一范式：字段具有原子性，不可再分，字段单一原则</p><p>第二范式：在满足第一范式的前提下，每行应该被唯一区分，而且还得有主键（都要依赖主键）</p><p>第三范式：在满足前两个范式的前提下，一个表不能包含其他表已存在的非主键信息</p><p>优点：重复冗余数据少，更新快，修改少，去重少</p><p>缺点：由于无法存在冗余重复数据，可能造成查询的时候需要额外关联导致效率变低，而且可能导致一些索引策略失效。比如我要查询a表的e字段和b表的f字段，但是遵循第三范式，就无法建立联合索引ef。</p><h3 id="2-25-MyISAM和Innodb"><a href="#2-25-MyISAM和Innodb" class="headerlink" title="2.25 MyISAM和Innodb"></a>2.25 MyISAM和Innodb</h3><ul><li>Innodb支持ACID事务，支持四种隔离级别</li><li>Innodb支持行锁以及外键约束</li><li>select count(*)效率：Innodb不存储总行数，MyISAM存储</li><li>Innodb主键采用聚簇索引，MyISAM采用非聚簇索引，索引文件的数据域指向数据文件的指针。</li></ul><h3 id="2-26-自增主键的理解"><a href="#2-26-自增主键的理解" class="headerlink" title="2.26 自增主键的理解"></a>2.26 自增主键的理解</h3><p>InnoDB的自增值实际上是<strong>保存在内存中，到MySQL8.0的时候才有了自增值持久化的能力</strong></p><p>如果发生了重启：在MySQL5.7以及之前的版本，自增值会保存在内存中，并没有持久化。每次重启之后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将最大值 + 1的值作为这个表当前的自增值。</p><p>也就是说，如果一个表当前数据行里面最大的id是10，则自增值为11，然后我们删除id为10的记录，然后重启实例，之后这个表的自增值就变成了10。</p><p><strong>而在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</strong></p><blockquote><p>为什么自增主键不连续</p></blockquote><ul><li>MySQL5.7以及之前的版本，自增保存在内存中，没有持久化机制</li><li><strong>事务回滚</strong>：自增值无法回滚，因为并发插入数据的时候，回滚自增ID可能造成主键冲突</li><li><strong>唯一键冲突</strong>：假如执行SQL的时候表中的id &#x3D; 10，此时内存中的自增值为11，插入的时候发生了唯一键冲突写库失败（比如如果name字段建立了唯一索引，并且id为10的记录和之前的记录的name值发生冲突），则表中就没有id为10的记录，下一次插入的时候id就从11开始了。<strong>自增值的修改发生在真正执行插入数据的操作之前</strong></li><li><strong>批量写库操作</strong>：对于批量插入数据的语句，MySQL第一次会申请一个自增id，第二次会申请两个，每次都申请之前的两倍。如果此时插入4条记录，第一次申请一个，第二次申请两个，第三次申请四个， 但是我们只有四条记录，就会有三个自增id浪费掉。</li></ul><blockquote><p>为什么主键推荐使用自增ID</p></blockquote><p>自增ID有序，会按照顺序往最后插入，减少了页分裂和内存碎片的产生，减少大量随机IO。</p><p>新插入的行一定会在原有的最大数据行下一行，MySQL定位和寻址很快，不会为计算新行的位置而做出额外的开销。</p><h3 id="2-27-MySQL行转列"><a href="#2-27-MySQL行转列" class="headerlink" title="2.27 MySQL行转列"></a>2.27 MySQL行转列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM t_gaokao_score;<br>+----+--------------+--------------+-------+<br>| id | student_name | subject      | score |<br>+----+--------------+--------------+-------+<br>|  1 | 林磊儿       | 语文         |   148 |<br>|  2 | 林磊儿       | 数学         |   150 |<br>|  3 | 林磊儿       | 英语         |   147 |<br>|  4 | 乔英子       | 语文         |   121 |<br>|  5 | 乔英子       | 数学         |   106 |<br>|  6 | 乔英子       | 英语         |   146 |<br>|  7 | 方一凡       | 语文         |    70 |<br>|  8 | 方一凡       | 数学         |    90 |<br>|  9 | 方一凡       | 英语         |    59 |<br>| 10 | 方一凡       | 特长加分      |   200 |<br>| 11 | 陈哈哈       | 语文         |   109 |<br>| 12 | 陈哈哈       | 数学         |    92 |<br>| 13 | 陈哈哈       | 英语         |    80 |<br>+----+--------------+--------------+-------+<br>13 rows in set (0.00 sec)<br><br>+--------------+--------+--------+--------+--------------+<br>| student_name | 语文   | 数学   | 英语   | 特长加分     |<br>+--------------+--------+--------+--------+--------------+<br>| 林磊儿       |    148 |    150 |    147 |            0 |<br>| 乔英子       |    121 |    106 |    146 |            0 |<br>| 方一凡       |     70 |     90 |     59 |          200 |<br>| 陈哈哈       |    109 |     92 |     80 |            0 |<br>+--------------+--------+--------+--------+--------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>使用case..when..then</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT student_name,<br>    SUM(CASE subject WHEN 语文 THEN score ELSE 0 END) as 语文,<br>    SUM(CASE subject WHEN 数学 THEN score ELSE 0 END) as 数学,<br>    SUM(CASE subject WHEN 英语 THEN score ELSE 0 END) as 英语,<br>    SUM(CASE subject WHEN 特长加分 THEN score ELSE 0 END) as 特长加分<br>FROM t_table<br>GROUP BY student_name<br></code></pre></td></tr></table></figure><p><strong>使用IF</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT student_name,<br>    SUM(IF(`subject`=&#x27;语文&#x27;,score,0)) as &#x27;语文&#x27;,<br>    SUM(IF(`subject`=&#x27;数学&#x27;,score,0)) as &#x27;数学&#x27;,<br>    SUM(IF(`subject`=&#x27;英语&#x27;,score,0)) as &#x27;英语&#x27;,<br>    SUM(IF(`subject`=&#x27;特长加分&#x27;,score,0)) as &#x27;特长加分&#x27; <br>FROM t_gaokao_score <br>GROUP BY student_name;<br></code></pre></td></tr></table></figure><h2 id="3-Redis相关面试题"><a href="#3-Redis相关面试题" class="headerlink" title="3. Redis相关面试题"></a><strong>3. Redis相关面试题</strong></h2><h3 id="3-1-布隆过滤器"><a href="#3-1-布隆过滤器" class="headerlink" title="3.1 布隆过滤器"></a>3.1 布隆过滤器</h3><p>是一种数据结构，用来告诉<strong>某样东西一定不存在或可能存在</strong></p><p>通常判断某个元素是否存在可以使用hashMap，但是HashMap的存储容量比较高，而且如果数据集比较大，也不太可能能一次性全部加载到内存当中。</p><p>布隆过滤器是一个bit向量或者说bit数组。<strong>如果我们要映射一个值到布隆过滤器中，需要使用多个不同的哈希函数生成多个哈希值，然后对每个哈希值指向的bit设置为1</strong></p><p><img src="image-20220310082010618.png" alt="image-20220310082010618"></p><p><strong>实战场景：</strong></p><p>某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。</p><p>这是只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次。需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。</p><h3 id="3-2-Redis跳跃表"><a href="#3-2-Redis跳跃表" class="headerlink" title="3.2 Redis跳跃表"></a>3.2 Redis跳跃表</h3><p><a href="https://www.cnblogs.com/hunternet/p/11248192.html">Redis数据结构——跳跃表 - Mr于 - 博客园 (cnblogs.com)</a></p><p>如果一个有序集合（zset）包含的<strong>元素数量比较多</strong>或者<strong>成员是比较长的字符串</strong>时，redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>为什么要元素数量比较多或者成员比较长的字符串呢？首先跳跃表这个结构是以空间换时间，来让链表快速的获取到指定的元素。当数量比较多时，或者成员变量是比较长的字符串时，跳表带来的空间消耗就相对而言非常少了，其优势必然会放大。</p><p><img src="Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="Redis跳跃表"></p><p>Redis的跳跃表由zskiplistNode和skiplist两个结构定义，其中上图蓝色的部分就是skiplist，右边的四个部分就是zskiplistNode结构。</p><h3 id="3-3-AOF文件过大怎么办"><a href="#3-3-AOF文件过大怎么办" class="headerlink" title="3.3 AOF文件过大怎么办"></a>3.3 AOF文件过大怎么办</h3><p><a href="https://blog.csdn.net/qq_19595957/article/details/122122367">(34条消息) 面试真题：AOF文件越来越大怎么办？_Z-AI-CSDN博客_aof文件过大怎么处理?</a></p><ol><li>AOF重写，Redis在AOF文件过大时会对命令进行合并重写。</li><li>redis考虑到像集合这种元素过多的时候不是一个命令能写完的，而是也会分多个命令写入。因为写入太多可能导致缓冲区溢出（先写缓冲区再写入AOF文件中）</li><li>如果是大量写入的话，线程会被长时间阻塞，redis是单线程的，解决办法就是将重写放到<strong>子进程</strong>中，父进程可以继续处理命令请求，子进程带有父进程的数据副本，使用子进程而不是线程是因为可以避免使用锁，保证数据安全性</li><li>但是可能会导致子进程和父进程数据不一致，比如在写入原来的数据时，父进程又处理了新的命令。解决办法是提供一个aof重写缓冲区，创建子进程开始，redis执行完写命令后会将命令发送到AOF缓冲区和AOF重写缓冲区，当子进程完成AOF重写工作后，子进程向父进程发送一个信号，父进程将AOF重写缓冲区的内容写入到新AOF文件中。</li></ol><h3 id="⭐3-4-缓存一致性解决办法？"><a href="#⭐3-4-缓存一致性解决办法？" class="headerlink" title="⭐3.4 缓存一致性解决办法？"></a>⭐3.4 缓存一致性解决办法？</h3><p><a href="https://blog.csdn.net/qq_42253147/article/details/94447103">https://blog.csdn.net/qq_42253147/article/details/94447103</a></p><p>要是问到为什么简历上写的是双写一致性，我就说当时做项目的时候是这么考虑的，然后随着后续的学习，发现这样子对性能有影响，就对项目进行了改造，采用延时双删。</p><p>如果是<strong>先写数据库再更新缓存</strong>，首先会有数据不一致问题，比如A线程写了数据库，然后由于网络等原因，没来得及更新缓存。此时B线程进行更新了数据库，然后将缓存写到了redis，这时候线程A又开始写缓存了，就会导致线程B的缓存更新无效。同时如果数据库一小时更新了很多次，就会导致缓存也更新很多次。然后这个缓存可能一个小时内只会被读取一次，那么额外更新的缓存数就完全没有必要。<strong>因此缓存应该是被删除而不是被更新</strong></p><p>因此采用的策略是<strong>先删除缓存，再更新数据库</strong>，解决方案是<strong>延迟双删</strong></p><p>问题产生：先删除缓存，此时数据库还没有更新成功，如果另一个线程来读取缓存，发现缓存为空，就会去数据库读取新的值，但是此时数据库还未更新成功，因此读到的就是旧值，缓存不一致发生。</p><p>解决办法：为了避免在更新数据库的时候，其它线程从缓存中读取不到数据，就在更新完成之后sleep一段时间，然后再次删除缓存。同时sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。</p><ol><li>线程1删除缓存，然后去更新数据库</li><li>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存</li><li>线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除</li><li>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值</li></ol><p><img src="image-20220330164742346.png" alt="image-20220330164742346"></p><h3 id="3-5-说一下redis中的事务"><a href="#3-5-说一下redis中的事务" class="headerlink" title="3.5 说一下redis中的事务"></a>3.5 说一下redis中的事务</h3><p>首先在redis中，每一条命令都是原子性的。而对于redis的事务而言，它其实并不能保证原子性，你可以将它看成是一个打包的批量执行脚本，如果中间某条指令执行失败了，并不会导致前面已经执行完了的指令回滚，也不会导致后续未执行的指令不执行。</p><p>redis的事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。多个命令会被人入队到事务队列中，然后按照FIFO的顺序执行。</p><h3 id="3-6-数据倾斜？"><a href="#3-6-数据倾斜？" class="headerlink" title="3.6 数据倾斜？"></a>3.6 数据倾斜？</h3><p><a href="https://bbs.huaweicloud.com/blogs/194535">Redis如何避免数据倾斜问题？-云社区-华为云 (huaweicloud.com)</a></p><p>简单的来说，数据倾斜就是我们在计算数据的时候，数据不够分散，大量的数据集中到了一台或几台机器节点上，就导致这些节点负载过大，而其余的节点确是空闲等待中的，最终导致整体效率低下。</p><p>比如一些big key的存在，数据量比较大，在业务上举例：论坛中的大型持久盖楼活动；聊天室系统中的热门聊天室的消息列表。</p><p>big key解决办法：如果big key是个大JSON，通过mset，将该key的存储内容分散到各个实例中。如果是个大list，就将list进行拆分。</p><h3 id="3-10-redis中有一亿条数据，其中10w个以某个固定的已知前缀开头，找到这些数据？"><a href="#3-10-redis中有一亿条数据，其中10w个以某个固定的已知前缀开头，找到这些数据？" class="headerlink" title="3.10 redis中有一亿条数据，其中10w个以某个固定的已知前缀开头，找到这些数据？"></a>3.10 redis中有一亿条数据，其中10w个以某个固定的已知前缀开头，找到这些数据？</h3><p>可以使用keys命令配合通配符找到这些keys，但是使用keys的话会导致redis阻塞一段时间，直到指令执行完毕。这个时候可以使用scan指令，它可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端去一次重就好了，但是整体所花费的时间会比keys指令长。</p><h2 id="4-JVM相关面试题"><a href="#4-JVM相关面试题" class="headerlink" title="4. JVM相关面试题"></a><strong>4. JVM相关面试题</strong></h2><h3 id="4-1-说一下垃圾回收器的三色标记"><a href="#4-1-说一下垃圾回收器的三色标记" class="headerlink" title="4.1 说一下垃圾回收器的三色标记"></a>4.1 说一下垃圾回收器的三色标记</h3><p><a href="https://juejin.cn/post/6844904070788939790">面试官:你说你熟悉jvm?那你讲一下并发的可达性分析 - 掘金 (juejin.cn)</a></p><p>所谓的三色标记其实就是白色、黑色、灰色</p><ul><li>白色：表示对象尚未被垃圾回收器访问过</li><li>黑色：表示对象已经被垃圾回收器访问过，而且这个对象所有的直接引用都已经扫描过</li><li>灰色：表示对象已经被垃圾回收器访问过，但是这个对象至少有一个引用还没有被扫描过。</li></ul><p>由于垃圾回收器和用户线程是并发工作的，再加上被标记为黑色的对象就一定不会再次被扫描。因此并发标记就会产生两个问题：对象消亡和浮动垃圾</p><p><strong>对象消亡：</strong>把原本存活的对象错误的标记为已消亡</p><ol><li>存在对象关系，A指向B，B指向C，但是A不指向C。</li><li>将A标记后，并开始标记B</li><li>刚开始标记对象B，但是还没开始标记对象B的下一个对象C，此时A是黑色，B是灰色，C是白色。如果此时将引用关系改为A指向了C，并且断开了B和C的联系，根据三色标记原则，对象C是白色的，就会被错误的当成垃圾进行回收。</li></ol><p>总的来说，<strong>对象消亡需要两个条件</strong></p><ol><li>赋值器插入了一条或多条从黑色对象指向白色对象的新引用</li><li>赋值器删除了全部从灰色对象到白色对象的直接或间接引用。</li></ol><p><strong>有两种方式解决，增量更新和原始快照</strong></p><ul><li>增量更新：用的是写后屏障，记录了所有新增的引用关系。当黑色对象插入新的指向白色对象的引用之后，就会将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系的黑色对象为根，再次扫描一遍。</li><li>原始快照：当灰色对象要删除指向白色对象的引用关系时，就会将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。也就是无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照进行搜索。</li></ul><p><strong>CMS基于增量更新，G1基于原始快照</strong></p><h3 id="4-2-说一下类卸载，或者说怎么判断无用类"><a href="#4-2-说一下类卸载，或者说怎么判断无用类" class="headerlink" title="4.2 说一下类卸载，或者说怎么判断无用类"></a>4.2 说一下类卸载，或者说怎么判断无用类</h3><ul><li>该类的所有的实例都已经被回收，即堆空间中不存在任何该类以及它的派生子类的实例。</li><li>该类的类加载器已经被回收</li><li>该类所对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。</li></ul><h3 id="4-3-新生代中的survival满了怎么办？"><a href="#4-3-新生代中的survival满了怎么办？" class="headerlink" title="4.3 新生代中的survival满了怎么办？"></a>4.3 新生代中的survival满了怎么办？</h3><p>首先得看是否发生了内存泄漏，可以使用JVisualVM来判断。</p><ul><li>首先看服务器的内存是否足够，如果足够，建议直接增大新生代空间。</li><li>如果内存不够的话，就可以压缩Eden区，但是Eden区的减少会增加MinorGC的次数，可以根据系统对延迟和吞吐量的指标来看是否符合。</li><li>如果调整了之后内存还是不够用，可以试着去增加服务器的内存，或者把负担分担到多个JVM实例上。</li></ul><h3 id="4-4-tomcat如何打破双亲委派机制的？"><a href="#4-4-tomcat如何打破双亲委派机制的？" class="headerlink" title="4.4 tomcat如何打破双亲委派机制的？"></a>4.4 tomcat如何打破双亲委派机制的？</h3><p><strong>双亲委派机制的优点：</strong></p><ol><li>保证了Java程序的稳定运行</li><li>可以避免类的重复加载</li><li>保证了Java核心API不被篡改。</li></ol><p><a href="https://www.cnblogs.com/ITPower/p/13217145.html">1.5 tomcat是如何打破双亲委派机制的? - 盛开的太阳 - 博客园 (cnblogs.com)</a></p><p>我们都知道，一个tomcat可以加载多个不同的应用程序，比如可以同时加载spring5和spring4两种应用程序。而在spring4和spring5中，有很多类类名相同，但是他们的实现不一样。如果没有打破双亲委派机制，就只能加载一份，也就无法同时加载多个不同的应用程序了。</p><p>在tomcat中，每一个项目打包成war包的时候，tomcat都会自动生成一个类加载器，专门用来加载这个war包，而这个类加载器就打破了双亲委派机制。webapp类加载器就不需要再让上级去加载，它自己就可以加载对应war包里面的class文件了。</p><p><strong>双亲委派机制时ClassLoader类中的loadClass方法来实现的，重写该方法用来打破双亲委派机制</strong></p><h3 id="4-5-FullGC效果不好，每次只能从90-85-90，该怎么办"><a href="#4-5-FullGC效果不好，每次只能从90-85-90，该怎么办" class="headerlink" title="4.5 FullGC效果不好，每次只能从90-85-90，该怎么办"></a>4.5 FullGC效果不好，每次只能从90-85-90，该怎么办</h3><p>（如果是一次fullgc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区。如果一次fullgc后，old区回收率不大，那么说明old区太小。）</p><h3 id="4-6-内存分配策略"><a href="#4-6-内存分配策略" class="headerlink" title="4.6 内存分配策略"></a>4.6 内存分配策略</h3><ul><li><p>新对象优先在Eden中分配</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活的对象进入老年代，默认是15</p></li><li><p>动态对象年龄判定：如果survivor中相同年龄所有对象大小的总和大于s空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到15岁（HotSpot虚拟机遍历所有对象时，按照年龄从小到大对其所占有的空间进行累积，当累积的某个年龄大小超过了s区中的一半时，取出这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">uint <span class="hljs-title function_">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-type">size_t</span> survivor_capacity)</span> &#123;<br>    <span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br>    <span class="hljs-type">size_t</span> desired_survivor_size = (<span class="hljs-type">size_t</span>)((((<span class="hljs-type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br>    <span class="hljs-type">size_t</span> total = <span class="hljs-number">0</span>;<br>    uint age = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>        <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>        total += sizes[age];<br>        <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        age++;<br>    &#125;<br>    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>空间分配担保：在执行MinorGC之前，JVM会先检查老年代的最大可连续空间是否大于新生代所有对象的总空间，如果大于，则认为这次GC是安全的；如果不大于，就看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC；如果小于，或者不允许担保，就要进行FullGC；<strong>在JDK6 Update24之后，规则变为只要老年代的最大连续可用空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，否则将进行FullGC。</strong></p></li></ul><h3 id="4-7-CPU占用过高的问题以及定位"><a href="#4-7-CPU占用过高的问题以及定位" class="headerlink" title="4.7 CPU占用过高的问题以及定位"></a>4.7 CPU占用过高的问题以及定位</h3><p><a href="https://blog.csdn.net/weixin_32822759/article/details/108170281">(34条消息) CPU占用过高的问题如何定位_weixin_32822759的博客-CSDN博客</a></p><ol><li>首先使用top命令查看正在执行进程的CPU使用率，内存使用率以及系统负载等信息。可以看到哪个进程id的进程cpu使用率最高，比如7139</li><li>接下来就可以使用<code>top -p 7139 -H</code>，单独监视该进程下的所有线程信息，找到是哪个线程占用cpu最高。</li><li>使用<code>jstack 指定线程id &gt; xxx.txt</code>将线程的所有信息做dump记录。</li><li>或者使用<code>jstat</code>相关命令</li><li>或者使用<code>jmap</code>相关命令，或者使用<code>jvisualvm</code>可视化来看哪些对象用的最多，或者查看GC频率等</li></ol><p>或者如果是业务线程CPU占用高，就检查代码，CPU狂算或者死循环；如果是GC线程，频繁FGC，读日志。如果每次回收不掉，内存泄漏</p><h3 id="4-8-JVM如何对指令重排序，排序的依据"><a href="#4-8-JVM如何对指令重排序，排序的依据" class="headerlink" title="4.8 JVM如何对指令重排序，排序的依据?"></a>4.8 JVM如何对指令重排序，排序的依据?</h3><p><a href="https://blog.csdn.net/pzxwhc/article/details/48984209">(34条消息) Java JVM（十二）：指令重排序_Sauron1的博客-CSDN博客_指令重排序</a></p><p><strong>数据依赖性</strong>：如果两个操作访问同一个变量，且这两个操作中有一个写操作，此时这两个操作之间就存在数据依赖性。</p><table><thead><tr><th>名称</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a &#x3D; 1;  b &#x3D; a</td><td>写一个变量之后，再读这个变量</td></tr><tr><td>写后写</td><td>a &#x3D; 1;  a &#x3D; 2</td><td>写一个变量之后，再写这个变量</td></tr><tr><td>读后写</td><td>a &#x3D; b; b &#x3D; 1</td><td>读一个变量之后，再写这个变量</td></tr></tbody></table><p><strong>在单线程环境中，JVM指令重排序会保证最终执行结果和代码顺序结果一致。并且处理器在执行重排序的过程中会考虑数据依赖性（如果不存在数据依赖性，编译器和处理器可能会对操作进行重排序）。但是多线程环境中，并不会保证。</strong></p><p>也就是说，as-if-serial语义：<strong>不管怎么重排序，单线程下程序的执行结果不能被改变</strong></p><p>除了考虑数据依赖性以外，<strong>还得考虑happens-before</strong></p><p>两个操作之间存在先行发生原则，并不意味着一定要按照该原则制定的顺序来执行。如果重排序之后的执行结果与按照先行发生原则来执行的结果一致，那么这种重排序并不非法。</p><h3 id="4-9-了解堆内内存和堆外内存吗？"><a href="#4-9-了解堆内内存和堆外内存吗？" class="headerlink" title="4.9 了解堆内内存和堆外内存吗？"></a>4.9 了解堆内内存和堆外内存吗？</h3><p><strong>堆内内存：</strong></p><ol><li>堆内内存 &#x3D; 新生代 + 老年代 + 永久代</li></ol><p><strong>堆外内存：</strong></p><ol><li>堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存。</li><li>使用<code>java.nio.DirectByteBuffer</code>对象进行堆外内存的管理和使用，该类会在创建对象时就分配堆外内存。</li><li>元空间就是使用的堆外内存。</li><li>对堆外内存的申请主要是通过成员变量<code>unsafe</code>来操作</li><li><strong>优点</strong>：<ul><li>减少了垃圾回收机制</li><li>加快了复制的速度：堆内在flush到远程时，会先复制到直接内存再发送，而堆外内存（本身就是物理机内存）几乎省略了该步骤</li></ul></li><li><strong>缺点：</strong>内存难以控制；使用堆外内存就间接失去了JVM管理内存的可能性，改由自己来管理，当发送内存溢出时排查起来十分困难。</li></ol><h3 id="4-10-Java8为什么用元空间代替永久代"><a href="#4-10-Java8为什么用元空间代替永久代" class="headerlink" title="4.10 Java8为什么用元空间代替永久代"></a>4.10 Java8为什么用元空间代替永久代</h3><ul><li>HotSpot JVM和JRockit VM进行了融合，而JRockit中没有永久代。</li><li>永久代内存经常不够用或发生内存溢出，这是因为在1.7的时候永久代的内存受JVM的内存限制，并且回收率较低，导致更容易溢出。而且PermGen分配多大的空间很难确定，它的大小依赖于很多因素，比如JVM加载的class总数、常量池的大小和方法的大小。</li></ul><h3 id="4-11-常见的性能调优"><a href="#4-11-常见的性能调优" class="headerlink" title="4.11 常见的性能调优"></a>4.11 常见的性能调优</h3><p><strong>1、降低MinorGC频率</strong></p><p>如果频繁发生MinorGC，可能是新生代的空间太小所导致的，因此就可以适当的增大新生代的空间。但是有人可能会说，增大了空间，难道不会导致单次MinorGC时间变长吗？值得注意的是，MinorGC分为扫描和复制。如果在堆内存中存在较多的长期存活的对象，此时增大年轻代空间，反而会增加MinorGC的时间；但是如果堆中的短期对象很多，那么扩容新生代，单次MinorGC反而不会显著增加，因为GC频率变低，就可能导致大量的对象已经过期了，存活的对象少了，在复制阶段的损耗也会大大减少。</p><p><strong>2、降低FullGC频率</strong></p><p>可以<strong>减少创建大对象</strong>，因为大对象会直接创建在老年代；即使被创建在了年轻代，由于年轻代内存空间有限，通过MinorGC之后也会进入到老年代。这种大对象过多很容易导致FullGC。因此可以将大对象拆解出来，只查询一些重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。</p><p><strong>增大堆内存空间</strong></p><p><strong>3、选择合适的GC回收器</strong></p><p>如果对低延时有要求，就可以选择CMS；如果对吞吐量有要求，就选择Parallel Scavenge；如果内存较大，可以选用G1。</p><h3 id="4-12-FullGC的触发条件"><a href="#4-12-FullGC的触发条件" class="headerlink" title="4.12 FullGC的触发条件"></a>4.12 FullGC的触发条件</h3><ol><li>**调用System.gc()**，只是建议JVM执行，但是它不一定真正去执行，不建议使用这种方式。</li><li><strong>老年代空间不足</strong>：大对象直接进入老年代，长期存活的对象进入老年代。尽量不要创建大对象以及数组。</li><li><strong>空间分配担保失败</strong>：使用复制算法的MinorGC需要老年代的内存空间作为担保，如果担保失败会执行一次FullGC</li><li><strong>JDK1.7以及之前的永久代空间不足：</strong>当系统要加载的类、反射的类和调用的方法较多时，可能会被占满。</li><li><strong>Concurrent Mode Failure</strong>：使用CMS垃圾回收器的时候，用户线程并没有被中断，如果在回收过程中，老年代空间不足了（也有可能是浮动垃圾过多，或者碎片过多），便会报错，并且触发一次FullGC，临时采用serial old收集器来重新进行老年代的垃圾收集，这时也会整理碎片</li></ol><h3 id="4-13-JVM调优"><a href="#4-13-JVM调优" class="headerlink" title="4.13 JVM调优"></a>4.13 JVM调优</h3><blockquote><p>调优时机</p></blockquote><ul><li>FullGC频繁</li><li>GC停顿时间过长</li><li>应用出现OOM等内存异常</li><li>应用中有使用本地缓存并占用大量内存空间</li><li>系统吞吐量与响应性能不高或下降</li></ul><blockquote><p>JVM调优步骤</p></blockquote><ul><li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点</li><li>确定JVM调优量化目标（比如目标让堆空间使用率下降到百分之七十）</li><li>确定JVM调优参数</li><li>依次调优内存、延迟、吞吐量等指标</li><li>对比观察调优前后的差异</li><li>不断的分析和调整，直到找到合适的JVM参数配置</li><li>找到最合适的参数，将这些参数进行应用，并进行后续的跟踪</li></ul><blockquote><p>常见的JVM参数</p></blockquote><p><strong>堆栈配置相关</strong></p><ul><li>-Xmx3550m：最大堆大小为3550m。</li><li>-Xms3550m：设置初始堆大小为3550m。</li><li>-Xmn2g：设置年轻代大小为2g。</li><li>-Xss128k：每个线程的堆栈大小为128k。</li><li>-XX:MaxPermSize： 设置持久代大小为16m</li><li>-XX:NewRatio&#x3D;4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。</li><li>-XX:SurvivorRatio&#x3D;4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1&#x2F;6</li><li>-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。</li></ul><p><strong>垃圾收集器相关</strong></p><ul><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</li><li>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</li><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li><li>-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器</li></ul><p><strong>辅助信息</strong></p><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li></ul><blockquote><p>常见的调优策略</p></blockquote><ul><li>选择合适的垃圾收集器</li><li>调整内存大小：如果垃圾收集频繁，而此时内存较小的话，就可以适当调整内存大小</li><li>调整内存区域大小比率（某一个区域的GC频繁，其他正常）</li><li>调整对象升老年代的年龄（老年代频繁GC，每次回收的对象很多）</li><li>调整大对象的标准（老年代频繁GC，每次回收的对象很多，并且体积都比较大）</li><li>调整触发GC的时机（CMS、G1经常Full GC，程序卡顿严重）</li><li>调整JVM本地内存大小（ GC次数、时间、回收的对象都正常，堆内存空间充足，但是报OOM）</li></ul><h3 id="4-14-分代假说"><a href="#4-14-分代假说" class="headerlink" title="4.14 分代假说"></a>4.14 分代假说</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多代垃圾回收的对象约难消亡</li><li>跨代引用假说：对象不是孤立的，对象之间会存在跨代引用，但是跨代引用相对于同代引用来说占极少数。也就是存在相互引用关系的两个对象，是应该倾向于同时生存或同时消亡的；也因此我们不应该为这些少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用。只需要在新生代上建立一个全局的数据结构，也就是记忆集，将老年代划分成若干个小块，标识出老年代的哪一块内存会存在跨代引用。</li></ul><h2 id="5-Spring相关面试题"><a href="#5-Spring相关面试题" class="headerlink" title="5. Spring相关面试题"></a><strong>5. Spring相关面试题</strong></h2><h3 id="⭐5-1-Spring事务中的隔离级别？"><a href="#⭐5-1-Spring事务中的隔离级别？" class="headerlink" title="⭐5.1 Spring事务中的隔离级别？"></a>⭐5.1 Spring事务中的隔离级别？</h3><p>Spring中的事务有五种，其实和MySQL的事务基本一致</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">DEFAULT</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">READ_UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ_COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE_READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>其中DEFAULT代表的含义就是<strong>使用数据库默认的事务隔离级别</strong></p><p>如果Spring事务和MySQL的事务不一致的话，会默认使用Spring的事务，因为Spring的事务可以看作是MySQL的一种封装。</p><h3 id="5-3-Spring中的设计模式"><a href="#5-3-Spring中的设计模式" class="headerlink" title="5.3 Spring中的设计模式"></a>5.3 Spring中的设计模式</h3><ul><li>工厂设计模式：Spring使用工厂模式通过BeanFactory、ApplicationContext创建bean对象，IOC的实现中其实也是用到了工厂 + 反射。</li><li>代理设计模式：AOP功能的实现。</li><li>单例设计模式：Bean默认都是单实例的</li><li>原型模式：Bean的prototype作用域</li><li>策略模式：Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略。还有逆向生成就用了策略。</li><li>模板方法：将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题，比如RestTemplate、RedisTemplate</li><li>适配器模式：AOP的增强或通知（Advice）使用到了适配器模式、SpringMVC中也是用到了适配器模式适配Controller</li><li>桥接模式：根据客户的需求能够动态切换不同的数据源，比如我们项目需要连接多个数据库，客户在每次访问中根据需要会访问不同的数据库。</li><li>享元模式：数据库连接池</li></ul><h3 id="5-5-说一下-Transactional失效的场景"><a href="#5-5-说一下-Transactional失效的场景" class="headerlink" title="5.5 说一下@Transactional失效的场景"></a>5.5 说一下@Transactional失效的场景</h3><ol><li>注解用在非public修饰的方法上，不支持回滚<ul><li>原因就是SpringAOP在动态代理的时候，TransactionInterceptor（事务拦截器）会在目标方法前后进行拦截。DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource 的 computeTransactionAttribute 方法，获取Transactional 注解的事务配置信息，</li><li><img src="20201126161911807.jpeg" alt="img"></li></ul></li><li>注解的rollbackFor设置错误：<strong>Spring默认抛出了未检查（unchecked）异常（继承自 RuntimeException 的异常）或者 Error才回滚事务，其他异常不会触发回滚事务</strong></li><li>普通方法A调用同类中的事务方法B，方法B的事务不会生效：<strong>这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码直接调用时，才会由Spring生成的代理对象来管理，进而由 TransactionInterceptor （事务拦截器）生成事务对象。</strong></li><li>数据库引擎不支持事务</li><li>如果异常被try-catch处理了，也不会回滚。</li></ol><h3 id="⭐5-6-说一下Spring事务的传播行为"><a href="#⭐5-6-说一下Spring事务的传播行为" class="headerlink" title="⭐5.6 说一下Spring事务的传播行为"></a>⭐5.6 说一下Spring事务的传播行为</h3><ol><li><strong>REQUIRED</strong>：默认的传播机制，如果当前没有事务，就新建一个事务，如果已经存在在一个事务中，就加入到这个事务。</li><li><strong>SUPPORTS</strong>：持当前事务，如果当前有事务，就以事务方式执行；如果当前没有事务，就以非事务方式执行</li><li><strong>MANDATORY</strong>：使用当前的事务，且必须在一个已经有的事务中执行，如果当前不存在事务，就会抛出异常。</li><li><strong>REQUIRES_NEW</strong>：不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务。</li><li><strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务，就把当前事务挂起</li><li><strong>NEVER</strong>：以非事务方式执行，且必须在一个没有的事务中执行，如果当前存在事务，则抛出异常【和MANDATORY相反】</li><li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行与REQUIRED类似的操作。</li></ol><h3 id="5-7-如何实现一个IOC容器？"><a href="#5-7-如何实现一个IOC容器？" class="headerlink" title="5.7 如何实现一个IOC容器？"></a>5.7 如何实现一个IOC容器？</h3><p>IOC即控制反转，是一种思想，意味着将你设计好的对象交给容器来控制，而不是传统的在你的对象内部直接控制。将对象之间的相互依赖关系交给IOC容器进行管理，并由IOC容器完成对象的注入，简化应用开发，把应用从复杂的依赖关系中解放出来。</p><ol><li>先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象。</li><li>进行配置文件的读取工作或注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中。</li><li>容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的初始化工作。</li><li>进行对象的初始化操作，也就是给类中对应属性值进行设置，也就是依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中。</li><li>通过容器对象来获取对象，进行对象的获取和逻辑处理工作</li><li>提供销毁操作，当对象不用或者容器关闭的时候将无用的对象进行销毁。</li></ol><h3 id="5-8-Spring的优势"><a href="#5-8-Spring的优势" class="headerlink" title="5.8 Spring的优势"></a>5.8 Spring的优势</h3><ol><li>Spring拥有强大的生态圈，将Spring扩展到不同的领域</li><li>IOC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>AOP支持允许将一些通用任务比如安全、事务、日志等进行集中处理，从而提供更好的复用</li><li>高度开放性和可扩展性</li><li>低侵入设计，代码的污染极低。</li><li>拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断改进、不断发展</li></ol><h3 id="5-9-BeanFactory和ApplicationContext"><a href="#5-9-BeanFactory和ApplicationContext" class="headerlink" title="5.9 BeanFactory和ApplicationContext"></a>5.9 BeanFactory和ApplicationContext</h3><p><strong>相同：</strong></p><ol><li>两者都是Spring提供的IOC容器，它们都可以用来配置XML属性，也支持属性的自动注入。</li><li>都可以通过getBean(“bean name”)来获取bean。</li></ol><p><strong>不同点：</strong></p><ol><li>对于BeanFactory来说，采用延迟加载形式注入bean，只有使用getbean时才会对该bean进行加载实例化，如果某个Bean的某一个属性没有注入，只有等到第一次调用getBean获取该Bean的时候才会抛出异常；而后者在容器启动时一次性创建了所有的Bean。</li><li>前者不支持国际化，即i18n，后者支持</li><li>前者提供基本的IOC和DI功能，后者提供高级功能，比如AOP。</li><li>ApplicationContext是BeanFactory的子接口。</li></ol><p><strong>什么时候用哪个？</strong></p><p><strong>延迟实例化优点：</strong>应用启动的时候占用资源很少，对于资源要求较高的应用，比较有优势。</p><p><strong>不延迟实例化优点：</strong>所有的Bean在启动的时候就已经加载了，系统运行速度较快。又因为如此，我们能在系统启动的时候发现系统中的配置问题。建立Web应用。</p><h3 id="5-10-bean的生命周期"><a href="#5-10-bean的生命周期" class="headerlink" title="5.10 bean的生命周期"></a>5.10 bean的生命周期</h3><p><img src="b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p><p>初始化-&gt;设置属性-&gt;setBeanName（如何实现了BeanNameAware接口）-&gt;setBeanFactory (如果实现了BeanFactoryAware接口)-&gt;setApplicationContext(如果实现了ApplicationContextAware接口)-&gt;预初始化方法postProcessorBeforeInitialization(如果实现了BeanPostProcessor接口)-&gt;afterPropertiesSet方法（如果实现了InitializingBean接口）-&gt; 调用自定义的方法init-method（如果指定了） -&gt; 初始化之后的方法postProcessorAfterInitialization(如果实现了BeanPostProcessor接口)-&gt;最后是destroy（如果实现了DisposableBean） 和destroy-method方法。</p><ol><li>解析类得到BeanDefinition</li><li>如果有多个构造方法，则要推断构造方法</li><li>确定好构造方法之后，进行实例化得到一个对象</li><li>进行属性填充，设置对象属性。</li><li>回调Aware方法，比如BeanNameAware、BeanFactoryAware</li><li>调用BeanPostProcessor的初始化前的方法，然后调用初始化方法，接着调用初始化后的方法（这里会AOP）</li><li>如果当前创建的bean是单例的，就会将bean放到单例池</li><li>此时Bean就可以被使用了</li><li>在销毁的时候看看Bean有没有实现DisposableBean接口或者使用destory-method声明了销毁方法。</li></ol><h3 id="5-11-IOC"><a href="#5-11-IOC" class="headerlink" title="5.11 IOC"></a>5.11 IOC</h3><p><strong>IOC即控制反转</strong>，它将在程序中手动创建对象的控制权交给了Spring框架来管理。Spring IOC负责创建对象，管理对象（通过DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p><strong>DI即依赖注入</strong>，就是IOC容器在运行期间，动态地将某种依赖关系注入到对象中。</p><p>通过引入IOC容器，利用依赖注入的方式，来实现对象之间的解耦。</p><p><strong>作用：</strong></p><ul><li>对象之间的耦合度或者说依赖程度降低。比如我们如果针对于UserDao接口开发了它的实现类UserDaoImpl，然后传统方式在用到该实现类的地方都去new UserDaoImpl，但是如果我们想去使用新的实现类NewUserDaoImpl，就得在每个使用到UserDaoImpl的地方去修改代码，这就非常的麻烦。</li><li>资源变得容易管理，它支持单例和原型。</li><li>简化开发，让程序员更加的专注于业务的实现。</li></ul><p><strong>实现原理：工厂模式 + 反射机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我吃苹果！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String className)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fruit = (Fruit)Class.forName(className).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> fruit;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> FruitFactory.getInstance(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span> (apple != <span class="hljs-literal">null</span>) &#123;<br>            apple.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实对于IOC和DI，这两者是同一种东西的不同说法。对于IOC来说，一开始我们都是自己new对象，然后自己去控制它的生命周期，比如<code>OrderService orderService = new OrderServiceImpl ()</code>，但是如果我们进行了技术迭代，从而导致出现了新的实现类<code>OrderServiceImplNew</code>，我们就得去修改源代码，比较麻烦。于是我们就可以利用IOC思想，将我们所有的对象都交给IOC容器进行管理，我们需要什么对象就去找IOC容器去拿，然后Spring会在合适的时机将你需要的对象给你。我们不再关心我们所依赖的对象是怎么创建、销毁的，控制对象生命周期的不再是我自己，而是Spring容器。这就叫控制反转。</p><p>而如何动态的将某个对象提供给它所需要的其他对象，这就是通过DI依赖注入实现的。上述的合适的时机，其实就是DI做的事情。</p><h3 id="5-12-AOP"><a href="#5-12-AOP" class="headerlink" title="5.12 AOP"></a>5.12 AOP</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>AOP一般被称为面向切面编程，它能够将那些与业务无关，却是业务所共同调用的逻辑或责任，比如事务处理、日志管理、权限控制等。AOP能够减少系统的重复代码，降低模块之间的耦合度，并有利于未来的扩展性和维护性。</p><h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h4><p>Spring AOP底层是使用动态代理的，又可以分为JDK动态代理和Cglib动态代理。</p><h4 id="3-Spring-AOP和AspectJ-AOP"><a href="#3-Spring-AOP和AspectJ-AOP" class="headerlink" title="3. Spring AOP和AspectJ AOP"></a>3. Spring AOP和AspectJ AOP</h4><p>AOP的实现是基于代理的，而代理又分为动态代理和静态代理。其中Spring AOP是动态代理，AspectJ AOP是静态代理。</p><p><strong>SpringAOP属于运行时增强，AspectJAOP属于编译时增强</strong></p><ul><li>前者不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li><li>后者是基于字节码操作的，它会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ（切面）织入到Java字节码中，运行的时候就是增强之后的AOP对象。</li></ul><h4 id="4-JDK动态代理和Cglib"><a href="#4-JDK动态代理和Cglib" class="headerlink" title="4. JDK动态代理和Cglib"></a>4. JDK动态代理和Cglib</h4><p>JDK动态代理只能代理实现了某个接口的类或者直接代理该接口，而CGLIB可以代理未实现任何接口的类。同时CGLIB是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为final类型的类和方法，private修饰的方法也不行。</p><h3 id="5-13-Autowired和-Resource"><a href="#5-13-Autowired和-Resource" class="headerlink" title="5.13 @Autowired和@Resource"></a>5.13 @Autowired和@Resource</h3><p>这两个注解都是用于依赖注入。</p><p>其中@Autowired默认是按照类型装配注入的，如果想要按名称注入，就得配合@Qualifier</p><p>而Resource是java中的注解，默认按照名称来装配注入，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h3 id="5-14-Spring中Bean的自动装配"><a href="#5-14-Spring中Bean的自动装配" class="headerlink" title="5.14 Spring中Bean的自动装配"></a>5.14 Spring中Bean的自动装配</h3><p>bean的自动装配指的是bean的属性值在进行注入的时候通过某种特定的规则和方式去容器中查找，并设置到具体的对象属性中，它有五种方式：</p><ol><li>no：缺省情况下，自动配置是通过ref属性手动设定，在项目中最常用</li><li>byName：根据属性名称自动装配。如果一个bean的名称和其它bean属性的名称是一样的，将会自动装配它。</li><li>byType：根据类型自动装配</li><li>constructor：在构造函数参数的byType方式</li><li>autodetect：如果找到默认的构造函数，使用构造函数，否者按类型自动装配。</li></ol><h3 id="5-15-SpringMVC的工作流程"><a href="#5-15-SpringMVC的工作流程" class="headerlink" title="5.15 SpringMVC的工作流程"></a>5.15 SpringMVC的工作流程</h3><p><img src="image-20220409191239028.png" alt="image-20220409191239028"></p><p>1、用户向服务器发送请求，这个请求会先到中央控制器DispatcherServlet</p><p>2、中央控制器接收到请求后会调用HandlerMapper处理器映射器。由此得知该请求该由哪个Controller来处理</p><p>3、中央控制器调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</p><p>4、处理器适配器HandlerAdapter去执行Controller并得到ModelAndView，然后层层返回给DispatcherServlet</p><p>5、中央控制器将ModelAndView交给ViewResolver视图解析器解析视图，然后返回真正的视图。</p><p>6、中央控制器将模型数据填充到视图中，然后将结果响应给用户。</p><h3 id="5-16-spring怎么根据不同的环境条件注入不同的对象（比如win和linux）"><a href="#5-16-spring怎么根据不同的环境条件注入不同的对象（比如win和linux）" class="headerlink" title="5.16 spring怎么根据不同的环境条件注入不同的对象（比如win和linux）"></a>5.16 spring怎么根据不同的环境条件注入不同的对象（比如win和linux）</h3><p><a href="https://blog.csdn.net/yjc_1111/article/details/78807129">(34条消息) Spring之条件注解@Conditional，条件（系统）不同注入的对象也不同。_Small-Young的博客-CSDN博客_条件注入</a></p><p>我们可以使用注解**@Conditional**，大致就是我们先定义一个接口TomcatService，里面包含两个方法：getTomcatStartupPath、getTomcatShutdownPath。然后可以搞两个不同的实现类去实现这个接口，比如WindowsTomcatService、LinuxTomcatService。下一步就实现两个不同的Condition的子类，然后就可以在注册TomcatService的时候，根据不同的Conditional去注册不同的TomcatService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).contains(<span class="hljs-string">&quot;Windows&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinuxCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).contains(<span class="hljs-string">&quot;Linux&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Conditional(WindowsCondition.class)</span><br>    <span class="hljs-keyword">public</span> TomcatService <span class="hljs-title function_">wndowsListService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsTomcatServiceImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Conditional(LinuxCondition.class)</span><br>    <span class="hljs-keyword">public</span> TomcatService <span class="hljs-title function_">wndowsListService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinuxTomcatServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-SpringBoot相关面试题"><a href="#6-SpringBoot相关面试题" class="headerlink" title="6. SpringBoot相关面试题"></a><strong>6. SpringBoot相关面试题</strong></h2><h3 id="6-1-说一下SpringBoot的加载过程"><a href="#6-1-说一下SpringBoot的加载过程" class="headerlink" title="6.1 说一下SpringBoot的加载过程"></a>6.1 说一下SpringBoot的加载过程</h3><p><img src="20200806150352650.png" alt="img"></p><p>大体启动流程分为三个部分：</p><ol><li>进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器</li><li>实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块</li><li>自动化配置模块，该模块作为springboot自动配置的核心。</li></ol><p>一开始会调用SpringApplication.run方法，它首先会初始化SpringApplication对象，初始化的时候会设置ApplicationContextInitializer和ApplicationListener对象，之后会调用内部的run方法，发布SpringApplicationRunListeners starting事件，准备相关配置环境，初始化ApplicationContext，然后调用prepareContext设置环境加载一部分bean如mainApplication等，最后会调用refreshContext创建BeanFactory容器，加载并初始化bean，执行Bean的后置处理等。</p><h3 id="6-2-说一下拦截器的使用和底层原理"><a href="#6-2-说一下拦截器的使用和底层原理" class="headerlink" title="6.2 说一下拦截器的使用和底层原理"></a>6.2 说一下拦截器的使用和底层原理</h3><p>首先我们可以实现HandlerInterceptor接口，并在里面实现preHandler方法和afterComplete方法。接着去WebMvcConfigurer中配置好拦截器</p><p>拦截器的底层原理大概是，找出处理该请求的所有拦截器，并根据责任链模式一次执行拦截器，只有上一个拦截器返回了true才能执行下一个拦截器，否则不让被拦截的方法执行。 </p><h3 id="6-3-说一下自动装配"><a href="#6-3-说一下自动装配" class="headerlink" title="6.3 说一下自动装配"></a>6.3 说一下自动装配</h3><p>SpringBoot通过@EnableAutoConfiguration注解开启自动装配功能，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器中，就可以完成自动配置。</p><h2 id="7-JUC相关面试题"><a href="#7-JUC相关面试题" class="headerlink" title="7. JUC相关面试题"></a><strong>7. JUC相关面试题</strong></h2><h3 id="7-1-JDK15为什么取消偏向锁"><a href="#7-1-JDK15为什么取消偏向锁" class="headerlink" title="7.1 JDK15为什么取消偏向锁"></a>7.1 JDK15为什么取消偏向锁</h3><ul><li>偏向锁导致synchronized子系统的代码复杂度过高，并影响其它的子系统，造成代码的维护和升级困难。</li><li>偏向锁带来的性能提升从整体来看并没有带来太多的收益，因为偏向锁的撤销成本过高，需要等待全局安全点，并且还需要暂停线程来做锁的撤销。</li></ul><h3 id="7-2-threadlocal在父子线程间是否可见，父子线程间如何通信"><a href="#7-2-threadlocal在父子线程间是否可见，父子线程间如何通信" class="headerlink" title="7.2 threadlocal在父子线程间是否可见，父子线程间如何通信"></a>7.2 threadlocal在父子线程间是否可见，父子线程间如何通信</h3><p><a href="https://blog.csdn.net/qq_38249409/article/details/114300384?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-114300384.pc_agg_new_rank&utm_term=%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B&spm=1000.2123.3001.4430">(34条消息) 【并发编程】（十一）父子线程数据共享——InheritableThreadLocal原理_语言日记-CSDN博客_父子线程怎么共享数据</a></p><h3 id="7-4-什么是协程"><a href="#7-4-什么是协程" class="headerlink" title="7.4 什么是协程"></a>7.4 什么是协程</h3><p><a href="https://zhuanlan.zhihu.com/p/172471249">什么是协程？ - 知乎 (zhihu.com)</a></p><p>协程是一种协作式的用户态线程</p><ol><li>线程和进程是抢占式执行的，意思是系统帮我们自动快速切换线程和进程来让我们感觉同步运行的感觉，这种切换动作由系统自动完成。</li><li>协作式执行说的就是，<strong>想要切换线程，必须用户手动来切换</strong></li></ol><p>协程为什么那么快原因就是因为，无需系统自动切换（系统自动切换会浪费很多的资源），而协程是我们用户手动切换，而且是在同一个栈上执行，速度就会非常快而且省资源。  </p><p>   但是，协程有他自己的问题：  <strong>协程只能有一个进程，一个线程在跑，一旦发生IO阻塞，这个程序就会卡住。</strong>所以我们要使用协程之前，必须要保证我们所有的<strong>IO都必须是非阻塞的</strong>  </p><p><strong>协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></p><p>   协程的真正目的其实并不是为了解决高并发而存在的，而是为了解决无限回调而存在的；  </p><p>   协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><h3 id="7-5-run-和start"><a href="#7-5-run-和start" class="headerlink" title="7.5 run( )和start( )"></a>7.5 run( )和start( )</h3><p><strong>区别：</strong></p><ol><li>run方法被称为线程体，每个线程执行的时候都是执行run方法里面的代码。而通过调用Thread中的start方法来启动一个线程。</li><li>start方法用于启动线程，而run方法用于执行线程的运行时代码。run可以重复调用，而start只能调用一次。</li><li>调用start方法无需等待run方法执行完毕，可以直接继续执行其它的代码，此时线程是就绪态，并没有运行。然后通过此thread类调用run方法来完成其运行态，run方法运行结束，此线程终止，然后CPU调度其它的线程。</li></ol><p><strong>为什么调用start方法的时候会执行run方法，为什么不能直接调用run方法？</strong></p><ol><li>new一个Thread会让该线程进行新建态。调用start方法会启动一个线程并使线程进入了就绪态，当该线程分配到了CPU的时间片之后就可以开始运行。start会执行线程的相应准备工作，然后自动执行run方法里面的内容，这是真正的多线程运行。</li><li>如果直接调用run方法，会把run方法当成一个main线程下的普通方法执行。</li></ol><h3 id="7-6-CAS为什么这么快？"><a href="#7-6-CAS为什么这么快？" class="headerlink" title="7.6 CAS为什么这么快？"></a>7.6 CAS为什么这么快？</h3><ol><li>CAS，比较并交换，如果内存中的值与预期原值相匹配，那么处理器就会自动将该位置的值更新为新的值。否则处理器不做任何操作。</li><li>白话：我认为V的值一定等于A，如果是那就将V的值更新为B，否则不修改并告诉V的值实际是多少。</li><li>CAS的实现并不是简单的代码层面控制的，<strong>而是需要硬件的支持</strong>，因此在不同体系的架构中执行的性能差异很大。 <strong>现代大多数处理器都是从硬件层面通过一些列指令实现CAS同步原语，进而操纵系统和JVM可以直接使用这些指令实现锁和并发的数据结构</strong></li><li><strong>JVM对CAS的支持</strong>：由于Java程序运行在JVM上，所以应对不同的硬件体系架构的处理则需要JVM来实现。在不支持CAS操作的硬件上，JVM将使用自旋锁来实现。</li></ol><h3 id="7-7-为什么还要有非公平锁"><a href="#7-7-为什么还要有非公平锁" class="headerlink" title="7.7 为什么还要有非公平锁"></a>7.7 为什么还要有非公平锁</h3><ol><li>首先恢复挂起的线程到真正获取到锁还是有一定的时间差的。</li><li>假设线程A持有一个锁，并且线程B请求这个锁。由于锁被A持有，因此B将被挂起。当A释放锁之后，B将被唤醒，然后B会再次尝试获取这个锁。与此同时，线程C也来请求这个锁，那么C很有可能在B被完全唤醒之前获得该锁，以及使用并释放该锁。因此非公平锁能更充分的利用CPU等待时间片，尽量减少CPU的空闲时间。</li><li>举例：比如我在排队加油，我是第二个，但是我一直在玩手机，忘了到我了，然后后面的人就先行加油。</li></ol><h3 id="7-8-AQS原理"><a href="#7-8-AQS原理" class="headerlink" title="7.8 AQS原理"></a>7.8 AQS原理</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。  </p><p><strong>AQS 定义两种资源共享方式</strong>  </p><ul><li><p>Exclusive（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁： </p></li><li><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 </li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p>Share（共享）：多个线程可同时执行，如CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p>ReentrantReadWriteLock   可以看成是组合式，因为   ReentrantReadWriteLock   也就是读写锁允许多个线程同时对某一资源进行读。  </p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。  </p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><h3 id="7-9-synchronized和volatile的区别"><a href="#7-9-synchronized和volatile的区别" class="headerlink" title="7.9 synchronized和volatile的区别"></a>7.9 synchronized和volatile的区别</h3><ol><li>sync表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其余的线程；volatile表示变量在CPU寄存器中是不确定的，必须从主存中读取，保证多线程环境下变量的可见性，禁止指令重排。</li><li>volatile是变量修饰符，而sync可以作用与静态方法、方法和代码块。</li><li>volatile不会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化</li><li>volatile是线程同步的轻量级实现，性能比sync要高，但是volatile只能用于变量，而且volatile无法保证原子性。sync有了锁升级和各种优化，比如锁粗化和锁消除。</li></ol><h3 id="7-10-举一举线程不安全的例子"><a href="#7-10-举一举线程不安全的例子" class="headerlink" title="7.10 举一举线程不安全的例子"></a>7.10 举一举线程不安全的例子</h3><p><strong>线程安全的概念</strong>：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。</p><ul><li>代码本身封装了所有必要的正确性保障手段（互斥或者同步），调用者无需关系这些内容，无需自己去实现任何措施来保证多线程环境下的正常调用。</li></ul><p>比如多个线程同时操作i++，或者多个线程共享一个HashMap，导致在1.7的时候会产生环形链或者数据覆盖，而1.8的时候利用尾插法解决了环形链，但是还是会有数据覆盖。</p><p><strong>并发三要素：</strong></p><ol><li>原子性：指的是一个或多个操作要么全部执行成功，要么全部执行失败。</li><li>可见性：一个线程对共享变量的修改，另一个线程能够马上看得到。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对执行进行重排序）</li></ol><p><strong>出现线程安全问题的原因：</strong></p><ol><li>多线程的切换带来的原子性问题</li><li>JMM内存模型，即缓存带来的可见性问题</li><li>编译优化带来的有序性问题（执行重排）</li></ol><p><strong>解决办法：</strong></p><ol><li>JDK Atomic开头的原子类、synchronized、Lock、CAS自选，解决原子性问题</li><li>volatile、sync、lock解决可见性问题</li><li>happens-before解决有序性问题。</li></ol><h3 id="7-11-synchronized底层实现原理"><a href="#7-11-synchronized底层实现原理" class="headerlink" title="7.11 synchronized底层实现原理"></a>7.11 synchronized底层实现原理</h3><p>可以从两方面来回答：</p><p><strong>1、JVM层面</strong></p><p>如果使用同步代码块，底层是通过monitorenter来获取锁，使用monitorexit来释放锁。但是注意的是<strong>同步代码块方式的sync会有两个monitorexit</strong>，这是问题：</p><p>防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会导致死锁。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p><p>而如果sync修饰方法，则字节码文件中没有monitorenter和monitorexit，而是会有个标识，<code>ACC_SYNCHRONIZED</code>；如果sync修饰静态方法，则还会多一个<code>ACC_STATIC</code>。</p><p><strong>2、底层层面</strong></p><p>每个锁其实都对应着一个monitor对象，多个线程想要访问共享资源的时候，就必须获取该锁的monitor，而这个monitor在c++层面是由ObjectMonitor实现的，每个对象都会有一个monitor与之关联。在ObjectMonitor中就维护了计数器和指向持有该monitor的线程的指针。</p><p><strong>synchronized可重入锁原理：</strong></p><p>每个锁底层都维护着一个计数器和一个指向只有该锁的线程的指针，当线程获取该锁的时候，计数器加一，当释放锁的时候，计数器减一。当计数器为零，标识该锁没有被任何线程占有。</p><h3 id="7-12-synchronized和Lock"><a href="#7-12-synchronized和Lock" class="headerlink" title="7.12 synchronized和Lock"></a>7.12 synchronized和Lock</h3><ol><li>sync是Java中的关键字，在JVM层面；而Lock是Java中的一个类。</li><li>sync可以给方法、静态方法、代码块加锁，而Lock只能给代码块加锁。</li><li>sync不需要手动的释放锁，使用简单，而Lock需要手动释放锁。</li><li>Lock支持精准唤醒，而sync只能随机唤醒或者全部唤醒。</li></ol><h3 id="7-13-为什么wait、notify等方法需要在sync内部使用"><a href="#7-13-为什么wait、notify等方法需要在sync内部使用" class="headerlink" title="7.13 为什么wait、notify等方法需要在sync内部使用"></a>7.13 为什么wait、notify等方法需要在sync内部使用</h3><p>当一个线程正在某个对象的同步方法中运行时调用了这个对象的wait方法，那么这个线程将释放对象的独占锁并放入这个对象的等待队列中。注意的是wait方法会强制当前线程释放对象锁，这就意味着<strong>在调用某对象的wait方法之前，当前线程必须已经获得该对象的锁。</strong>因此wait方法必须在sync中使用。</p><p>当线程调用某对象的notify或notifyall方法时，任意一个或者所有的在该对象的waitSet中的线程，将会被转移到该对象的EntryList中，接着这些队列将会竞争该对象的锁，最终获得锁的线程继续执行。如果没有线程在该对象的等待队列中等待获得锁，那么notify或notifyAll将不起任何作用。在调用对象的notify或notifyAll方法之前，调用线程必须已经得到该对象的锁，因此必须在sync内部使用。</p><p>拿生产者消费者的例子进一步说明：生产者向缓冲区中写入数据，消费者从缓冲区中读取数据。消费者线程需要等待直到生产者完成一次写入操作，生产者需要等待消费者完成一次读取操作。假如wait、notify、notifyAll不需要加锁就能够被调用，那么此时消费者线程调用wait，然后正在进入等待队列（可能还未进入，只是正在进入），在同一时刻，生产者调用notify打算向消费者线程通知状态改变，那么此时消费者线程将错过这个通知并一直阻塞。而生产者认为自己已经发出了通知，一直在等待消费者将自己唤醒，这就出现问题了。</p><h2 id="8-不知道分类面试题"><a href="#8-不知道分类面试题" class="headerlink" title="8. 不知道分类面试题"></a><strong>8. 不知道分类面试题</strong></h2><h3 id="8-1-说一下一致性哈希"><a href="#8-1-说一下一致性哈希" class="headerlink" title="8.1 说一下一致性哈希"></a>8.1 说一下一致性哈希</h3><p><a href="https://www.zsythink.net/archives/1182">白话解析：一致性哈希算法 consistent hashing-朱双印博客 (zsythink.net)</a></p><p>场景假设：如果我们有三台服务器用来缓存图片，那么就可以使用哈希算法以图片的名称计算hash，并且将其映射到这三台服务器上。这就可以让图片近乎均匀的缓存在这三台服务器上。</p><p>但是如果有一天，有一台服务器要下了，或者要增加一台新的服务器，这时所有的图片缓存都需要进行hash重算，就会导致所有的缓存都失效，也就是造成缓存雪崩问题，导致整个系统的压力过大而崩溃。而且就算不崩溃，几乎所有的缓存的位置都会发生变化，这也会对性能产生影响。</p><p>这时候一致性哈希算法就应运而生。</p><p>一致性哈希首先会假设有一个hash环。我们可以对服务器的IP地址进行取模运算，公式如下：</p><p><strong>hash（服务器A的IP地址）%2^32</strong></p><p>这样就会将这三台服务器放在hash环中的某个位置：（理想状况）</p><p><img src="image-20220309094122453.png" alt="image-20220309094122453"></p><p>同时，对于每一张图片，我们也同样计算它的位置：<strong>hash（图片名称）%2^32</strong>，</p><p><img src="image-20220309094224633.png" alt="IMG/面试话术.asserts/image-20220309094224633.png"></p><p>我们以顺时针的方式来判断该图片应该属于哪一个服务器。上图的示例就是图片1和图片2缓存到服务器A，图片3缓存到服务器B，图片4缓存到服务器C上。</p><p>如果此时B给宕机了，那么只需要将图片3给缓存到服务器C就行了，其余的图片就不需要改变。这就只会影响一部分的缓存，从而减少系统的压力。</p><p>但是其实上面是理想的情况，我们还可能造成<strong>hash环的倾斜</strong></p><p>实际计算hash的过程中，不会分布的那么均匀，就可能导致服务器之间在hash环上的位置非常的窄小，就会导致缓存的数据分布不均匀：</p><p><img src="image-20220309094541586.png" alt="IMG/面试话术.asserts/image-20220309094541586.png"></p><p><strong>这就需要虚拟节点了</strong></p><p>我们凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。</p><p><img src="image-20220309094606629.png" alt="IMG/面试话术.asserts/image-20220309094606629.png"></p><p><strong>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</strong>虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p><h3 id="8-2-什么是倒排索引"><a href="#8-2-什么是倒排索引" class="headerlink" title="8.2 什么是倒排索引"></a>8.2 什么是倒排索引</h3><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。</p><h3 id="8-3-负载均衡算法的实现"><a href="#8-3-负载均衡算法的实现" class="headerlink" title="8.3 负载均衡算法的实现"></a>8.3 负载均衡算法的实现</h3><p><a href="https://www.cnblogs.com/xrq730/p/5154340.html">几种简单的负载均衡算法及其Java代码实现 - 五月的仓颉 - 博客园 (cnblogs.com)</a></p><ol><li><strong>轮询法：</strong>它试图做到请求转移的绝对均衡。但是同时也需要付出一定代价，因为为了保证并发下的均衡，可能得引入悲观锁或者CAS。</li><li><strong>随机法：</strong>基于概率统计的理论，吞吐量越大，随机算法的效果越接近于轮询算法的效果。</li><li><strong>源地址哈希法</strong>：获取客户端访问的IP地址值，通过哈希函数计算得到一个哈希值，用该值对服务器列表的大小进行取模运算。</li><li><strong>加权轮询</strong>：不同的服务器可能配置不同，因此可以给配置高、负载低的机器赋予更大的权重。</li><li><strong>最小连接数</strong>：以后端服务器的视角来观察系统的负载，而不是请求发起方来观察。该算法比较灵活，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，因此该算法就会动态的选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能提高后端服务器的利用效率，将负载合理地分流到每一台机器。</li></ol><h3 id="8-4-CPU的原子操作"><a href="#8-4-CPU的原子操作" class="headerlink" title="8.4 CPU的原子操作"></a>8.4 CPU的原子操作</h3><p><a href="https://blog.csdn.net/qq_33215865/article/details/88562456">(34条消息) CPU实现原子操作的方法_盐焗咸鱼的博客-CSDN博客_cpu原子操作</a></p><p>首先对于单核CPU来说，所有的时间都是串行，执行完第一个才会去执行第二个，每个指令都是原子的。</p><p>对于多核CPU来说：</p><ol><li>CAS：它会检测现在内存中的值是不是符合预期值，如果符合就更新为新值，否则就丢弃新值</li><li>使用总线锁：用来锁住某一个共享内存，当一个CPU要对内存进行操作的时候，会加上总线锁，限制其它cpu对共享内存操作。</li><li>使用缓存锁：使用总线锁会锁定cpu与内存的通信，所以开销很大。而缓存锁在一个cpu进行回写时，会使用缓存一致性机制来保护内部内存，当其它处理器回写已被锁定的缓存行的数据时缓存行无效。</li></ol><h3 id="8-5-Hash冲突的解决办法"><a href="#8-5-Hash冲突的解决办法" class="headerlink" title="8.5 Hash冲突的解决办法"></a>8.5 Hash冲突的解决办法</h3><p><a href="https://www.jianshu.com/p/4d3cb99d7580">解决哈希冲突的常用方法分析 - 简书 (jianshu.com)</a></p><ol><li><strong>拉链法</strong></li><li><strong>开放地址法：</strong>从发生冲突的单元起，按照一定的次序，从哈希表找到一个空闲的单元，然后将发生哈希冲突的元素存入到该单元。</li><li><strong>再哈希法：</strong>同时构造多个不同的哈希函数。当H1&#x3D;RH1（key）发生冲突时，再用H2 &#x3D; RH2（key）进行计算，直到冲突不再发生，这种方法不易产生聚集，但是增加了计算的时间。</li><li><strong>建立公共溢出区：</strong>将哈希表分为基本表和溢出表，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ol><h3 id="8-6-git常用命令"><a href="#8-6-git常用命令" class="headerlink" title="8.6 git常用命令"></a>8.6 git常用命令</h3><p><img src="011500266295799.jpg" alt="img"></p><h3 id="8-7-典型的对称加密和非对称加密算法"><a href="#8-7-典型的对称加密和非对称加密算法" class="headerlink" title="8.7 典型的对称加密和非对称加密算法"></a>8.7 典型的对称加密和非对称加密算法</h3><blockquote><p>对称加密算法 AES、DES、3DES</p></blockquote><p>DES是一种分组数据加密技术（先将数据分成固定长度的小数据块，之后进行加密），速度较快，适合于大量数据加密。3DES是一种基于DES的加密算法，使用3个不同密钥对同一个分组数据块进行3次加密，使密文强度更高。</p><p>相对于DES和3DES来说，AES算法有着更高的速度和资源使用效率，安全级别更高，被称为下一代加密算法</p><blockquote><p>非对称加密算法：RSA、DSA、ECC</p></blockquote><p>RSA和DSA的安全性及其各方面性能都差不多，而ECC较之则有着很多的性能优越，包括处理速度，带宽要求，存储空间等</p><p>RSA算法包含了RSA加密算法和哈希算法</p><h3 id="8-8-JWT"><a href="#8-8-JWT" class="headerlink" title="8.8 JWT"></a>8.8 JWT</h3><blockquote><p>session的缺点</p></blockquote><p>HTTP是无状态的协议，它无法识别用户发出的请求的身份，因此可以使用Cookie或者Session机制。</p><p>但是Session是保存在服务端的，随着用户增多，可能造成服务端内存压力过大。而且如果是分布式的应用，就限制了应用扩展能力。</p><blockquote><p>基于token的鉴权机制</p></blockquote><ul><li>用户使用用户名或密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证并返回给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>每次请求的时候都得将token传递给服务端，保存在请求头中，服务端还得支持跨域策略。</p><blockquote><p>token和cookie的区别</p></blockquote><p>token相对cookie的优点：token完全由应用管理，可拓展性强，它可以放在cookie，也可以放在localstorage中，因此在某些不支持cookie的应用中就可以去使用token。</p><blockquote><p>什么是JWT</p></blockquote><p>JSON WEB TOKEN，由三部分组成，header、payload、signature</p><p><strong>header</strong></p><p>头部有两部分信息：声明类型，声明加密的算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  &#x27;typ&#x27;<span class="hljs-punctuation">:</span> &#x27;JWT&#x27;<span class="hljs-punctuation">,</span><br>  &#x27;alg&#x27;<span class="hljs-punctuation">:</span> &#x27;HS256&#x27;<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后将头部进行base64加密（可以对称解密）</p><p><strong>payload</strong></p><p>载荷包含三部分：标准中注册的声明（jwt签发者，jwt过期时间，签发时间等等），公共的声明（添加任何的信息，一般是用户的相关信息或者业务需要的必要信息，不建议添加敏感信息），私有的声明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>同样也要用base64进行加密</p><p><strong>signature</strong></p><p>三部分组成：加密后的header、加密后的payload，secret</p><p>签名的作用是保证JWT没有被篡改，实质上是对头部和负载内容进行签名。密钥只有服务器才知道，不能泄漏给用户。使用的是header中指定的签名算法进行签名</p><p><img src=".." alt="JWT"></p><blockquote><p>JWT的特点</p></blockquote><ul><li>由于JSON的通用性，JWT支持跨语言</li><li>JWT可以存储自身一些其他业务逻辑所需要的非敏感信息。</li><li>便于传输，JWT的构成简单，字节占用小</li><li>不需要再服务端保存会话信息，易于应用扩展</li><li>不应在JWT的payload中存放敏感信息，因为这部分客户端可以解密</li><li>保护好secret私钥</li></ul><h2 id="9-Java基础"><a href="#9-Java基础" class="headerlink" title="9. Java基础"></a><strong>9. Java基础</strong></h2><h3 id="9-1-static可以修饰什么，可以修饰类吗？"><a href="#9-1-static可以修饰什么，可以修饰类吗？" class="headerlink" title="9.1 static可以修饰什么，可以修饰类吗？"></a>9.1 static可以修饰什么，可以修饰类吗？</h3><p>static一般用来修饰成员变量和方法，也可以修饰类，但是普通类不允许声明为静态的，只有内部类可以。</p><p><strong>追问1：静态内部类的特点</strong></p><ol><li>静态内部类可以用静态成员变量和静态方法（普通内部类不能拥有）</li><li>可以直接创建实例，不需要先创建外部类。<code>Test.StaticInner staticInner = new Test.StaticInner();</code>，而普通内部类需要先创建外部类：<code>Test.Inner inner1 = new Test().new Inner();</code></li><li>只可以直接访问外部类的静态成员，不可以直接访问外部类的非静态成员，需要传入外部类引用的方式才能使用。</li><li>不持有外部类的引用（普通内部类持有）</li></ol><p><strong>追问2：什么时候会用到静态内部类</strong></p><ol><li>内部类与所在的外部类有一定的关系，往往只有该外部内会调用此内部类，就无需专门用一个Java文件来存放这个类。</li></ol><h3 id="9-2-Java为什么不支持多继承"><a href="#9-2-Java为什么不支持多继承" class="headerlink" title="9.2 Java为什么不支持多继承"></a>9.2 Java为什么不支持多继承</h3><p><a href="https://blog.csdn.net/u014133299/article/details/77571912">(34条消息) Java不支持多继承的原因_u014133299的博客-CSDN博客_java为什么不支持多继承</a></p><p>首先Java是一门面向对象的语言，从语义上来说，一个类继承了另一个类，那么这两个类就可以理解为父子关系，一个儿子只能有一个父亲。</p><p>再者多继承容易产生二义性：比如一个抽象类Animal，有一个抽象方法eat。此时有两个类分别继承了这个Animal类，Bird和Horse，但是同时又有一个类Pegasus继承了Horse和Bird类，当Pegasus执行eat方法时，到底是执行Bird的还是Horse的呢？这就产生了歧义。【致命方块】</p><p>为何接口不会产生致命方块问题，是以为接口所有的方法都是抽象的，实现的类必须得实现所有接口定义的接口，这不会存在歧义问题。</p><p>那么注意的是在1.8的时候，接口可以拥有默认实现，如果我们有两个接口，都同时默认实现了方法a，那么类Test去同时实现T1和T2接口的时候，又该去选择哪个接口呢？</p><p><strong>如果一个类同时实现的多个接口拥有相同的默认实现方法，如果不去在该类中实现该默认方法，就会产生编译时错误！</strong></p><p><img src="image-20220402180133872.png" alt="image-20220402180133872"></p><p>同时在Class文件结构中，只用了一个u2表示它的父类，而用了一个u2数组来表示该类对应的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             this_class;<span class="hljs-comment">//当前类</span><br>u2             super_class;<span class="hljs-comment">//父类</span><br>u2             interfaces_count;<span class="hljs-comment">//接口</span><br>u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br></code></pre></td></tr></table></figure><h3 id="9-3-List一边遍历一边删除"><a href="#9-3-List一边遍历一边删除" class="headerlink" title="9.3 List一边遍历一边删除"></a>9.3 List一边遍历一边删除</h3><p>如果是使用正序遍历：注意要修改i &#x3D; i - 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; platformList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    platformList.add(<span class="hljs-string">&quot;博客园&quot;</span>);<br>    platformList.add(<span class="hljs-string">&quot;CSDN&quot;</span>);<br>    platformList.add(<span class="hljs-string">&quot;掘金&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; platformList.size(); i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> platformList.get(i);<br>        <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;博客园&quot;</span>)) &#123;<br>            platformList.remove(i);<br>            i = i - <span class="hljs-number">1</span>; <br>        &#125;<br>    &#125;<br>    System.out.println(platformList);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是逆序遍历：不需要修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; platformList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    platformList.add(<span class="hljs-string">&quot;博客园&quot;</span>);<br>    platformList.add(<span class="hljs-string">&quot;CSDN&quot;</span>);<br>    platformList.add(<span class="hljs-string">&quot;掘金&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> platformList.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> platformList.get(i);<br>        <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;掘金&quot;</span>)) &#123;<br>            platformList.remove(i);<br>        &#125;<br>    &#125;<br>    System.out.println(platformList);<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用removeIf方法【推荐】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><br>    list.removeIf(item -&gt; <span class="hljs-string">&quot;aaa&quot;</span>.equals(item));<br>    <span class="hljs-comment">// 也可以用下面的代替：</span><br>    list.removeIf(<span class="hljs-string">&quot;aaa&quot;</span>::equals);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-4-自动装箱和拆箱"><a href="#9-4-自动装箱和拆箱" class="headerlink" title="9.4 自动装箱和拆箱"></a>9.4 自动装箱和拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">11</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>    System.out.println(a == c); <br>    System.out.println(a == b);<br>    System.out.println(b == c);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为true、false、true</p><p>如果a和c比较、b和c比较，因为c是基本数据类型，所以a和b都会进行拆箱，因此都转换为基本数据类型。</p><p>而a和b比较，b会进行装箱，取得是缓存池中的11的地址，所以为false</p><p><strong>为什么要有包装类型：</strong></p><ol><li>Java本身就是一门OOP语言，对象是灵魂。</li><li>基本数据类型有默认值，但是在业务中，可能我更加希望它的值是null，因为默认值也算是值。</li><li>泛型参数不能是基本数据类型，必须是Object及其子类。</li></ol><p><strong>自动拆箱带来的NPE问题</strong></p><ol><li><p>数据库的查询结果可能是null，如果使用基本数据类型进行接受，可能会导致NPE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>().getNum();<br>&#125;<br><br><span class="hljs-keyword">private</span> Integer <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>三元运算符的不正确使用导致诡异的NPE</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> flag ? <span class="hljs-number">1</span> : a;<br></code></pre></td></tr></table></figure><p>原因在计算三元表达式结果时，a变量自动拆箱，调用了Integer.intValue()方法。</p><p><strong>在三元表达式中，当第二、第三位操作数中有基本类型和对象时，对象就会拆箱为基本数据类型进行操作。</strong></p></li></ol><h3 id="9-5-序列化ID的作用"><a href="#9-5-序列化ID的作用" class="headerlink" title="9.5 序列化ID的作用"></a>9.5 序列化ID的作用</h3><p>首先序列化就是将对象转换为字节流，而反序列化就是将字节流再转换成对象。</p><p>一般我们对可以进行序列化的对象进行序列化之前，该对象都得需要一个seriallVersionUID，原因就是Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在反序列化时，JVM会将传来的字节流中的serialVersionUID与本地实体类中的UID进行比较，如果相同则认为一致的，不相同就会报错。</p><p>如果我们没有显示指定UID，Java序列化机制就会根据编译时的class自动生成一个UID，只有同一次编译生成的class才会生成相同的UID。</p><h3 id="9-6-泛型的缺点"><a href="#9-6-泛型的缺点" class="headerlink" title="9.6 泛型的缺点"></a>9.6 泛型的缺点</h3><p>Java中的泛型是伪泛型，这是因为在Java运行期间，所有的泛型信息都会被擦掉，也就是<strong>类型擦除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//        list.add(&#x27;a&#x27;);</span><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; clazz = list.getClass();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>    add.invoke(list,<span class="hljs-string">&quot;a&quot;</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终输出的结果是：<code>[1, a]</code></p><h3 id="9-7-HashMap详解"><a href="#9-7-HashMap详解" class="headerlink" title="9.7 HashMap详解"></a>9.7 HashMap详解</h3><h4 id="1-HashMap的hash扰动函数"><a href="#1-HashMap的hash扰动函数" class="headerlink" title="1. HashMap的hash扰动函数"></a>1. HashMap的hash扰动函数</h4><ul><li>使用扰动函数是为了防止一些比较差的hashCode函数，也就是为了减少哈希碰撞</li><li>底层1.7之前hash使用四次扰动，1.8之后只使用一次扰动，即hashcode右移16位，然后进行异或，目的是为了更全面的收集信息进一步减少冲突的可能，异或运算的结果更均匀</li><li>数组长度-1的作用相当于掩码，代替了取余的作用，效率更高</li></ul><h4 id="2-为什么hashmap中String、Integer这样的包装类适合作为key"><a href="#2-为什么hashmap中String、Integer这样的包装类适合作为key" class="headerlink" title="2. 为什么hashmap中String、Integer这样的包装类适合作为key"></a>2. 为什么hashmap中String、Integer这样的包装类适合作为key</h4><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况；</li></ul><h4 id="3-hashmap中的size究竟是什么"><a href="#3-hashmap中的size究竟是什么" class="headerlink" title="3. hashmap中的size究竟是什么"></a>3. hashmap中的size究竟是什么</h4><p>首先结论就是hashmap中的size其实就是map中所有的键值对数量。如果该数量大于负载因子*容量了，就会进行扩容。</p><p>而当hashmap中的链表长度大于8了，就会判断数组的长度是否超过64，如果超过了就会将链表转为红黑树。否则只会对数组扩容。</p><h4 id="4-HashMap扩容优化"><a href="#4-HashMap扩容优化" class="headerlink" title="4. HashMap扩容优化"></a>4. HashMap扩容优化</h4><p>在1.7的时候，hashMap会对每个元素都进行rehash算法， 计算原来每个元素在扩容之后的哈希表中的位置，但是这样效率过低。</p><p>在1.8的时候，HashMap借助两倍扩容机制，使元素不需要进行重新计算位置，而是通过高位运算<code>e.hash &amp; oldCap</code>的方式来确定元素是否需要移动，如果高位为0，就表示不需要移动；如果为1，就表示元素在扩容的时候发生了变化，新的下标位置等于原下标位置+原数组长度。</p><h4 id="5-为什么扩容是两倍"><a href="#5-为什么扩容是两倍" class="headerlink" title="5. 为什么扩容是两倍"></a>5. 为什么扩容是两倍</h4><p>一般在计算完hash之后就得进行取余操作来决定该元素放在数组的哪个位置。但是**取余操作中如果除数是2的幂次方则等价于该hash值与其除数减一的与操作，也就是说 hash%length &#x3D; hash &amp; (length - 1)**，采用二进制与操作，相对于%来说能够提升运算效率。</p><p>而且在2的幂次方的前提下采用了这种位运算方式，<strong>hash值始终在和一个大部分数字都为1的值做与运算，那么就有更大的可能性不会发生冲突（这可以提一下1.8时候的扰动函数）</strong>。因为在与运算中，如果一个数全为1，那么结果就完全取决于另外一个数，而这里的另外一个数就是指hash算法求出来的hash值，这样就大大减少了冲突的可能性。因为一个良好的hash函数会导致不同对象的hash值几乎不相等。</p><h3 id="9-8-Comparator和Comparable"><a href="#9-8-Comparator和Comparable" class="headerlink" title="9.8 Comparator和Comparable"></a>9.8 Comparator和Comparable</h3><p>Comparable可作为一个类的内部排序实现，Java中一些普通类型如String、Integer等都实现了该接口，我们直接使用即可。</p><p>Comparator是外部排序接口，使用策略模式，一个类的排序规则在基于“开闭原则”时，可通过实现Compartor制定多个比较排序策略，供该类采用。可用于Collections.sort()、Arrays.sort()以及一些内部有序的类（SortedSet、SortedMap等）。</p><h3 id="9-9-快速失败机制“fail-fast”"><a href="#9-9-快速失败机制“fail-fast”" class="headerlink" title="9.9 快速失败机制“fail-fast”"></a>9.9 快速失败机制“fail-fast”</h3><p>这个机制是Java集合的一种错误检测机制，当在迭代集合过程中进行结构上的改变的操作时，有可能会产生fail-fast机制。<strong>单机和多线程时候都有可能会触发</strong></p><p>如果有两个线程，线程1通过iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构的修改，不是简单的修改集合元素中的内容），那么就会报错：ConcurrentModificcationException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        list.add(i + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>            list.remove(<span class="hljs-number">3</span>);<br>        &#125;<br>        System.out.println(iterator.next());<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原因：</strong>迭代器在遍历的时候直接访问集合中的内容， 并且在遍历过程中会使用到一个叫modCount的变量。集合在遍历过程中如果内容发生了变化，就会改变modCount的值。同时抛出异常的主要原因就是每次迭代器hasNext()&#x2F;next()遍历下一个元素之前，都会判断modCount是否等于expectedModCount，而一开始这两者是相等的。因此如果在遍历过程中，集合的内容发生了变化，就会导致异常的出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次调用next/hasNext方法的时候都会去调用该方法来判断集合中的内容是否发生变化</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决办法：</strong>使用CopyOnWriterArrayList来代替ArrayList；使用removeIf；使用迭代器中的remove方法而不是使用ArrayList中的remove方法，因为在迭代器中的remove方法里面，会让expectedModCount重新等于modCount</p><h3 id="9-10-为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#9-10-为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="9.10 为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>9.10 为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><p>首先被加上transient修饰的属性将不会被序列化。</p><p>对于ArrayList而言，由于扩容机制，就可能导致有一定的空间是没有被使用的，list重写了writeObject方法，它先将ArrayList中的非transient属性给序列化，然后会去遍历整个elementData，只序列化已存入的元素，这样即加快了序列化的速度，也减少了序列化之后的文件大小。</p><h3 id="9-13-重写的规则？"><a href="#9-13-重写的规则？" class="headerlink" title="9.13 重写的规则？"></a>9.13 重写的规则？</h3><ol><li>参数列表和返回类型必须完全与被重写的方法一致。</li><li>构造方法不能被重写，声明为final的方法不能被重写</li><li>声明为static的方法不能被重写，但是能够被再次声明</li><li>访问权限不能比父类中被重写的方法低，即父类如果是public，子类就不能是protected</li><li>重写的方法能够抛出任何非强制异常（uncheckedException，也叫非运行时异常），但是重写的方法不能抛出新的强制性异常，或者比被重写的方法声明的更广泛的强制性异常。</li></ol><h3 id="9-14-红黑树和AVL树"><a href="#9-14-红黑树和AVL树" class="headerlink" title="9.14 红黑树和AVL树"></a>9.14 红黑树和AVL树</h3><p>链接：<a href="https://www.nowcoder.com/discuss/817925?channel=-1&source_id=profile_follow_post_nctrack">https://www.nowcoder.com/discuss/817925?channel=-1&amp;source_id=profile_follow_post_nctrack</a></p><p>普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。以红黑树为例，红黑树通过如下的性质定义实现自平衡：  </p><ol><li><strong>节点是红色或黑色。</strong> </li><li><strong>根是黑色。</strong> </li><li><strong>所有叶子都是黑色（叶子是NIL节点）。</strong> </li><li><strong>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</strong> </li><li><strong>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</strong></li></ol><p>​    有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的节点进行增删查操作时，效率也会大大降低。这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证<strong>任意节点到其每个叶子节点路径最长不会超过最短路径的2倍</strong>。原因如下：  </p><p>​    当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 &#x3D; 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。</p><p><strong>AVL和红黑树</strong></p><p>AVL就是平衡二叉树，它的所有子树的高度之差小于等于1。如果插入或删除后破坏了平衡性，就得将其进行旋转处理，但是频繁的旋转会造成性能损失。</p><ol><li>AVL的时间复杂度虽然优于红黑树，但是性能差异不是太大。</li><li>红黑树的插入删除比AVL树更便于控制操作。</li><li>红黑树整体的性能略优于AVL树（红黑树旋转情况少于AVL树）</li></ol><h3 id="9-15-为什么ConcurrentHashMap读操作不需要加锁"><a href="#9-15-为什么ConcurrentHashMap读操作不需要加锁" class="headerlink" title="9.15 为什么ConcurrentHashMap读操作不需要加锁"></a>9.15 为什么ConcurrentHashMap读操作不需要加锁</h3><p><a href="https://cloud.tencent.com/developer/article/1461980">Java 经典面试题：为什么 ConcurrentHashMap 的读操作不需要加锁？ - 云+社区 - 腾讯云 (tencent.com)</a></p><ol><li>在1.8中ConcurrentHashMap的get操作全程不需要加锁。</li><li>是因为Node的成员val是用volatile修饰的，和数组用volatile修饰没有关系。</li><li>数组用volatile修饰主要是保证数组在扩容时的可见性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-comment">//可以看到这些都用了volatile修饰</span><br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-16-接口和抽象类"><a href="#9-16-接口和抽象类" class="headerlink" title="9.16 接口和抽象类"></a>9.16 接口和抽象类</h3><table><thead><tr><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>不可以定义构造器</td><td>可以定义构造器</td></tr><tr><td>只能有抽象方法，1.8的时候有默认实现</td><td>可以有抽象方法和具体方法，不能有默认方法</td></tr><tr><td>不能有静态方法</td><td>可以有静态方法</td></tr><tr><td>一个类可以实现多个接口</td><td>一个类只能继承一个抽象类</td></tr><tr><td>成员全都是public的</td><td>成员可以是public、protected、private、默认</td></tr><tr><td>成员变量实际上全都是常量，public static final</td><td>有抽象方法的类一定是抽象类，而抽象类未必要有抽象方法</td></tr></tbody></table><p>相同点：</p><ol><li>都不能实例化</li><li>可以将抽象类和接口作为引用类型。</li><li>如果一个类继承了某个抽象类或者实现了某个接口，都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。</li></ol><h3 id="9-17-反射导致的异常"><a href="#9-17-反射导致的异常" class="headerlink" title="9.17 反射导致的异常"></a>9.17 反射导致的异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;String  of test&quot;</span>;<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> origin.getClass().getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>    value2.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">char</span>[] o2 = (<span class="hljs-type">char</span>[]) value2.get(origin);<br>    o2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>    o2[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>    o2[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;f&#x27;</span>;<br>    o2[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>    o2[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>    o2[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    o2[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;t&#x27;</span>;<br><br>    <span class="hljs-comment">//此时S3&quot;Reflect of test&quot;</span><br>    <span class="hljs-comment">//origin为&quot;Reflect of test&quot;</span><br>    <span class="hljs-comment">//        String ss=&quot;Reflect of test&quot;;</span><br><br>    String sss=<span class="hljs-string">&quot;String  of test&quot;</span>;<br>    System.out.println(sss);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-18-HashMap和HashTable的区别"><a href="#9-18-HashMap和HashTable的区别" class="headerlink" title="9.18 HashMap和HashTable的区别"></a>9.18 HashMap和HashTable的区别</h3><ol><li>HashMap是线程不安全的，HashTable是线程安全的，适合在多线程使用，但是它对数据的操作都会使用上synchronized锁，效率低下。</li><li>HashTable不允许键或值为null的；HashMap的键值都可以为null</li><li>初始化容量不同：HashMap的初始容量是16，每次扩容2倍。HashTable初始容量是11，每次扩容2倍 + 1，而且如果指定了HashTable的容量初始值，它会直接使用你给定的大小。</li><li>底层数据结构：1.8的时候HashMap有了大改变</li></ol><blockquote><p>关于HashTable不允许键或值为null的解释</p></blockquote><p>HashTable的作者认为要从HashTable成功存储和检索对象，用作键的对象必须实现hashCode和equals，但是null不是对象，因此无法调用equals或hashCode，因此HashTable无法将其计算哈希值用以键。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">* This class implements <span class="hljs-selector-tag">a</span> hash <span class="hljs-selector-tag">table</span>, which maps keys <span class="hljs-selector-tag">to</span> values. Any<br>* non-&lt;<span class="hljs-selector-tag">code</span>&gt;null&lt;/<span class="hljs-selector-tag">code</span>&gt; <span class="hljs-selector-tag">object</span> can be used as <span class="hljs-selector-tag">a</span> key or as <span class="hljs-selector-tag">a</span> value. &lt;<span class="hljs-selector-tag">p</span>&gt;<br>*<br>* <span class="hljs-selector-tag">To</span> successfully store and retrieve objects <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> hashtable, the<br>* objects used as keys must implement the &lt;<span class="hljs-selector-tag">code</span>&gt;hashCode&lt;/<span class="hljs-selector-tag">code</span>&gt;<br>* method and the &lt;<span class="hljs-selector-tag">code</span>&gt;equals&lt;/<span class="hljs-selector-tag">code</span>&gt; method. &lt;<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="9-19-安全失败机制（fail-safe）"><a href="#9-19-安全失败机制（fail-safe）" class="headerlink" title="9.19 安全失败机制（fail-safe）"></a>9.19 安全失败机制（fail-safe）</h3><p>采用安全失败机制的集合容器，在遍历的时候不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所做的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p><strong>缺点</strong>：基于拷贝的遍历是为了避免CME，但是迭代器不能访问到修改后的内容，即迭代器遍历的是一开始那一时刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h3 id="9-20-boolean-占用多少字节"><a href="#9-20-boolean-占用多少字节" class="headerlink" title="9.20 boolean 占用多少字节"></a>9.20 boolean 占用多少字节</h3><p>结论：单个 boolean 占用 4 字节，而 boolean 数组中每个 boolean 占用 1 字节。</p><p>Java 虚拟机规范中提到：在Java虚拟机中没有任何供 boolean值专用的字节码指令,Java语言表达式所操作的 boolean值,在编译之后都使用<strong>Java虚拟机中的int数据类型</strong>来代替。•Java虚拟机直接支持 boolean类型的数组,虚拟机的 navarra指令参见第6章的newarray小节可以创建这种数组。<strong>boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令</strong></p><p>在Java虚拟机中，对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表示专门为哪种数据类型服务。但是Java虚拟机的操作码长度只有一个字节，这就带来一个问题，如果每种与数据类型相关的指令都支持Java虚拟机运行时数据类型的话，显然一个字节就不够用了。 所以Java虚拟机规范中，这种特性”Not Orthogonal”,并非每种数据类型和每一种操作都有对应的指令。</p><p>大部分的指令都没有支持byte、char、short,没有任何指令支持boolean类型。编译器在编译期或者运行期将byte和short类型的数据带符号扩展为相应的int类型数据，将boolean和char类型数据零位扩展为相应的int类型数据。与之类似的，在处理byte、char、short和boolean类型的数组时，也会转换成对应的int类型的字节码指令来处理。因此，大多数对于byte、char、short和boolean类型数据的操作，实际上都是使用相应的int类型作为运算类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>a = a + b; <span class="hljs-comment">// 编译错误，可以发现 byte + byte 的结果不是 byte 类型，这是因为在计算的时候是按照 int 来计算的。</span><br></code></pre></td></tr></table></figure><h2 id="10-MyBatis相关面试题"><a href="#10-MyBatis相关面试题" class="headerlink" title="10. MyBatis相关面试题"></a><strong>10. MyBatis相关面试题</strong></h2><h3 id="10-1-MyBatis的一二级缓存"><a href="#10-1-MyBatis的一二级缓存" class="headerlink" title="10.1 MyBatis的一二级缓存"></a>10.1 MyBatis的一二级缓存</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&mid=2247496101&idx=1&sn=8d32c975eb41744903bb6331a500c28d&source=41#wechat_redirect">MyBatis一级缓存详解 (qq.com)</a></p><p>对于MyBatis的一级缓存中，当MyBatis在执行一次SQL查询或者SQL更新之后，这条SQL语句并不会消失，而是会被MyBatis给缓存起来，再次执行相同SQL语句的时候，就会直接从缓存中进行提取。</p><p><strong>一级缓存又被称为SqlSession级别的缓存</strong></p><p>SqlSession是SqlSessionFactory会话工厂创建出来的一个会话的对象，这个SqlSession对象用于执行具体的SQL语句并返回给用户请求的结果。</p><p><img src="image-20220315170722539.png" alt="image-20220315170722539"></p><p>在每次更新操作的时候，MyBatis都会将此SqlSession中的一级缓存给清空掉。对于MyBatis来说，它每次访问数据库都会创建一个SqlSession，就算这两次访问都在同一个方法中。但是如果该方法是存在事务的，那么在同一个事务中，其实都是同一个SqlSession。</p><p><a href="https://blog.csdn.net/qq_16159433/article/details/121128555?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-121128555.pc_agg_new_rank&utm_term=mybatisplus+%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82+%E9%83%BD%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BASqlSession&spm=1000.2123.3001.4430">(34条消息) 同一个方法中，Mybatis多次请求数据库，是否要创建多个SqlSession会话？_Abstracted的博客-CSDN博客</a></p><p><strong>如果多个SqlSession需要共享缓存，则需要开启二级缓存</strong>，开启之后，会使用CacheExecutor装饰Executor，进入一级缓存的查询流程前， 会先在CacheExecutor进行二级缓存的查询。</p><p>当二级缓存开启之后，同一个namespace的所有的操作语句，都影响着一个共同的cache。而且开启二级缓存的时候，<strong>要求返回的POJO必须是可序列化的</strong></p><p><img src="1515111-20190810211454258-1861395227.png" alt="img"></p><h3 id="10-2-和"><a href="#10-2-和" class="headerlink" title="10.2 #{}和${}"></a>10.2 #{}和${}</h3><p>前者是预编译处理，在处理的时候，会将sql中的#{}替换为？，然后调用PreparedStatement的set方法来赋值。</p><p>后者是字符串替换，在处理的时候，把括号里面的值替换成变量的值。</p><p>使用前者可以有效的防止SQL注入，提高系统安全性。</p><h2 id="11-计算机网络"><a href="#11-计算机网络" class="headerlink" title="11. 计算机网络"></a><strong>11. 计算机网络</strong></h2><blockquote><p>计算机五层结构</p></blockquote><ol><li><strong>应用层：</strong>提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会传给传输层。HTTP、DNS、SMTP、FTP</li><li><strong>传输层：</strong>为两个终端设备进程之间的通信提供通用的数据传输服务。TCP、UDP</li><li><strong>网络层：</strong>选择合适的网间路由和交换结点，确保数据及时传送，IP、ARP、ICMP</li><li><strong>数据链路层：</strong>将网络层交下来的IP数据报组成成帧，在两个相邻节点之间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制）</li><li><strong>物理层：</strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li></ol><h3 id="11-1-应用层协议"><a href="#11-1-应用层协议" class="headerlink" title="11.1 应用层协议"></a>11.1 应用层协议</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><ul><li>HTTP全称超文本传输协议，用来规范超文本（网络上的包括文本在内的各种各样的消息）的传输的。具体来说，主要是用来规范浏览器和服务器端的行为的。 HTTP是一种无状态的协议，也就是说，服务器不维护任何有关客户端过去所发请求的消息。默认端口是80。</li><li>HTTP优点：扩展性强、速度快、跨平台支持性好。</li><li>HTTP通信过程：首先服务器在80端口等待客户的请求；浏览器发起到服务器的TCP连接；服务器接受来自浏览器的TCP连接；浏览器和服务器交换HTTP消息；关闭TCP连接。</li></ul><blockquote><p>URL和URI是什么？</p></blockquote><p>URI是统一资源标识符，可以唯一标识一个资源。（身份证）</p><p>URL是统一资源定位符，提供该资源的路径。它是一种具体的URI。不仅可以用来标识一个资源，还指明了如何定位该资源。（家庭住址）</p><blockquote><p>HTTP报文首部</p></blockquote><p>对于请求报文来说，它的首部包含<strong>请求行以及其他首部字段</strong>。</p><p><img src="image-20220513201903002.png" alt="image-20220513201903002"></p><p>而响应报文，首部包含<strong>状态行和首部字段</strong>。</p><p><img src="image-20220513201934522.png" alt="image-20220513201934522"></p><p>常见字段：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">Host：github.noaharno.top <span class="hljs-comment">// 指定域名服务器</span><br>Content<span class="hljs-operator">-</span>Length：<span class="hljs-number">1000</span> <span class="hljs-comment">// 服务器在返回数据的时候，表明本次回应的数据长度</span><br>Connection：keey<span class="hljs-operator">-</span>alive <span class="hljs-comment">// 最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用</span><br>Content<span class="hljs-operator">-</span><span class="hljs-keyword">type</span>：text<span class="hljs-operator">/</span>html;charset<span class="hljs-operator">=</span>utf<span class="hljs-number">-8</span> <span class="hljs-comment">// 服务器回应时告诉客户端，本次数据是什么格式</span><br>Accept：<span class="hljs-operator">*/*</span> <span class="hljs-comment">// 客户端请求的时候，声明自己可以接受哪些数据格式</span><br>Content<span class="hljs-operator">-</span>Encoding<span class="hljs-operator">:</span> gzip <span class="hljs-comment">// 表明数据的压缩方式，服务器返回的数据用了什么压缩格式</span><br>Accept<span class="hljs-operator">-</span>Encoding：gzip，deflate <span class="hljs-comment">// 客户端表明自己可以接受哪些压缩方法。</span><br></code></pre></td></tr></table></figure><blockquote><p>HTTP缺点</p></blockquote><ul><li>通信使用明文传输，内容可能被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法证明报文的完整性，可能已经遭到篡改</li></ul><blockquote><p>HTTP优点</p></blockquote><ul><li><strong>简单</strong></li></ul><p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><ul><li><strong>灵活和易于扩展</strong></li></ul><p>HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>。</p><p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层，HTTP&#x2F;3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p><ul><li><strong>应用广泛和跨平台</strong></li></ul><p>互联网发展至今，HTTP 的应用范围非常的广泛，同时天然具有<strong>跨平台</strong>的优越性。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS相当于在HTTP和TCP之间加了一层SSL&#x2F;TLS协议。也就是说，之前是HTTP直接和TCP进行通信，现在变成了HTTP先和SSL通信，然后再由SSL和TCP通信。</p><p>SSL是独立于HTTP的协议，其他的运行在应用层的协议也可以配合SSL使用。</p><ul><li>HTTPS是HTTP的加强安全版本，具有安全性的SSL加密传输协议。默认端口号是443.</li><li>保密性好、信任度高（可认证用户和服务器，确保数据发送到正确的客户机和服务器）。</li><li>建立一个信息安全通道来保证数据传输的安全；另一种就是确认网站的真实性。</li><li>相对于HTTP来说，HTTPS的技术门槛较高，并且CA证书的申请大部分都需要一定的资金。对接HTTPS也需要额外的技术支持；对于大部分网站来说，并不关系数据的安全性和保密性；HTTPS加重了服务端的负担，相比HTTP需要更多的资源来支撑，同时降低了用户的访问速度；对于用户来说，HTTP和HTTPS的差异感知不大。</li></ul><p>相对于HTTP的缺点来说，HTTPS使用混合加密的方式解决明文传输的风险；使用摘要算法解决数据的完整性；使用数字证书解决了冒充的风险。</p><p><strong>对称加密 + 非对称加密 + 摘要算法 + 数字签名实现可靠性</strong></p><blockquote><p>HTTPS的加密方式</p></blockquote><p><strong>对称加密</strong>指的是加密和解密用的是同一把钥匙。但是注意的是，在加密之前肯定得将密钥发送给对方才能将加密的消息进行解密，可是在互联网上转发密钥的时候，如果通信被窃听了，那么密钥就可能会造成泄露，失去了加密的意义，是不安全的。</p><p><strong>非对称加密</strong>指的是用两把钥匙，一把叫做私钥，一把叫做公钥。公钥可以随便发布，而私钥只能够自己保存。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息之后，使用自己的私钥进行解密，保障安全性，但是相对于对称加密来说效率降低。如果是指根据密文和公钥，想要恢复信息原文是非常困难的。</p><p><strong>HTTPS是采用对称加密和非对称加密混合加密的。</strong>使用非对称加密算法将对称加密算法的密钥进行安全交换，然后接下来的传输就使用对称加密进行传输。</p><blockquote><p>数字证书</p></blockquote><p>遗憾的就是<strong>非对称加密算法还是存在一些问题的</strong>，那就是<strong>无法保证公钥本身就是货真价实的公钥</strong>。如何证明收到的公钥就是原本预想的那台服务器发行的公开密钥？或许在公钥传输途中，真正的公钥就已经被攻击者替换了。</p><p>比如A生成了自己的公钥和私钥，并想和B交换对称加密的公钥。此时A发送非对称加密的公钥的时候，被M给拦截了，并且自己生成一个对称加密的公钥，并使用A发来的公钥加密后发给A，此时A解密之后就认为这个对称加密的公钥来自于B，以后就使用这个公钥进行加密传输数据，这就导致消息在M看来就是明文的了。</p><p>因此就需要数字证书了。</p><p>当浏览器向服务器发送HTTPS请求的时候，一定要先获取目标服务器的证书，并根据证书中的信息校验证书的合法性。一旦客户端检测到证书非法就发生错误。客户端获取到服务器的证书之后，证书里面包含服务器的公钥信息，客户端就可以放心信任证书上的公钥就是目标服务器的公钥。</p><p>数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它识别对方的身份，避免身份被篡改冒充。</p><p>数字签名被数字证书包含：公钥和个人等信息经过Hash摘要算法加密形成消息摘要。将消息摘要拿到拥有公信力的认证中心比如CA，用它的私钥对消息摘要加密形成数字签名。</p><blockquote><p>摘要算法</p></blockquote><p>摘要算法用来校验数据的<strong>完整性</strong>，解决了篡改的风险。又称哈希算法，只能加密不能解密，常见的摘要算法有：MD5、SHA-1、SHA-256、SHA-512。</p><p>客户端在发送明文之前会通过摘要算法计算出明文的指纹，发送的时候将指纹和明文一同加密成密文后再发送给服务器。服务器收到密文并解密之后，用相同的摘要算法计算发送过来的明文，并通过比较客户端一同发过来的指纹，如果相同代表数据是完整的。</p><blockquote><p>HTTPS工作原理、具体加密传输流程</p></blockquote><p><img src="4E0CD01326A8E2DA4531747D0DD3B192" alt="img"></p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><table><thead><tr><th align="left">区别</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td align="left">协议</td><td></td><td></td></tr><tr><td align="left">端口</td><td>80</td><td>443</td></tr><tr><td align="left">资源消耗</td><td>较少</td><td>由于加密解密处理，会消耗更多的CPU和内存资源</td></tr><tr><td align="left">开销</td><td>无需证书</td><td>需要申请到CA申请证书</td></tr><tr><td align="left">加密机制</td><td>无</td><td>共享密钥加密和公开密钥加密并用的混合加密机制</td></tr><tr><td align="left">安全性</td><td>弱</td><td>由于加密机制，安全性强</td></tr></tbody></table><ol><li>首先HTTP是超文本传输协议，运行在TCP之上，明文传输，<strong>客户端与服务器端无法校验对方的身份</strong>；HTTPS是具有安全性的SSL加密传输协议，运行在SSL之上，而SSL运行在TCP之上，<strong>是添加了加密和认证机制的HTTP</strong>。</li><li>HTTP默认是80端口，而HTTPS是443</li><li>HTTP的资源消耗相对于HTTPS来说较少，因为HTTPS的加解密处理，会消耗更多的CPU和内存资源。</li><li>HTTPS还得需要向CA申请证书，大部分都需要花费一定的金额</li><li>HTTP连接是无状态的，没有加密解密机制；而HTTPS使用<strong>共享密钥加密和公开密钥加密并用的混合加密机制，安全性较强</strong></li></ol><h3 id="HTTP版本对比"><a href="#HTTP版本对比" class="headerlink" title="HTTP版本对比"></a>HTTP版本对比</h3><p><strong>HTTP1.1相比HTTP1.0支持的特性：</strong></p><ul><li><strong>连接方式</strong>：HTTP1.0为短连接，HTTP1.1为长连接，注意长连接需要客户端和服务端都支持长连接。</li><li><strong>状态响应码：</strong>HTTP1.1中新加入了大量的状态码，比如100-在请求大量资源前的预热请求，206–范围请求的标识码。</li><li><strong>缓存处理：</strong>在HTTP1.1中引入了更多的缓存控制策略。</li><li><strong>带宽优化及网络连接的使用：</strong>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，但是服务器却将整个对象送了过来。而HTTP1.1在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码是206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>HOST头处理：</strong>HTTP1.1在请求头中加入了HOST字段。</li></ul><p><strong>HTTP2相比HTTP1.1支持的特性：</strong></p><ul><li><strong>新的二进制格式</strong>：HTTP1.1基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。 </li><li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免 HTTP1.1 出现的”队头堵塞”问题。 </li><li><strong>头部压缩</strong>，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。并且HTTP2.0在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。比如请求a发送了所有的头信息字段，请求b则只需要发送差异数据，这样可以减少冗余数据，降低开销。 </li><li><strong>服务端推送</strong>：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><table><thead><tr><th>响应码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完成</td></tr><tr><td>3XX</td><td>Redirection重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error 客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error 服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>200 OK</strong>：表示从客户端发来的请求在服务端被正常处理了。</p><p><strong>204 No Content</strong>：服务器接受的请求已经成功处理，但是返回的响应报文中不包含实体的主体部分，没有资源可以返回。另外也不允许返回任何实体的主体。比如当从浏览器发出请求处理后，返回204，浏览器显示的页面不发生更新。一般在只需要从客户端往服务端发消息，而对客户端不需要发送新消息内容的情况下使用。</p><p><strong>206 Partial Content</strong>：客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p><p><strong>301 Moved Permanently</strong>：永久性重定向。</p><p><strong>302 Found</strong>：临时性重定向。请求的资源已经被分配了新的URI，希望用户本次能够使用新的URI访问。</p><p><strong>400 Bad Request</strong>：请求报文中存在语法错误，需要修改请求的内容之后再次发送请求。</p><p><strong>403 Forbidden</strong>：对请求资源的访问被服务器拒绝了。</p><p><strong>404 Not Found</strong>：服务器上无法找到请求的资源。</p><p><strong>500 Internal Server Error</strong>：服务端在执行请求的时候出现了错误。</p><p><strong>502 Bad Gateway</strong>：通常是服务器作为网关或代理的时候返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p><p><strong>503 Service Unavailable</strong>：服务器暂时处于超负载或正在进行停机维护，无法处理请求。</p><h2 id="11-2-传输层协议"><a href="#11-2-传输层协议" class="headerlink" title="11.2 传输层协议"></a>11.2 传输层协议</h2><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>IP层是不可靠的，它不保证网络包的按序交付、不保证网络包中数据的完整性、不保证网络包的可靠性， 因此就需要由传输层的TCP协议来进行负责。因为TCP能保证接收端接收到的网络包是无损坏、无间隔、非冗余和按序的。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><blockquote><p>三次握手的过程</p></blockquote><p><img src="TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>一开始的时候客户端和服务端都是处于CLOSE状态，然后服务器主动监听某个端口，处于LISTEN状态。</p><p>客户端随机初始化自己的序列号之后，将其设置在TCP的首部的序列号字段中，然后将SYN标志位设置为1。当客户端发送SYN包之后，自己变成SYN-SENT状态。</p><p>服务端收到SYN包之后，它也会去随机初始化自己的序列号，并且将其设置在TCP首部中，然后设置确认应答字段为客户端的序列号+ 1，同时将ACK和SYN标志位都设置为1。最后将该TCP报文发送给客户端，此时服务端处于SYN-RCVD状态。</p><p>客户端收到服务端传来的SYN + ACK报文之后，回应服务端一个ACK包，里面包含了确认应答字段的值为服务端的序列号 + 1。然后客户端的状态为ESTABLISHED，当服务端收到ACK包之后，状态也变为ESTABLISHED。</p><p><strong>只有第三次握手是可以携带数据的，前两次都不能</strong></p><blockquote><p>建立连接可以两次握手吗？为什么？</p></blockquote><ul><li>不可以</li><li><strong>避免历史连接</strong>：就比如第一次客户端发送序列号90的SYN给服务端，但是由于网络的原因迟迟未到达。之后客户端重新发送一个序列号为100的SYN给服务端（不是超时重传），在他到达之前，之前延期的那个90的SYN包到达服务端了，如果只是两次握手，那么此时服务端就会进入ESTABLISHED状态，建立好了连接。</li><li><strong>减少开销</strong>：如果只有两次握手，并且客户端的SYN由于网络原因迟迟未到达，就会导致客户端迟迟未收到ACK，于是就会超时重传。由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，就会每收到一个SYN就只能先主动建立一个连接。造成不必要的资源浪费。</li><li><strong>同步双方初始序列号</strong>：序列号对于可靠传输而言非常重要。如果只是两次握手，那么服务端就无法知道客户端到底有没有同步服务端的初始序列号。</li></ul><blockquote><p>初始序列号的生成过程</p></blockquote><p>ISN &#x3D; M + F。基本不可能生成一样的初始化序列号。</p><p>M：一个计时器，该计时器每隔4微秒 + 1。</p><p>F：Hash算法，根据源IP、目的IP、源端口、目的端口生成的一个随机数值。</p><p><strong>正是有了随机的初始序列号，才能够避免历史报文被下一个相同的四元组的连接接受。</strong></p><p>假如发送端和接收端的初始序列号都是从0开始，那么当两者建立好TCP连接之后，发送端向接收端发送的数据由于网络延时，未能及时到达接收端。并且此时两者由于某些原因断开连接进行重启了，然后重新建立连接。待到他们建立好连接之后，那个延迟的数据终于到达接收端了，此时这个新的TCP连接就会收到历史报文数据。</p><blockquote><p>如果已经建立了连接，但是客户端出现故障怎么办？</p></blockquote><p>如果服务端发送了数据包给客户端，由于客户端的连接已经关闭了，此时客户的内核就会回复RST报文来释放连接。</p><p>如果服务端一直没有发送数据给客户端，在超过一段时间之后，就会触发<strong>TCP保活机制</strong></p><p>服务端每收到一次客户端的请求之后都会重新复位一个计时器，通常是两个小时。如果两个小时之后还没有收到客户端的任何数据，server就会发送一个探测报文段，每隔75秒发送一次。如果发送了十次都没反应，就会认为客户端出现了故障， 然后就会关闭连接。</p><blockquote><p>如果已经建立了连接，客户端掉线再上线的时候发起了SYN握手，服务器怎么应对</p></blockquote><p>首先服务端IP地址、服务端端口号、客户端IP地址都不会变。</p><p><strong>如果客户端端口号改变</strong>：</p><p>服务端收到客户端发来的SYN之后，会认为是新的连接请求建立，就会通过三次握手来建立新的连接。那么旧的处于ESTABLISHED状态的服务端连接就会按照上一问的方式处理。</p><p><strong>如果客户端端口号不变</strong>：</p><p>处于ESTABLISHED状态的服务端收到客户端的SYN报文（此时Sequence Number和之前的不一样），会回复一个携带了正确序列号和确认号的ACK报文，被称为Challenge ACK。</p><p>客户端收到这个ACK之后，发现序列号不是自己期望收到的，于是就会回复RST报文，服务端收到之后会释放掉该连接。</p><blockquote><p>第一次SYN丢失怎么办？</p></blockquote><p>客户端迟迟收不到服务端发来的SYN-ACK报文，就会触发超时重传机制。</p><p>一般来说，第一次超时重传是在1秒后，第二次2秒，第三次4秒，第四次8秒，第五次16秒。<strong>每次超时时间会是上一次的2倍</strong></p><p>当第五次超时重传之后，会继续等待32秒，如果服务端仍然没有收到SYN-ACK，那么客户端将不再发送SYN包，而是断开TCP连接。</p><blockquote><p>第二次握手丢失怎么办？</p></blockquote><p>首先对于客户端来说，它没有收到SYN-ACK报文，客户端触发超时重传机制，重传SYN报文。</p><p>其次由于第二次握手丢失，导致服务端收不到客户端传来的ACK，也会触发服务端的超时重传，重传SYN-ACK报文。</p><blockquote><p>第三次ACK丢失怎么办？</p></blockquote><p>对于服务端来说，它会根据TCP的超时重传机制，等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</p><blockquote><p>SYN泛洪</p></blockquote><p>攻击者短时间伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就会进入SYN_RCVD状态，但是服务端发送的SYN-ACK报文无法得到IP主机的ACK应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端无法正常为用户提供服务。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><blockquote><p>四次回收的过程</p></blockquote><p><img src="aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy" alt="IMG/面试话术.asserts/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy"></p><ol><li>第一次挥手：客户端发送一个FIN，并发送一个序列号，用来关闭客户端到服务端的数据连接</li><li>第二次挥手：服务端收到这个FIN，并且发回一个ACK，确认需要为收到的序列号加1，此时服务端进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但是仍然可以接受来此服务端的数据</li><li>第三次挥手：服务端发送一个FIN，并且发送一个序列号给客户端，此时服务端进入LAST_ACK状态。第三次挥手的作用是服务端关闭与客户端的连接。</li><li>第四次挥手：客户端收到服务端发送的FIN之后，进入TIME_WAIT状态，将ACK置为1，并且将确认序号设置为收到序号加1；服务端收到并确认序列号之后，变成CLOSE状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSE状态。完成四次挥手。</li></ol><blockquote><p>白话文理解四次挥手</p></blockquote><p>首先四次挥手是因为要确定数据全部传输完了。</p><ol><li>可以将四次挥手理解为A和B打电话。</li><li>A想要结束这次会话，就会告诉B，我要挂电话了。</li><li>B听到后，就说好的我知道了。但是此时B还有可能有话想和A说。</li><li>当B话说完之后，就对A说：我说完了，我要挂电话了</li><li>A听到后，就说：好的，我知道你要挂电话了。</li><li>四次挥手完毕</li></ol><blockquote><p>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</p></blockquote><p><strong>产生原因：</strong></p><p>服务端收到客户端断开连接的请求之后，可能会还有一部分数据没有发完，这时先回复ACK表示服务端接受到了客户端发来的断开连接请求。等待数据发送完之后再发送FIN，表示要断开服务端与客户端的数据传送。</p><p><strong>CLOSE_WAIT产生太多的原因：</strong></p><p>CLOSE_WAIT按照正常的操作应该是很短的时间，接收到客户端传来的FIN包并且回复客户端ACK之后，会继续发送FIN包告知客户端关闭连接，之后就会迁移到LAST_ACK状态。</p><p>但是close_wait过多只能说明没有迁移到last_ack状态，也就是服务端是否发送FIN包，只有发送了FIN之后才会迁移到last_ack状态，所以<strong>问题定位在是否发送FIN包</strong>。</p><p>FIN包的底层的实现其实就是调用socket中的close方法，这里的问题出在没有执行close方法，说明服务端socket忙于读写。 </p><p><strong>CLOSE_WAIT太多解决办法：</strong></p><ol><li>使用完socket就调用close方法。</li><li>socket读控制，当读取的长度为0时（读到结尾），立即close；</li><li>如果read返回-1，出现错误，检查error返回码，有三种情况：INTR（被中断，可以继续读取），WOULDBLOCK（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），AGAIN（表示现在没有数据稍后重新读取）。如果不是AGAIN，立即close</li><li>可以设置TCP的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接</li></ol><blockquote><p>客户端TIME_WAIT状态的意义？（为什么要等待2MSL）</p></blockquote><p><a href="https://blog.csdn.net/weixin_43851782/article/details/116925584">(34条消息) TCP通信过程中time_wait和close_wait产生过多的原因和解决方法_赵雨诺的博客-CSDN博客_tcp time wait 过多</a></p><ul><li><strong>保证TCP协议的全双工连接能够可靠关闭</strong></li></ul><p>在第四次挥手的时候，客户端发给服务端的ACK可能丢失，TIME_WAIT就是用来重发可能丢失的ACK报文。如果server没有收到ACK，就会重发FIN，如果client在2MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL。防止server没有收到ACK而不断重发FIN。MSL是指一个片段在网络中的最大存活时间。2MSL就是一个发送和一个回复所需要的最大时间。如果直到2MSL，client都没有再次收到FIN，那么client推断ACK已经被成功接受，则结束TCP连接。</p><ul><li><strong>保证这次连接的重复数据段从网络中消失</strong></li></ul><p>客户端在发送完最后一个ACK报文段之后，再经过2MSL，就可以使本次连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p><p><strong>拓展：TIME_WAIT过多产生原因：</strong></p><p>如果短时间内进行大量的短连接，就可能会导致客户端所在的操作系统的socket端口和文件描述符被用尽，系统无法再发起新的连接。</p><p><strong>扩展；TIME_WAIT过多解决办法：</strong></p><ol><li>修改为长连接，但是长连接太多也会导致服务器性能问题，并且安全性较差。</li><li>增大可用端口范围，但是只能缓解问题</li><li>客户端打开tcp_tw_recycle和tcp_timestamps选项：也就是销毁TIME_WAIT，当开启这个配置之后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。</li></ol><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。如果我们使用通过IP电话进行通信：如果使用TCP协议，数据在传输过程中如果丢失会被重发，但是这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有数据丢失也只会影响某一小部分的通话。</p><p>即使是出现网络拥堵，UDP也无法进行流量控制等避免网络拥塞的行为。而且传输途中即使出现了丢包，UDP也不会负责重发。甚至当出现包的到达顺序乱掉的时候也没有纠正功能。</p><blockquote><p>UDP的用途：</p></blockquote><ul><li>包总量较少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信（即时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><blockquote><p>TCP和UDP比较</p></blockquote><p>TCP首部比较长，并且不是一定固定的。而UDP首部固定8个字节。</p><p>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片；UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p><p><img src="B67D1C5538D193ED0D71FE132439138E.png" alt="img"></p><blockquote><p>为什么说TCP是面向字节流的，而UDP是面向报文的？</p></blockquote><p><strong>UDP是面向报文的</strong>：发送方的UDP对应用层交下来的报文，不合并不拆分，只是在其上面加上首部之后就交给了下面的网络层，也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对于接收方，接收到之后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小，如果报文太长就会导致IP层需要分片，降低效率。</p><p><strong>TCP是面向字节流的</strong>：TCP将上面交下来的数据看成是无结构的字节流来发送，发送方TCP会将数据放入缓存区，等到可以发送的时候才发送，不能发送就等着。如果应用层传送的数据块太长，TCP就可以将它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p><h3 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h3><blockquote><p>校验和</p></blockquote><p> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p><p>TCP的校验和覆盖TCP首部和TCP数据，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。</p><p>TCP的校验和是必须的，UDP的校验和是可选的。</p><p>TCP和UDP一样，在计算校验和的时候要使用16位的伪首部。</p><blockquote><p>序列号和确认应答提高可靠性</p></blockquote><p>当发送端的数据到达接收端的主机之后，接收端主机会返回一个已收到消息的通知，这个消息就叫做确认应答（ACK）。比如发送端发送了1-1000的数据给接收端，接收端就会发出一个ACK 1001，表示下一次我想收到的数据为1001。</p><p>如果一段时间之后，发送端都没有收到ACK，那么它就会进行重发。当然发送端没收到ACK并不一定是接收端没收到数据，也有可能是接收端发送的ACK在途中丢失了，没有到达接收端。这种情况同样发送端因为没有收到ACK而认为数据没有到达目的地从而重发数据。</p><p>序列号SYN的初始值是在建立连接的时候随机生成的，而后面SYN会累加它所发送过去的数据的字节数。然后接收端查询接受数据TCP首部中的序列号和数据的长度，将自己下一步应该接受的序列号作为ACK返送回去。通过SYN和ACK，TCP可以实现可靠传输。</p><p><strong>序列号对于可靠传输非常重要：</strong></p><ol><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ol><p><strong>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</strong> TCP通常将不按序到达的数据先临时放在接收窗口中，等到字节流中缺少的字节收到之后，再按序交付上层的应用进程。</p><p><strong>TCP 的接收端会丢弃重复的数据。</strong> </p><blockquote><p>超时重传</p></blockquote><p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p>如果超时重传的数据再次超时的时候，又得再次需要进行重传，这次的超时间隔是上一次的<strong>两倍</strong>。</p><p>超时重传时间RTO的计算其实还是比较复杂的，如果较大就可能导致丢了很久才重发，效率低下。如果较小就可能导致并没有丢失就重发了，增加网络拥塞。</p><p>规则：RTO的值应该略大于报文往返RTT的值，但是RTT的值其实是不确定的，是动态变化的。因此需要通过采样RTT的时间计算出一个平滑的RTT。除了采样RTT，还得采用RTT的波动范围，避免如果RTT有一个很大的波动很难被发现。</p><blockquote><p>TCP以段为单位发送数据</p></blockquote><p>TCP在传输大量数据的时候，是以<strong>MSS（Maximum Segment Size）</strong>的大小将数据进行分割发送，重发的时候也是以MSS为单位。MSS正好是IP中不会被分片处理的最大数据长度。</p><p>MSS是在三次握手的时候由两端主机之间被计算出来的。两端的主机在发出建立连接的请求的时候，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小（此时TCP首部不再是20字节了，而是4字节的整数倍）。然后会在两者之间选出一个较小的值投入使用。 </p><p>于此同时，在IP层如果数据大小超过了<strong>MTU（除去IP头部和TCP头部之后，一个网络包能容纳的TCP数据的最大长度）</strong>，同样也会进行分片，那<strong>既然IP层也会分片，为什么还要在TCP层进行分段？</strong></p><p>如果有一份数据比较大，并且在TCP层不分段，如果这份数据在发送过程中丢包，TCP就会发生重传，那么这一份大数据都会被重传（虽然IP层会将这份数据切割成MTU长度的多个小包，但是在TCP层来说，它重传的仍然是那一大份数据）。</p><p>而如果数据在TCP层进行分段，那么IP层就不会再进行分段了。此时在传输途中出现丢包，那么TCP也只会重传那一小部分的MSS段，效率比TCP不分段时更高。</p><blockquote><p>滑动窗口</p></blockquote><p>如果TCP每发送一个数据，都要进行一次确认应答，然后等到上一个数据包收到了确认应答了，才去发送下一个，这会造成<strong>效率低下</strong>。因此TCP就引入了滑动窗口，<strong>窗口的大小就是无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>滑动窗口实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到ACK，此时数据就可以从缓冲区中清除。</p><p>假如窗口大小为3个TCP段，那么发送端就可以连发三个TCP数据段，而且途中有ACK丢失，<strong>可以通过下一个ACK进行确认</strong>。只要发送端收到了ACK num，那么num之前的所有数据接收方都已经收到了。<strong>这就叫累计确认或累计应答</strong></p><p> 对于滑动窗口而言，可以使用三个指针来描述窗口的状态。</p><p>小于P1的表示已经发送并且收到确认的部分。大于P3的表示不允许发送的部分；窗口的大小就是P3-P1；P2-P1的大小表示已经发送但是未收到确认的字节数。P3-P2代表当前允许发送但是还尚未发送的字节数量。</p><p>虽然发送方的发送窗口是根据接收方的接受窗口设置的，但是<strong>在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</strong>因为网络传送窗口值需要经历一定的时间滞后，并且这个时间还不是确定的；同时发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。</p><p><strong>TCP强烈不赞成窗口的前沿向后收缩</strong>，也就是对方通知的窗口缩小了，因为有可能发送方再收到这个通知之前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，就会产生错误。</p><blockquote><p>流量控制</p></blockquote><p>一般来说，我们都希望数据传输的更快一些。但是如果发送方把数据发送的过快，就可能导致接收方来不及接受，从而造成数据的丢失。而所谓流量控制，其实就是<strong>让发送端的发送速率不要太快，要让接收方来得及接受</strong></p><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p><p>当接收端的接受窗口调整为0，对发送端进行流量控制，此时发送端由于自己的发送窗口被调控为0了，就无法再发送数据了，它就会一直等待接收端发送的非零窗口的通知。但是此时如果接收端又有了一些存储空间，将接收窗口调整为300，并通告发送端，然后等待发送端发送数据过来，但是不巧的是，该调整通知丢失了！此时接收端一直等待发送端发来数据，而发送端一直等待接收端的非零窗口通知，就造成了<strong>死锁</strong>。</p><p><strong>TCP使用持续计时器 + 零窗口探测报文进行解决</strong>。所谓的持续计时器，就是等到发送端接收到零窗口通知时，就会启动该计时器，当持续计时器超时的时候，会发送零窗口探测报文，携带一字节数据。等到接收端收到了该零窗口探测报文段，就对零窗口探测报文进行确认，并通告自己的接收窗口。如果不为零，那么死锁的局面就可以被打破了；如果还是为零，那么就重置持续计时器，等待下一次超时或者等待接收端发布窗口通告。</p><p><strong>TCP规定，即使接受窗口为0，也必须接受零窗口探测报文段、确认报文段、携带有紧急数据的报文段</strong></p><p>如果零窗口探测报文段丢失了，注意，<strong>零窗口探测报文段同样也有重传计时器，当零窗口探测报文段超时了，也会进行重传</strong>。</p><blockquote><p>拥塞控制</p></blockquote><p>当网络拥塞时，减少数据的发送。 </p><p><strong>为什么有了流量控制，还得有拥塞控制？</strong></p><p>流量控制是避免发送端的数据填满接收端的缓存，避免接收端处理不过来导致数据包丢失。而拥塞控制就是避免发送方的数据填满整个网络。因为当网络出现拥堵的时候，如果继续发送大量的数据包，可能会导致数据包时延、丢失等情况，然后TCP就会进行重传，然后就更加加剧了网络的拥堵，造成恶性循环。因此就需要拥塞控制。</p><p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。发送双方都有一个拥塞窗口（cwnd），它会根据网络的拥塞程度动态变化，发送窗口取的是拥塞窗口和接收窗口的最小值。  </p><p>维护一个慢开始门限<code>ssthresh</code>状态：</p><ul><li><p>当cwnd &lt; ssthresh时，使用慢开始算法</p></li><li><p>当cwnd &gt; ssthresh时，停止使用慢开始算法，转而使用拥塞避免算法</p></li><li><p>当cwnd &#x3D; ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</p></li></ul><ol><li><p><strong>慢开始</strong>：最开始发送方的拥塞窗口为1，由小到大递增。并假设慢开始门限ssthresh为16，每经过一个传输轮次，拥塞窗口cwnd加倍（乘2）（具体解释：一开始cwnd为1，TCP只能发送0号报文段，然后cwnd变成2；接着TCP就可以发送1-2号报文段了，之后因为发送了2个，cwnd就变成了2 + 2 &#x3D; 4；下一次就可以发送3-6共四个报文段了，然后cwnd就会变成4 + 4 &#x3D; 8；这就相当于翻倍）。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过长。  </p></li><li><p><strong>拥塞避免</strong>：当cwnd超过慢开始门限，每经过一个往返时间RTT，cwnd就增长1（举例中，ssthresh为16，因此可以发送15-30的号数据报文段，当发送端收到了15-30号报文段的ACK之后，就可以将cwnd的值 + 1，变成17；下一轮就可以发送31-47号数据报文段，共17个。）。在慢开始和拥塞避免过程中，一旦发现<strong>网络拥塞（发送的数据报文段出现了丢失，超时重传计时器超时之后，进行重传）</strong>，就把慢开始门限设置为当前值的一半，并且重新设置cwnd为1，重新慢启动。  </p><p>拥塞避免并不是说完全能够避免拥塞，而是指的是在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络不容易出现拥塞。</p></li><li><p><strong>快重传</strong>：接收方每收到一个失序的报文段后就立即发出重复确认，而不是等超时重传计时器超时再重传，发送方只要收到3个连续的重复确认就立即重传。 因为可能个别报文段再网络中丢失，但是实际上网络并没有发送拥塞。这可能导致发送方误以为网络发生拥塞，就会将cwnd设置为1，并错误启动了慢重传算法，降低传输效率。</p><p><img src="image-20220512163334886.png" alt="image-20220512163334886"></p></li><li><p><strong>快恢复</strong>：当发送方连续收到三个重复确认，就将慢开始门限减半，将当前的窗口设置为慢开始门限，并采用拥塞避免算法。（采用快恢复算法时，慢开始只在建立连接和网络超时时才使用）</p></li></ol><blockquote><p>ARQ协议</p></blockquote><p>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 </p><p><strong>ARQ就是自动重传请求，是OSI模型中数据链路层和传输层的错误纠正协议之一</strong>。它通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包含停止等待ARQ协议和连续ARQ协议。</p><p><strong>停止等待ARQ协议：</strong></p><p>基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到ACK确认就说明没有发送成功，需要重新发送，直到收到确认之后才会再次发送下一个分组。</p><p>在该协议中，若接收方收到重复分组，就丢弃该分组，而且还要发送确认。</p><p>优点是简单，缺点是信道利用率低，等待时间长。</p><p><strong>连续ARQ协议：</strong></p><p>该协议可以提高信道利用率。发送方会维持一个发送窗口，凡是位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p>优点：信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。比如发送方发送了5条消息，但是只有第3条消息丢失了。接收方只能对前两条消息发送确认。而发送方无法知道后续三个分组的情况，只能把后面三个分组都重新传送一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。</p><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="image-20220512091825656.png" alt="image-20220512091825656"></p><p>TCP中并没有包长度和数据长度的字段，TCP数据的长度 &#x3D; IP总长度 - IP首部长度 - TCP首部长度。</p><ul><li><strong>序列号（Sequence Number）</strong></li></ul><p>字段长32位，指的是发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。序列号在建立连接的时候由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，然后再将每转发过去的字节数累加到初始值上表示数据的为欸之，此为，在建立连接和断开连接的时候发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p><ul><li><strong>确认应答号（Acknowledgment Number）</strong></li></ul><p>同样也是32位，指的是下一次应该收到的数据的序列号。发送端收到这个确认应答以后就可以认为在这个序列号以前的数据都已经被正常接受。</p><ul><li><strong>数据偏移（Data Offset）</strong></li></ul><p>表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，也可以将其看作是TCP首部的长度，该字段长4位，<strong>单位为4字节</strong>。如果不包含选项字段，那么TCP首部的长度为20字节，因此数据偏移字段的值设置为5。</p><ul><li><strong>保留（Reserved）</strong></li></ul><p>主要是为了以后扩展使用，一般设置为0，但即使收到的包在该字段不为0，此包也不会丢弃。</p><ul><li><strong>控制位（Control Flag）</strong></li></ul><p><img src="image-20220512093737773.png" alt="image-20220512093737773"></p><blockquote><p>ACK（Acknowledgement Flag）</p></blockquote><p>该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</p><blockquote><p>RST（Reset Flag）标志位</p></blockquote><p>RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的，<strong>为1的时候表示TCP连接中出现异常必须强制断开连接</strong>。发送RST包关闭连接时，不必等缓冲区的包都发出去（不像FIN包），直接就丢弃缓冲区的包发送RST包。而接收端收到RST包之后，也不必发送个ACK包来确认。</p><p>TCP处理程序会在自己认为的异常时刻发送RST包。</p><ol><li>A向B发起连接，但B之上并未监听相应的端口，因此无法进行通信，这时B操作系统上的TCP处理程序会发RST包。</li><li>AB正常建立连接，正在通讯时，A向B发送了FIN包要求关闭连接，B发送ACK之后网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了之后，B又开始发送数据包，A收到之后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到之后会出现connect reset by peer错误。</li></ol><blockquote><p>SYN（Synchronize Flag）</p></blockquote><p>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定</p><blockquote><p>FIN（Fin Flag）</p></blockquote><p>该标志位为1的时候，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主 机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连 接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据 都因已成功发送而被自动删除之后再发。</p><ul><li><strong>窗口大小（Window Size）</strong></li></ul><p>该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字 节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p><ul><li><strong>校验和（Checksum）</strong></li></ul><p>和UDP类似，<strong>区别在于TCP的校验和无法关闭</strong></p><p>它在计算的时候同样也会使用TCP伪首部，只是协议号为6，表示是TCP协议。同时它计算的时候使用的是<strong>补码</strong>。</p><p>一旦在数据包的发送途中的某一个路由器发生故障，经过此路由器的包、协议首部或数据就极有可能被破坏。而TCP或UDP能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p><ul><li><strong>紧急指针（Urgent Pointer）</strong></li></ul><p>字段长16位，只有在URG控制位为1时有效。该字段的数值表示本报文段中紧急数据的指针。正确 来讲，从数据部分的首位到紧急指针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数据 的末尾在报文段中的位置。</p><ul><li><strong>选项（Options）</strong></li></ul><p>由于数据偏移的影响，长度最大为40字节。用于提高TCP传输性能。</p><p>比如MSS选项用于在建立连接的时候决定最大段长度的情况。</p><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><img src="image-20220512084529994.png" alt="image-20220512084529994"></p><ul><li><strong>源端口号</strong>：表示发送端的端口号，字段长16位。当然有时候可能不会设置源端口号，没有源端口号的时候该字段的值设置为0，可用于不需要返回的通信中。（只针对某个主机或应用，亦或者针对某个组织，只单方面发送更新消息，不需要接收端返回任何确认或应答）</li><li><strong>目的端口号</strong>：接收端端口，16位</li><li><strong>包长度</strong>：保存的是UDP首部的长度和数据部分的长度之和。</li><li><strong>校验和</strong>：</li></ul><p>为了提供可靠的UDP首部和数据而设计。</p><p>UPD计算校验和的方法和IP数据报首部校验和的方法相似，但是IP数据报校验和只会校验IP数据报的首部，而UDP的校验和是将首部和数据部分一起都校验。</p><p>在计算校验和的时候，UDP会在UDP数据报之前添加12个字节的伪首部，<strong>伪首部既不向下传送也不向上递交，仅仅只是为了计算校验和</strong>；</p><p><img src="image-20220512090742156.png" alt="image-20220512090742156"></p><p>其中17表示协议号，表示这是UDP协议。0是数据填充，将其填充至12字节。</p><p>在计算校验和的时候，会先将校验和字段全部填充0，然后将UDP伪首部、首部、数据每16位一组进行二进制<strong>反码</strong>求和，再将求和结果求<strong>反码</strong>，填入校验和字段。</p><p>当然UDP中也有可能不用校验和，此时校验和字段中填入0，这种情况下由于不进行校验和计算，协议处理的开销就会降低，但是如果UDP首部的端口号或者IP首部的IP地址遭到破坏，那么可能会对其他通信造成不好的影响。</p><blockquote><p>为什么需要伪首部？</p></blockquote><p>TCP&#x2F;IP中识别一个进行通信的应用需要5大要素，分别为源IP地址、目的IP地址、源端口号、目的端口号、协议号。而UDP首部只包含他们当中的两项。如果其他的三项被破坏了，就可能导致应该收包的应用收不到包，不应该收包的应用收到了包。</p><h3 id="TCP粘包拆包"><a href="#TCP粘包拆包" class="headerlink" title="TCP粘包拆包"></a>TCP粘包拆包</h3><p>我们都知道，TCP是面向字节流的，没有边界，但是操作系统在发送TCP数据的时候，会通过缓冲区来进行优化。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP就会将多个请求合并成同一个请求进行发送，这就是<strong>粘包</strong></p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP将其拆分成多次发送，每个大小最大MSS，这就是<strong>拆包</strong></p><p><strong>常见解决办法</strong>：</p><ol><li>发送端将每个包都封装成固定的长度，如果大小不够可以通过填充0达到指定长度。</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只要读取到足够长度的消息之后才算是读取到了一个完整的消息。</li><li>可以在数据包之间设置边界，比如添加特殊符号等，就可以通过边界将不同的数据包拆开。</li></ol><h2 id="11-3-网络层协议"><a href="#11-3-网络层协议" class="headerlink" title="11.3 网络层协议"></a>11.3 网络层协议</h2><h3 id="（TODO）IP"><a href="#（TODO）IP" class="headerlink" title="（TODO）IP"></a>（TODO）IP</h3><p>IP协议的作用就是将各种数据包传送给对方</p><h3 id="（TODO）ARP"><a href="#（TODO）ARP" class="headerlink" title="（TODO）ARP"></a>（TODO）ARP</h3><p>用于根据IP地址查询相应的以太网MAC地址。</p><h3 id="（TODO）ICMP"><a href="#（TODO）ICMP" class="headerlink" title="（TODO）ICMP"></a>（TODO）ICMP</h3><p>用于告知网络包在传输过程中产生的错误以及各种控制信息。</p><h3 id="11-4-GET和POST的区别"><a href="#11-4-GET和POST的区别" class="headerlink" title="11.4 GET和POST的区别"></a>11.4 GET和POST的区别</h3><ol><li>GET重点在于从服务器上获得资源，POST重点在于向服务器发送数据。</li><li>GET传输的数据量小，因为受URL长度影响，但是效率较高（HTTP协议本身没有对URL长度做出任何规定，只是浏览器规定）；POST可以传送大量数据，所以上传文件只能POST</li><li>GET是不安全的，因为GET请求发送的数据是在URL上，是可见的。而POST是放在请求头部的，是安全的，但是HTTP传输的内容都是明文，虽然浏览器地址栏看不到POST提交的body数据，但是可以通过抓包看见。</li></ol><h3 id="11-5-Cookie和Session"><a href="#11-5-Cookie和Session" class="headerlink" title="11.5 Cookie和Session"></a>11.5 Cookie和Session</h3><p>HTTP是一种无状态协议，也就是说HTTP协议本身不对请求和响应之间的通信状态进行保存。因此就可以使用Cookie和Session来解决这个问题。</p><ul><li><p>Cookie一般用来保存用户信息。它是web服务器保存在用户浏览器上的文件（key-value），可以包含用户相关的信息。客户端向服务器发起请求的时候就会提取浏览器中的用户信息由HTTP发送给服务器。</p><p>第一次客户端向浏览器发送请求，服务器生成Cookie之后通过响应报文中的名为Set-Cookie的首部字段，通知客户端保存Cookie。当下次客户端发送请求的时候，就会自动在请求报文中加入Cookie值并发送出去。</p></li><li><p>Session是浏览器向服务器会话过程中，服务器会分配的一块存储空间给SESSION。服务器默认为客户浏览器的cookie中设置sessionId，这个sessionId就和cookie对应，浏览器在向服务器请求过程中传输的cookie包含sessionId，服务器根据传输的cookie中的sessionId获取出会话中存储的信息，然后确认会话的身份信息。</p></li></ul><p><strong>区别：</strong></p><ol><li>cookie数据放在浏览器端，安全性较差；session放在服务器上，安全性相对较高，但是session的实现对客户端的cookie有依赖关系。</li><li>单个cookie保存的数据不能超过4K，session无此限制。</li><li>session会在一定时间内容保存在服务器上，当访问增多，会比较占用服务器的性能。</li></ol><h3 id="11-6-浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#11-6-浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="11.6 浏览器中输入url地址-&gt;&gt;显示主页的过程"></a>11.6 浏览器中输入url地址-&gt;&gt;显示主页的过程</h3><p>比如<a href="http://www.baidu.com/">www.baidu.com</a></p><ol><li><p><strong>浏览器通过DNS解析查找域名的IP地址（DNS查找过程：浏览器缓存、路由器缓存、DNS缓存）</strong></p><ol><li><p>先从浏览器缓存里面查找IP，因为浏览器会缓存DNS记录一段时间（维护一张域名和IP地址的对应表）</p></li><li><p>如果没有，搜索操作系统中的DNS缓存（维护一张域名和IP地址的对应表）</p></li><li><p>如果没找到，就会去hosts文件查找是否有该域名和对应IP</p></li><li><p>如果找不到，就得求助于本地DNS服务器（本地DNS服务器的IP地址一般由本地网络服务商如移动、电信提供，一般是通过DHCP自动分配，目前用的较多的是谷歌提供的公用DNS8.8.8.8和国内的114.114.114.114）</p><p>找到本地DNS之后，它也会去查询一遍自己的缓存。</p></li><li><p>如果都没有，从根域名服务器开始递归搜索，到根（.）、顶级（.com）、权威（xxx.com）域名服务器，再到自己的输入的域名服务器，直到找到IP</p><p>比如根域名服务器接收到本地DNS的解析请求之后，发现后缀是.com，就把负责.com的顶级域名服务器ip地址返回给本地DNS。</p><p>本地DNS再拿着返回的IP地址去找对应的顶级域名服务器，顶级域名服务器又将负责该域名的权威域名服务器IP返回去。</p><p>本地DNS又拿着IP去找对应的权威域名服务器，权威域名服务器最终将对应的主机IP返回给本地DNS，至此就完成了域名解析的过程。</p><p><img src="v2-f1e081e30e47c8c1f5af6b944d6eda3c_720w.jpg" alt="img"></p></li></ol></li><li><p><strong>浏览器和服务器建立TCP连接（三次握手）</strong></p><ol><li>应用层发起HTTP请求</li><li>传输层的TCP协议为传输报文提供可靠的字节流服务，也就是用了TCP三次握手</li><li>网络层把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。</li><li>链路层将数据发送到数据链路层传输。至此请求报文已经发出，客户端发送的请求的阶段结束。</li></ol></li><li><p><strong>浏览器向服务器发送一个HTTP请求</strong>（cookies会随着请求发送给服务器）</p><p>HTTP的请求包含三部分：请求方法URI协议&#x2F;版本、请求头、请求正文。</p><p>HTTP的响应包含三部分：状态行、响应头、响应正文</p></li><li><p><strong>服务器处理请求</strong>（通过路径参数映射到对应的请求处理器进行请求）<strong>并发回一个HTML响应</strong>（将处理结果和视图返回给浏览器）。</p></li><li><p><strong>TCP连接释放。</strong></p></li><li><p><strong>浏览器开始显示HTML。</strong></p></li></ol><p><strong>这个过程中用到的协议？</strong></p><ol><li>DNS：获取域名对应的IP</li><li>TCP：与服务器建立TCP连接</li><li>ARP：路由器在与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议。</li><li>HTTP：在TCP建立连接完成之后使用HTTP协议访问网页。</li><li>IP：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议。</li><li>OSPF：IP数据包在路由器之间，路由选择使用OSPF协议。</li></ol><h3 id="11-7-Keep-Alive"><a href="#11-7-Keep-Alive" class="headerlink" title="11.7 Keep-Alive"></a>11.7 Keep-Alive</h3><p><a href="https://blog.csdn.net/oceanperfect/article/details/51064574">(34条消息) http的keep-alive和tcp的keepalive区别_oceanperfect的博客-CSDN博客</a></p><blockquote><p>HTTP中的KeepAlive：</p></blockquote><p>在早期的HTTP，每一个HTTP请求都要求打开一个TCP SOCKET连接，并且在使用依次之后就会断开这个连接。这样的消耗无疑是非常大的。因此就可以使用KeepAlive来改善这种状态，<strong>即在一次TCP连接中可以持续发送多份数据而不会断开连接</strong>，只要任意一方没有明确提出断开连接，则保持TCP连接状态。通过该机制，可以减少TCP建立连接次数，提高性能和提高HTTP服务器的吞吐率。但是长时间的TCP连接容易导致系统资源无效占用，配置不当的KeepAlive带来的损失也是很大的。</p><p>同时为了避免资源浪费，web服务软件一般会提供<code>keepalive_timeout</code>参数，用来指定HTTP长连接的超时时间。比如HTTP的长连接的超时时间是60秒，web服务软件就会启动一个定时器，如果客户端在完成一个HTTP请求之后，60秒内都没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放连接。</p><blockquote><p>TCP中的KeepAlive</p></blockquote><p>也叫<strong>保活机制</strong>，该功能由内核实现，当客户端和服务端长达一定时间没有进行数据交互的时候，内核为了确保该连接是否还有效，就会发送探测报文，来检查对方是否还在线，然后来决定是否关闭该连接。</p><p>TCP连接建立之后，如果应用程序或者上层协议一直不发送消息或者隔很久才发送一次数据，这是掉线了还是确实没有数据传输，连接还需不需要保持？当超过一段时间（两小时）之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明连接还可以继续保持，如果没有报文返回，并且重复了多次之后达到了保活探测次数（一般都是每隔75秒，一共十次）后还是没有，就会认为连接丢失，没有继续保持下去。</p><p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><blockquote><p>HTTP如何保证长连接</p></blockquote><p>一种是应用层自己去实现心跳包：由应用程序自己发送心跳包来检测连接是否正常。大致就是服务器在一个Timer事件中定时向客户端发送一个数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应。如果在一定的时间内都没有收到回应，就会认为客户端掉线。同样如果客户端在一定时间没有收到服务端的心跳包，也会认为连接不可用。</p><p>一种是直接使用TCP的KeepAlive机制，因为HTTP实际上是基于TCP协议的，而且如果我们自己去实现心跳包的话，代码较多而且较为复杂。</p><h3 id="11-8-网络七层模型"><a href="#11-8-网络七层模型" class="headerlink" title="11.8 网络七层模型"></a>11.8 网络七层模型</h3><p>整个流程我们以信息发送为例，假如A想发送消息给B。</p><p><strong>应用层</strong>：直接向用户提供服务，完成用户希望在网络上完成的各种工作。就比如A在应用聊天框里面输入消息，并且点击发送按钮，这一刻就进入了应用层协议的处理。<strong>HTTP、HTTPS、FTP、SMTP</strong></p><p><strong>表示层</strong>：负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p><p><strong>会话层</strong>：建立和管理应用程序之间的通信；如果A一次性发送五条数据，是每发送一次信息建立一次通信连接然后断开，还是一旦建立好连接之后就将这五条消息连续发送给对方，决定采用哪种连接方法是会话层应该做的事情。<strong>会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理</strong>，<strong>SSL&#x2F;TSL协议</strong></p><p><strong>传输层</strong>：会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际的传输数据的功能，而传输层会确保所传输的数据到达目标地址，如果没有收到就会重发。</p><p><strong>网络层</strong>：网络层负责将数据发送至最终目标地址，端对端的发送。通过路由选择算法，为报文通过通信子网选择最合适的路径。比如计算机网络中有很多台计算机，如果找到想要发送的那台？如果中间有多个节点，该如何选择路径？<strong>ARP、IP、ICMP</strong></p><p><strong>数据链路层</strong>：通信传输实际上是通过物理的传输介质实现的，该层的作用就是在这些通过传输介质互连的设备之间进行数据处理。将IP转换为MAC地址</p><p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p>它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。</p><p><strong>物理层</strong>：解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</p><p>它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p><h2 id="12-操作系统"><a href="#12-操作系统" class="headerlink" title="12. 操作系统"></a><strong>12. 操作系统</strong></h2><h3 id="12-1-同步和异步？"><a href="#12-1-同步和异步？" class="headerlink" title="12.1 同步和异步？"></a>12.1 同步和异步？</h3><ol><li>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另外一个线程读到，或者正在读的数据可能已经被另外一个线程写过了，那么这些数据就必须进行同步存取。</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程。</li><li>事实上所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</li></ol><h3 id="12-3-线程、进程、协程"><a href="#12-3-线程、进程、协程" class="headerlink" title="12.3 线程、进程、协程"></a>12.3 线程、进程、协程</h3><p>进程是系统进行资源分配和调度的一个独立单位，是一个在内存中运行的应用程序；线程是进程划分的更小的运行单位，一个进程可以有多个线程。</p><p><strong>进程和线程的区别：</strong></p><ol><li><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看作是轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和PC，线程之间切换的开销比较小。</li><li><strong>包含关系：</strong>线程是进程的一部分，所以线程也被称为轻量级进程。</li><li><strong>内存分配：</strong>同一个进程的线程共享本进程的地址空间和资源，而进程和进程之间的地址空间和资源是独立的。 </li><li><strong>影响关系：</strong>一个进程崩溃之后，在保护模式下不会对其它进程产生影响，但是一个线程崩溃后有可能导致整个进程都死掉。进程比线程更有健壮性。</li><li><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ol><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><blockquote><p>有了进程为什么还要有线程？</p></blockquote><ul><li>进程只能在一个时间干一件事情，如果想要同时干多个事情就无能为力了。</li><li>进程在执行过程中如果阻塞，比如等待输入，整个进程就会被挂起，即使进程中有些工作不依赖于输入的数据也将无法运行。</li><li>从操作系统的层面来说，线程的切换相对于进程来说消耗较小。</li></ul><blockquote><p>什么是协程</p></blockquote><p>协程是一种比线程更加轻量级的存在，他完全由程序所控制，在<strong>用户态</strong>执行，可以让性能大幅度提升。</p><p>一个操作系统可以有多个进程，一个进程可以有多个线程，而一个线程又可以有多个协程。</p><p>可以将协程理解为一个特殊的函数，这个函数在某个地方挂起，并且可以重新在挂起处继续运行。而且一个线程内的多个协程的运行是<strong>串行的</strong>，也就是说<strong>当线程内的某一个协程运行的时候，其他协程必须挂起。</strong></p><p>协程的切换是在线程内完成的，涉及到的资源比较小，切换的代价比较低。如果线程内的某个协程调用了阻塞IO，那么就会导致线程切换发生。<strong>实际上协程只有在等待IO的过程中才能重复利用线程，协程 + 异步才能发挥出协程的最大作用</strong>。</p><p><strong>协程的使用</strong>：可以利用协程在IO等待时间就去切换执行其他任务，当IO操作结束之后再自动回调，那么就会大大节省资源并提高性能，从而实现异步编程。</p><p><strong>注意</strong>：协程只有再等待IO的过程中才能重复利用线程。而线程在等待IO过程中会陷入阻塞状态，切换到其他线程，而过多的线程的切换会占用大量的系统时间，并且系统线程会占用非常多的内存空间。</p><p><strong>协程无法被操作系统所感知到，因此在协程调用阻塞IO操作（打印、读取文件、Socket接口等）的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></p><h3 id="12-4-什么是上下文切换？"><a href="#12-4-什么是上下文切换？" class="headerlink" title="12.4 什么是上下文切换？"></a>12.4 什么是上下文切换？</h3><ol><li>在多线程编程中，线程的个数一般都大于CPU核心的个数，而一个CPU在任意时刻只能被一个线程使用，为了让这些线程都有效执行，<strong>CPU采取的策略就是为每个线程分配时间片并轮转的形式。</strong>当一个线程的时间片用完的时候就会重新处于就绪状态让给其它线程使用，这个过程就叫做上下文切换。</li><li>概括来就是说，当前任务在执行完CPU的时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换。</strong></li><li>频繁的上下文切换会消耗大量的CPU事件。</li></ol><h3 id="12-5-死锁"><a href="#12-5-死锁" class="headerlink" title="12.5 死锁"></a>12.5 死锁</h3><h4 id="1-死锁形成的条件"><a href="#1-死锁形成的条件" class="headerlink" title="1. 死锁形成的条件"></a>1. 死锁形成的条件</h4><ul><li><strong>互斥条件：</strong>资源只能有一个进程占用。如果此时还有其它的进程来请求该资源，就只能等待直到占有资源的进程用毕释放。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一个资源，而该资源被别的进程所占有。</li><li><strong>非抢占：</strong>资源不能被抢占，只能在持有资源的进程完成任务后，该资源才会被释放。 </li><li><strong>循环等待：</strong>若干进程之间形成一种头尾相接的循环等待关系。</li></ul><h4 id="2-如何避免死锁"><a href="#2-如何避免死锁" class="headerlink" title="2. 如何避免死锁"></a>2. 如何避免死锁</h4><p>预防死锁，就要避免上述的四个死锁形成条件。</p><ol><li>避免一个线程同时获得多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替换使用内部锁机制。</li></ol><h3 id="12-6-孤儿进程和僵尸进程"><a href="#12-6-孤儿进程和僵尸进程" class="headerlink" title="12.6 孤儿进程和僵尸进程"></a>12.6 孤儿进程和僵尸进程</h3><p><strong>孤儿进程：</strong>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对他们完成状态收集工作。</p><p><strong>僵尸进程：</strong>一个进程使用fork创建子进程之后，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。在Linux中，僵尸进程不占用资源，只是它对应的PCB还存在。可能造成内存泄漏</p><p><strong>如何杀死僵尸进程？</strong></p><p> 首先僵尸进程一但出现会很难自己消亡，会一直存在直至系统重启。虽然僵尸进程几乎不占用系统资源，但是数量太多了之后还是会对系统带来其它的影响。因此就需要杀掉僵尸进程。而僵尸进程是无法直接使用kill -9命杀掉的。</p><ol><li><strong>重启服务器</strong></li><li><strong>找到该defunct（失效的）僵尸进程的父进程，将该进程的父进程杀掉，将僵尸进程变成孤儿进程，然后由init进程收养</strong></li></ol><p><strong>它们是如何产生的？</strong></p><p>当你运行一个程序时，它会产生一个父进程以及很多子进程。 所有这些子进程都会消耗内核分配给它们的内存和CPU 资源。这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。  </p><p>若父进程正确的读取了子进程的 Exit 信号，则子进程会从进程表中删掉。但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。</p><h3 id="12-7-用户态和系统态"><a href="#12-7-用户态和系统态" class="headerlink" title="12.7 用户态和系统态"></a>12.7 用户态和系统态</h3><p>运行在应用态的进程可以直接读取用户程序的数据。运行在系统态的进程几乎可以访问计算机上的任何资源。</p><p><strong>用户态切换到内核态的三种方式：</strong></p><ol><li><strong>系统调用</strong>：用户态主动通过系统调用的方式切换到内核态。如果处于用户态的进程想要调用操作系统提供的系统态级别的子功能的时候，就可以通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。</li><li><strong>异常：</strong>当CPU在执行运行在用户态下的程序时， 发生了某些事先不可知的异常，这时就会触发当前由运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页中断。</li><li><strong>外围设备的中断：</strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU就会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到系统态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ol><h3 id="12-8-线程和进程的生命周期"><a href="#12-8-线程和进程的生命周期" class="headerlink" title="12.8 线程和进程的生命周期"></a>12.8 线程和进程的生命周期</h3><blockquote><p>线程的生命周期</p></blockquote><p>对于通用的生命状态来说，一共有五种状态：</p><ol><li><strong>初始状态：</strong>线程已经被创建，但是还不允许分配CPU运行。这个状态是属于编程语言特有的，不过这里的创建仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还未被创建，比如new Thread，这时候在编程语言层面线程是新建状态</li><li><strong>可运行状态：</strong>线程可以分配CPU执行，在这个时候，真正的操作系统层面的线程已经被成功创建了，但是还暂未分配CPU。</li><li><strong>运行状态：</strong>可运行状态的线程被分配到了处理机资源，进入运行状态</li><li>运行状态的线程如果调用一个阻塞的API（例如以阻塞的方式读取文件）或者等待某个事件（例如条件变量），那么线程就会切换至<strong>休眠状态</strong>，同时释放CPU使用权，休眠状态的线程永远无法获得CPU使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li><li>线程执行完毕或者出现异常就会进入<strong>终止状态</strong>，此时意味着线程的生命周期结束了。</li></ol><p>不同的编程语言会有不同的实现，比如Java中的线程生命周期可以分为六个状态。</p><ol><li><strong>NEW（初始化状态）</strong></li><li><strong>RUNNABLE（可运行&#x2F;运行状态）</strong>：Java里面可以把可运行状态和运行状态进行合并，因为这两个状态在操作系统调度层面有用，而JVM层面不关心这两种状态，因为JVM将线程调度交给操作系统处理了。</li><li><strong>BLOCK（阻塞状态）</strong></li><li><strong>WAITING（无时限等待）</strong></li><li><strong>TIMED_WAITING（有时限等待）</strong></li><li><strong>TERMINATED（终止状态）</strong></li></ol><p><strong>Java中各大状态的转换】</strong></p><ul><li><strong>RUNNABLE与BLOCKED的状态转换</strong></li></ul><p>当线程等待synchronzied的隐式锁的时候，等待的线程会从RUNNABLE转换位BLOCKED状态，而当等待的线程获取到隐式锁的时候，就会从BLOCKED状态转换回RUNNABLE状态。</p><p>如果线程调用阻塞式API，在操作系统层面，的确会转换到休眠状态，释放CPU资源。但是在Java层面线程的状态依然保持RUNNABLE状态，<strong>JVM根本不关心操作系统调度相关的状态</strong>，因为在JVM看来，等待CPU使用权（操作系统层面此时处于可执行状态）和等待IO（操作系统层面处于休眠状态）没有区别，都是在等待某个资源，所以都归入了RUNNABLE状态。</p><p>平时说的Java在调用阻塞式API时线程阻塞，说的其实是操作系统层面的阻塞状态。</p><ul><li><strong>RUNNABLE和WAITTING状态切换</strong></li></ul><p>第一种：在隐式锁中调用wait方法</p><p>第二种：调用无参数的Thread.join方法，这是一种线程同步方法，比如有一个线程对象ThreadA，当调用A.join方法的时候，执行这条语句的线程会等待A线程执行完毕，而等待中的这个线程就会从RUNNABLE转换为WAITTING。当线程A执行完之后，线程B就会从WAITTING转换回RUNNABLE</p><p>第三种：调用LockSupport.park方法，使用unpark又回去了。</p><ul><li><strong>RUNNABLE和TIMED_WAITTING</strong></li></ul><p>带有超时参数的各种方法，比如sleep、wait、jon、parkNanos、parkUntil</p><ul><li><strong>NEW到RUNNABLE</strong></li></ul><p>Java刚创建出来的对象就是NEW状态，只需要调用线程对象的start方法就可以转换为RUNNABLE状态。</p><ul><li><strong>RUNNABLE到TERMINATED</strong></li></ul><p>执行完run之后自动转换。同时如果执行期间抛出异常也会转换。</p><p>如果需要强制中断run方法执行，首先Thread中的stop方法可以，但是不建议使用，可以使用interrupt方法。</p><blockquote><p>进程的生命周期</p></blockquote><p>NEW创建状态：进程正在被创建</p><p>READY就绪态：进程创建成功，并且获得了除处理器以外的所有所需资源，一旦获得处理器资源即时间片之后就可以运行</p><p>RUNNING运行态：进程在处理器上运行，注意的是，单核CPU下任意时刻只能有一个进程处于运行状态</p><p>WAITING阻塞态：进程正在等待某一事件而暂停运行，比如等待某资源可用或等待IO操作完成，即使处理器空闲，该阻塞态的进程也无法被执行</p><p>TERMINATED结束态</p><h3 id="12-9-进程间的通信方式"><a href="#12-9-进程间的通信方式" class="headerlink" title="12.9 进程间的通信方式"></a>12.9 进程间的通信方式</h3><p>每个进程都有不同的用户地址空间，任何一个进程的全局变量在另外一个进程中都看不到，因此如果进程之间想要交换数据必须要通过内核，在内核中开辟一片缓冲区，进程A将数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区将数据读走，这种内核提供的机制被称为进程间通信。</p><p><strong>匿名管道</strong></p><p>管道是一种半双工的通信方式，也就是数据只能单向流动，而且匿名管道只能在具有亲缘关系的进程间使用，通常是指父子进程。管道这种通信方式效率低，不适合进程间频繁交换数据。</p><ul><li>父进程创建管道，得到两个文件描述符指向管道的两端</li><li>父进程fork出子进程，子进程也有两个文件描述符指向同一管道，创建的子进程会复制父进程的文件描述符</li><li>父进程关闭管道读端，子进程关闭管道写端（管道只支持单向通信）。父进程可以往管道里面写，子进程从管道里面读。管道是利用环形队列实现的，数据从写端流入从读端流出。</li></ul><p><strong>有名管道</strong></p><p>对于有名管道，他可以在不相关的进程间也能相互通信。因为有名管道提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件就可以相互通信。</p><h3 id="12-10-线程间通信方式"><a href="#12-10-线程间通信方式" class="headerlink" title="12.10 线程间通信方式"></a>12.10 线程间通信方式</h3><p>线程间的通信方式主要用于线程同步，而不是数据交换</p><p><strong>锁机制</strong>：</p><p>比如互斥锁、条件变量、读写锁等等。</p><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法</li><li>读写锁允许多个线程同时读共享数据，但是只能有一个线程对共享数据进行写操作</li><li>条件变量可以以原子的方式阻塞线程，直到某个特定条件为真未知。对条件的测试是在互斥锁的保护下进行的。条件变量始终和互斥锁一起使用</li></ul><p><strong>信号量机制</strong>：Semaphore</p><p><strong>信号机制</strong>：Signal</p><h3 id="12-11-用户态和内核态"><a href="#12-11-用户态和内核态" class="headerlink" title="12.11 用户态和内核态"></a>12.11 用户态和内核态</h3><p>如果面试官问什么是系统调用，就可以扯到用户态和内核态</p><p><a href="https://zhuanlan.zhihu.com/p/388057431">从根上理解用户态与内核态 - 知乎 (zhihu.com)</a></p><h3 id="12-12-Linux常用命令"><a href="#12-12-Linux常用命令" class="headerlink" title="12.12 Linux常用命令"></a>12.12 Linux常用命令</h3><p>查看端口占用情况：lsof -i:端口号，list open files</p><p>杀掉执行PID的进程：kill -9</p><p>kill命令对应的是kill -15，系统会发送SIGTERM信号给对应的进程，大部分进程收到之后会先释放自己的资源再停止，也就是说SIGTERM多半是会被阻塞的；而kill -9会发送SIGKILL信号，代表强制删除</p><p>显示系统内所有的进程信息：ps -elf</p><p>以全屏交互式的界面显示进程排名：top</p><h2 id="13-RPC项目指南"><a href="#13-RPC项目指南" class="headerlink" title="13. RPC项目指南"></a>13. RPC项目指南</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>项目借鉴了Dubbo的SPI机制，使用SPI机制对一些类进行配置。</p><p>服务提供者端启动：启动代码就常规的Netty服务端启动代码，从容器中获取NettyRpcServer（被@Component标注），然后调用它的start方法，等待客户端建立连接。</p><p>同时在启动类上，有注解@RpcScan，它内部包含@Import注解，导入了一个注册类CustomScannerRegistrar，它实现了ImportBeanDefinitionRegistrar，该类的执行时机：在容器刷新过程中的invokeBeanFactoryPostProcessor阶段，ConfigurationClassPostProcessor会起到作用，它内部最终会调用ImportBeanDefinitionRegistrar的registerBeanDefinitions方法实现中，它会扫描所有标注了@RpcService的类，后续再进行实例化。</p><p>对于Spring整合Dubbo来说，它也是有一个类似RpcScan的注解，同样会扫描所有的标注了@DubboService注解的class。</p><p>同时还向Spring容器中引入了SpringBeanPostProcessor，它实现了BeanPostProcessor接口，重写了postProcessBeforeInitialization和postProcessAfterInitialization方法，</p><ul><li>在前者方法中，会判断该类是否被RpcService标注，如果是，就进行服务发布流程，构造RpcServiceConfig，将其注入到注册中心，并做好缓存。</li><li>在后者方法中，会判断该类的属性中是否有被@RpcReference标注的，如果有，就创建其代理类，并注入其中</li></ul><p>Dubbo中的@DubboReference是在类进行populate的时候，如果发现该字段是标注了该注解的话，就会去实例化他</p><p>服务消费者端启动，启动之后并未直接向服务端通信，而是正常流程启动，利用CustomScannerRegistrar和SpringBeanPostProcessor进行一些初始化操作。接下来如果我们调用暴露的服务，比如HelloController中有属性@RpcReference HelloService，在调用Service的hello方法的时候，由于HelloController中注入的Service是它的代理类，因此执行的时候会执行它的invoke方法，在该方法里面，构造RpcRequest，并向服务端发送RPC请求。</p><p>在发送请求的流程中， 首先会去注册中心查找该请求的服务，如果有多个，就使用负载均衡策略选择一个。得到对应服务的ip和端口之后，看看有没有已经建立好对应的连接了，如果没有就创建新的连接，然后客户端发送请求给服务端，经过压缩、序列化之后，服务端收到请求，执行好了之后，将结果再发给客户端，客户端收到请求，解析出结果，返回给调用者。RPC结束。</p><p>在我的RPC项目中，并没有对zookeeper中的节点进行缓存，也没有订阅zookeeper的变化，而且是在执行远程服务方法的时候才去zookeeper中获取服务的地址。</p><p>同时客户端和服务端之间还拥有心跳检测机制。</p><p>压缩使用的GZIP，</p><p>Netty自带的心跳核心类，IdleStateHandler。</p><h3 id="如何解决粘包、拆包问题？"><a href="#如何解决粘包、拆包问题？" class="headerlink" title="如何解决粘包、拆包问题？"></a>如何解决粘包、拆包问题？</h3><p>四种方法：</p><ol><li>短连接，每次传输数据都是一次连接，传输完毕就关闭连接。频繁建立和关闭消耗资源</li><li>固定长度，如果太长就浪费资源，如果太短就可能有些数据无法完整传输</li><li>固定分隔符：数据包中无法含有该分隔符</li><li>预设长度，本项目采用的方式：</li></ol><p>使用的是Netty的<strong>LengthFieldBasedFrameDecoder</strong>类，有五个参数：最大长度、长度偏移、长度占用字节、长度调整、剥离字节数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">this</span>(RpcConstants.MAX_FRAME_LENGTH, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>5表示长度的偏移量为5，并且长度占用4个字节。</p><p>0表示所有的数据我都接受，不抛弃。</p><h3 id="序列化机制是？为啥选kryo？"><a href="#序列化机制是？为啥选kryo？" class="headerlink" title="序列化机制是？为啥选kryo？"></a>序列化机制是？为啥选kryo？</h3><p>JDK序列化：Java自带的，不支持跨语言，</p><p>hessian序列化：时间较早，跨语言，</p><p>Protostuff序列化：跨语言</p><p>Kryo：针对Java</p><ol><li>Kryo序列化的“对象”是数据以及少量元信息，这和JAVA默认的序列化的本质区别，java默认的序列化的目的是语言层次的，将类，对象的所有信息都序列化了，也就是就算是不加载类的定义，也可以根据序列化后的信息动态生成类的所有信息。而Kryo反序列化时，必须能加载类的定义，这样Kryo可以节省大量的字节空间。</li><li>使用变长int，变长long存储int，long类型，大大节省空间。</li><li>元数据（字符串类型）使用缓存机制，重复出现的字符串使用int来存储，节省存储空间。</li><li>字符串类型使用UTF-8存储，但会使用ascii码进一步优化空间</li></ol><p><a href="https://zhuanlan.zhihu.com/p/272816835">为什么如此高效？解密kryo各个数据类型的序列化编码机制，强 - 知乎 (zhihu.com)</a></p><h3 id="说说本项目的协议设计："><a href="#说说本项目的协议设计：" class="headerlink" title="说说本项目的协议设计："></a>说说本项目的协议设计：</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">*   0    1    2    3    4       5   6   7   8   9         10      11      12   13   14   15  16<br>*   +<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">----</span> -- +<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+<span class="hljs-params">----</span>+--+<br>*   |   magic   code    |<span class="hljs-keyword">version</span>|   full length |messageType|codec|compress|    RequestId    |<br>*   +<span class="hljs-params">-------------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-----</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">-----------------</span>+<br>*   |                                                                                        |<br>*   |                                         body                                           |<br>*   |                                                                                        |<br>*   |                                        <span class="hljs-string">...</span> <span class="hljs-string">...</span>                                         |<br>*   +<span class="hljs-params">----------------------------------------------------------------------------------------</span>+<br>* 4B  magic code（魔法数）   1B <span class="hljs-keyword">version</span>（版本） 4B full length（消息长度）1B messageType（消息类型）<br>* 1B compress（压缩类型） 1B codec（序列化类型） 4B  requestId（请求的Id）<br></code></pre></td></tr></table></figure><h3 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h3><p>BIO：</p><ul><li>线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成；</li><li>一个连接一个线程</li><li>同步并阻塞，服务器实现模式为一个连接一个请求，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个线程不做任何事情会造成不必要的开销，可以通过线程池改善。</li><li>适用于连接数比较小，且固定的架构，JDK1.4之前的唯一选择</li></ul><p>NIO：</p><ul><li>线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成；</li><li>一个请求一个线程；</li><li>同步非阻塞，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有IO请求的时候才启动一个线程去处理</li><li>适用于连接数较多且连接比较短的架构，比如聊天服务器，1.4开始支持</li></ul><p>AIO：</p><ul><li>线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。</li><li>一个有效请求一个线程</li><li>异步非阻塞，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li><li>适用于连接数比较多，且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作。</li></ul><h3 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h3><h3 id="HTTP如何解决粘包问题？知道chunked吗？"><a href="#HTTP如何解决粘包问题？知道chunked吗？" class="headerlink" title="HTTP如何解决粘包问题？知道chunked吗？"></a>HTTP如何解决粘包问题？知道chunked吗？</h3><p><a href="https://blog.csdn.net/u013378306/article/details/107742524">https://blog.csdn.net/u013378306/article/details/107742524</a></p><h3 id="zookeeper作为注册中心是怎么存储的，存储什么数据？"><a href="#zookeeper作为注册中心是怎么存储的，存储什么数据？" class="headerlink" title="zookeeper作为注册中心是怎么存储的，存储什么数据？"></a>zookeeper作为注册中心是怎么存储的，存储什么数据？</h3><h3 id="为什么要把每个服务端注册成临时节点？"><a href="#为什么要把每个服务端注册成临时节点？" class="headerlink" title="为什么要把每个服务端注册成临时节点？"></a>为什么要把每个服务端注册成临时节点？</h3><h3 id="客户端发起调用的时候每次都去获取节点信息吗？"><a href="#客户端发起调用的时候每次都去获取节点信息吗？" class="headerlink" title="客户端发起调用的时候每次都去获取节点信息吗？"></a>客户端发起调用的时候每次都去获取节点信息吗？</h3><h3 id="如果每次都获取的话性能就会比较低，有没有什么优化方案？（用watcher）"><a href="#如果每次都获取的话性能就会比较低，有没有什么优化方案？（用watcher）" class="headerlink" title="如果每次都获取的话性能就会比较低，有没有什么优化方案？（用watcher）"></a>如果每次都获取的话性能就会比较低，有没有什么优化方案？（用watcher）</h3><h3 id="使用watcher的时候需要注意什么？watcher回调完后还要做什么事情吗？"><a href="#使用watcher的时候需要注意什么？watcher回调完后还要做什么事情吗？" class="headerlink" title="使用watcher的时候需要注意什么？watcher回调完后还要做什么事情吗？"></a>使用watcher的时候需要注意什么？watcher回调完后还要做什么事情吗？</h3><h3 id="rpc中应用线程池调用者发送调用后，请求跟响应是怎么异步关联的呢？（回调）"><a href="#rpc中应用线程池调用者发送调用后，请求跟响应是怎么异步关联的呢？（回调）" class="headerlink" title="rpc中应用线程池调用者发送调用后，请求跟响应是怎么异步关联的呢？（回调）"></a>rpc中应用线程池调用者发送调用后，请求跟响应是怎么异步关联的呢？（回调）</h3><h3 id="基于回调要怎么异步关联起来呢，有没有什么思路？"><a href="#基于回调要怎么异步关联起来呢，有没有什么思路？" class="headerlink" title="基于回调要怎么异步关联起来呢，有没有什么思路？"></a>基于回调要怎么异步关联起来呢，有没有什么思路？</h3><h3 id="消息里为什么要有requestID？"><a href="#消息里为什么要有requestID？" class="headerlink" title="消息里为什么要有requestID？"></a>消息里为什么要有requestID？</h3><p>如果使用netty的话，一般会用channel.writeAndFlush()方法来发送消息二进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。于是这里出现以下两个问题：</p><p>1）怎么让当前线程“暂停”，等结果回来后，再向后执行？</p><p>2）如果有多个线程同时进行远程方法调用，这时建立在client server之间的socket连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server处理完结果后，将结果消息发送给client，client收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？</p><p>　　如下图所示，线程A和线程B同时向client socket发送请求requestA和requestB，socket先后将requestB和requestA发送至server，而server可能将responseA先返回，尽管requestA请求到达时间更晚。我们需要一种机制保证responseA丢给ThreadA，responseB丢给ThreadB。</p><p><img src="522490-20151003171953574-1892668698.png" alt="img"></p><p>怎么解决呢？</p><p>1）client线程每次通过socket调用一次远程接口前，生成一个唯一的ID，即requestID（requestID必需保证在一个Socket连接里面是唯一的），一般常常使用AtomicLong从0开始累计数字生成唯一ID；</p><p>2）将处理结果的回调对象callback，存放到全局ConcurrentHashMap里面put(requestID, callback)；</p><p>3）当线程调用channel.writeAndFlush()发送消息后，紧接着执行callback的get()方法试图获取远程返回的结果。在get()内部，则使用synchronized获取回调对象callback的锁，再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。</p><p>4）服务端接收到请求并处理后，将response结果（此结果中包含了前面的requestID）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到requestID，再从前面的ConcurrentHashMap里面get(requestID)，从而找到callback对象，再用synchronized获取callback上的锁，将方法调用结果设置到callback对象里，再调用callback.notifyAll()唤醒前面处于等待状态的线程。</p><h3 id="项目中-负载均衡怎么实现的"><a href="#项目中-负载均衡怎么实现的" class="headerlink" title="项目中[负载均衡怎么实现的"></a>项目中[负载均衡怎么实现的</h3><h3 id="有没有提供什么扩展的接口，钩子给其人或程序方便扩展。"><a href="#有没有提供什么扩展的接口，钩子给其人或程序方便扩展。" class="headerlink" title="有没有提供什么扩展的接口，钩子给其人或程序方便扩展。"></a>有没有提供什么扩展的接口，钩子给其人或程序方便扩展。</h3><h3 id="JDK动态代理机制是怎么实现的"><a href="#JDK动态代理机制是怎么实现的" class="headerlink" title="JDK动态代理机制是怎么实现的"></a>JDK动态代理机制是怎么实现的</h3>]]></content>
    
    
    <categories>
      
      <category>面试话术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试话术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于一些可能会用到的东西的记录</title>
    <link href="/%E6%9D%82%E8%B0%88/%E9%9A%8F%E7%AC%94/"/>
    <url>/%E6%9D%82%E8%B0%88/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA2020-3-4重置30天"><a href="#IDEA2020-3-4重置30天" class="headerlink" title="IDEA2020.3.4重置30天"></a>IDEA2020.3.4重置30天</h1><p>修改文件名为：reset_jetbrains_eval_windows.vbs</p><figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vbs"><span class="hljs-keyword">Set</span> oShell = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)<br><span class="hljs-keyword">Set</span> oFS = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Scripting.FileSystemObject&quot;</span>)<br>sHomeFolder = oShell.ExpandEnvironmentStrings(<span class="hljs-string">&quot;%USERPROFILE%&quot;</span>)<br>sJBDataFolder = oShell.ExpandEnvironmentStrings(<span class="hljs-string">&quot;%APPDATA%&quot;</span>) + <span class="hljs-string">&quot;\JetBrains&quot;</span><br><br><span class="hljs-keyword">Set</span> re = <span class="hljs-keyword">New</span> RegExp<br>re.Global     = <span class="hljs-literal">True</span><br>re.IgnoreCase = <span class="hljs-literal">True</span><br>re.Pattern    = <span class="hljs-string">&quot;\.?(IntelliJIdea|GoLand|CLion|PyCharm|DataGrip|RubyMine|AppCode|PhpStorm|WebStorm|Rider).*&quot;</span><br><br><span class="hljs-keyword">Sub</span> remove<span class="hljs-built_in">Eval</span>(<span class="hljs-keyword">ByVal</span> file, <span class="hljs-keyword">ByVal</span> sEvalPath)<br>bMatch = re.Test(file.Name)<br>    <span class="hljs-keyword">If</span> <span class="hljs-keyword">Not</span> bMatch <span class="hljs-keyword">Then</span><br><span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><br><span class="hljs-keyword">If</span> oFS.FolderExists(sEvalPath) <span class="hljs-keyword">Then</span><br>oFS.DeleteFolder sEvalPath, <span class="hljs-literal">True</span> <br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br><br><span class="hljs-keyword">If</span> oFS.FolderExists(sHomeFolder) <span class="hljs-keyword">Then</span><br><span class="hljs-keyword">For</span> <span class="hljs-keyword">Each</span> oFile <span class="hljs-keyword">In</span> oFS.GetFolder(sHomeFolder).SubFolders<br>    removeEval oFile, sHomeFolder + <span class="hljs-string">&quot;\&quot;</span> + oFile.Name + <span class="hljs-string">&quot;\config\eval&quot;</span><br><span class="hljs-keyword">Next</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><br><span class="hljs-keyword">If</span> oFS.FolderExists(sJBDataFolder) <span class="hljs-keyword">Then</span><br><span class="hljs-keyword">For</span> <span class="hljs-keyword">Each</span> oFile <span class="hljs-keyword">In</span> oFS.GetFolder(sJBDataFolder).SubFolders<br>    removeEval oFile, sJBDataFolder + <span class="hljs-string">&quot;\&quot;</span> + oFile.Name + <span class="hljs-string">&quot;\eval&quot;</span><br><span class="hljs-keyword">Next</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><br>MsgBox <span class="hljs-string">&quot;done&quot;</span><br></code></pre></td></tr></table></figure><h1 id="安装Prometheus-Grafana"><a href="#安装Prometheus-Grafana" class="headerlink" title="安装Prometheus + Grafana"></a>安装Prometheus + Grafana</h1><ul><li>安装prometheus：9090端口</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">https:<span class="hljs-string">//prometheus.io/download/</span>下载tar.gz版本<br><span class="hljs-string">//</span> 解压<br>tar -xzvf prometheus-2.21.0.linux-amd64.tar.gz -C <span class="hljs-string">/usr/local/</span><br><br><span class="hljs-string">//</span> 重命名<br>mv <span class="hljs-string">/usr/local/prometheus-2.21.0.linux-amd64</span> <span class="hljs-string">/usr/local/prometheus</span><br><br><span class="hljs-string">//</span> 修改prometheus.yml文件<br>将默认的localhost<span class="hljs-function">:9090</span>改为你服务器的ip,端口号可以不改<br><br><span class="hljs-string">//</span> 启动<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr/local/prometheus</span><br><span class="hljs-string">./prometheus</span> <span class="hljs-params">--config</span>.file=<span class="hljs-string">&quot;/usr/local/prometheus/prometheus.yml&quot;</span> &amp;<br><br><br></code></pre></td></tr></table></figure><ul><li>安装grafana：3000端口</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//g</span>rafana.com<span class="hljs-regexp">/grafana/</span>download?platform=linux<br><br>wget https:<span class="hljs-regexp">//</span>dl.grafana.com<span class="hljs-regexp">/enterprise/</span>release/grafana-enterprise-<span class="hljs-number">9.2</span>.<span class="hljs-number">0</span>.linux-amd64.tar.gz<br>tar -zxvf grafana-enterprise-<span class="hljs-number">9.2</span>.<span class="hljs-number">0</span>.linux-amd64.tar.gz<br><br>进入目录中的bin下启动<br></code></pre></td></tr></table></figure><h1 id="github-push-失败"><a href="#github-push-失败" class="headerlink" title="github push 失败"></a>github push 失败</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-selector-attr">[你的代理端口]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="/Java/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Java/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap源码解析"><a href="#ConcurrentHashMap源码解析" class="headerlink" title="ConcurrentHashMap源码解析"></a>ConcurrentHashMap源码解析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>什么是ConcurrentHashMap？</p></blockquote><p>ConcurrentHashMap是为了解决HashMap线程不安全而出现的一个类。</p><p><strong>底层结构</strong>：在JDK1.7的时候，底层是分段的数组 + 链表；在JDK1.8的时候，使用了数组+ 链表 + 红黑树的底层结构。</p><p><strong>线程安全</strong>：在JDK1.7的时候，ConcurrentHashMap对整个数组进行了分割，形成了多个Segment，而Segment类继承了ReentrantLock，也就是形成了多把锁，每把锁只锁住容器中的一部分数据。多线程访问不同数据段中的数据，就不会造成并发问题。每个Segment都包含一个HashEntry数组，而每个HashEntry是一个链表结构的元素。而在JDK1.8的时候，进行了大修改。采用synchronized和CAS来操作。同时每次使用synchronized只会锁住当前链表或红黑树的头节点，提升并发量。</p><h2 id="JDK7下的ConcurrentHashMap"><a href="#JDK7下的ConcurrentHashMap" class="headerlink" title="JDK7下的ConcurrentHashMap"></a>JDK7下的ConcurrentHashMap</h2><p>优点：如果多个线程访问不同的Segment，实际上不会产生冲突。</p><p>缺点：Segment的初始值大小为16，而且这个容量一旦确定之后就不可以被修改。</p><h2 id="JDK8下的ConcurrentHashMap"><a href="#JDK8下的ConcurrentHashMap" class="headerlink" title="JDK8下的ConcurrentHashMap"></a>JDK8下的ConcurrentHashMap</h2><p>对于ConcurrentHashMap的无参构造器来说，其实是个空构造器，什么都没做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Encodings for Node hash fields. See above for explanation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOVED</span>     <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEBIN</span>   <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RESERVED</span>  <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span><br></code></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode()); <span class="hljs-comment">// 计算hash值</span><br>    <span class="hljs-comment">// 要求table不为null，table的长度大于0，该key所处于的桶不为null</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果头节点就是要查找的key</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">// hash值为负数表示该bin在扩容中或者是treebin，这时候调用find方法来查找</span><br>        <span class="hljs-comment">// TreeBin表示红黑树头节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 注意TreeBin重写了Node的find方法</span><br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 正常的链表遍历</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么get方法不需要加锁？</p></blockquote><p>Node的成员val是用volatile修饰的，因此对val的修改是满足可见性的。</p><p>而table数组也使用了volatile修饰，主要是保证数组在扩容时的可见性。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 不允许key或value为null</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode()); <span class="hljs-comment">//spread方法：return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 注意这里的循环</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable(); <span class="hljs-comment">// 第一次访问的时候，进行初始化，然后进入下一个循环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果使用CAS添加链表表头成功就直接跳出循环</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED) <span class="hljs-comment">// MOVED = -1</span><br>            <span class="hljs-comment">// 帮忙扩容，之后进入下一循环</span><br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// </span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 锁住链表头节点</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 遍历链表</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125; <span class="hljs-comment">// 红黑树</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-comment">// putTreeval会看key是否已经在树种，如果是则返回对应的TreeNode</span><br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                              value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 树化操作</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 增加size计数</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol><li>如果table未初始化，就会先初始化</li><li>如果table[i] &#x3D;&#x3D; null，就会使用CAS去创建bin。</li><li>如果已经有了，就锁住链表头节点，然后进行后续的put操作（链表还是红黑树），接着判断是否需要树化</li><li>最后调用addCount方法，这里面会判断是否需要扩容，即是否超过阈值</li></ol><h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果小于0，表示另外的线程执行CAS成功，就要让出CPU使用权</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// 设置SIZECTL为-1，</span><br>        <span class="hljs-comment">// -1说明正在初始化</span><br>        <span class="hljs-comment">// -N说明有N - 1个线程正在进行扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 说明得到了锁（不是sync），该线程就会进行初始化操作，而其他的线程就会yield直到table创建</span><br>            <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 双端检索</span><br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（TODO）扩容"><a href="#（TODO）扩容" class="headerlink" title="（TODO）扩容"></a>（TODO）扩容</h3><p>对于ConcurrentHashMap来说，它的扩容时机主要有两个：</p><ul><li>集合中的元素个数到达阈值的时候触发扩容，主要在addCount方法中判断</li><li>树化的时候，如果此时数组长度小于64，也会触发扩容</li></ul><p><a href="https://www.cnblogs.com/gunduzi/p/13651664.html">ConcurrentHashMap原理分析(二)-扩容 - 猿起缘灭 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池源码分析</title>
    <link href="/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-线程池执行流程"><a href="#第一章-线程池执行流程" class="headerlink" title="第一章 线程池执行流程"></a>第一章 线程池执行流程</h2><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池核心原理-线程池执行流程"></p><p>线程池在内部其实构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分为两部分：任务管理、状态管理。其中任务管理就是充当生产者的角色，当任务提交之后，线程池会判断该任务后续的流转：</p><ol><li>直接申请线程执行该任务</li><li>缓冲到阻塞队列中等待线程执行</li><li>拒绝该任务。</li></ol><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行</p><h2 id="第二章-线程池属性标识"><a href="#第二章-线程池属性标识" class="headerlink" title="第二章 线程池属性标识"></a>第二章 线程池属性标识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两个作用：声明当前线程池状态；声明线程池中的线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 高3位是线程池装填，低29位是线程池中的线程个数</span><br><span class="hljs-comment">// SIZE：32，COUNT_BITS就是29，方便后面做位运算</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 通过位运算得出最大容量</span><br><span class="hljs-comment">// 因为后29位是表示线程池中的线程数，因此就是1111111111111，29位1，2的29次方</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// 线程池的五种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 高三位为111 代表正常接受任务</span><br><span class="hljs-comment">// 000 不接受任务，但是内部还会处理阻塞队列中的任务，正在进行中的任务也正常执行 执行shutdown方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 001 不接受新任务，也不去处理阻塞队列中的任务，同时会中断正在执行的任务 执行shutdownNow方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 010 过渡状态，代表线程池即将OVER</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 011 执行terminated（），真的凉凉了。</span><br><br><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 得到线程池的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 得到当前线程池的线程数量，不区分核心和非核心</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-comment">// 通过状态和线程数生成ctl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>线程状态</th><th>状态释义</th></tr></thead><tbody><tr><td>RUNNING</td><td>线程池被创建后的初始状态，能接受新提交的任务，也能处理阻塞队列中的任务</td></tr><tr><td>SHUTDOWM</td><td>关闭状态，不接受新任务，但是仍然可以处理已经进入阻塞队列中的任务</td></tr><tr><td>STOP</td><td>会中断正在处理任务的线程，不能再接受新的任务，也不能继续处理阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>所有的任务都已经终止，workerCount（有效工作线程数）为0</td></tr><tr><td>TERMINATED</td><td>线程池彻底终止运行</td></tr></tbody></table><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC.png" alt="线程池核心原理-线程池的状态流转"></p><h2 id="第三章-源码分析"><a href="#第三章-源码分析" class="headerlink" title="第三章 源码分析"></a>第三章 源码分析</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>   <br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//拿到32位的int</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 获取工作线程数，是否小于核心线程数，说明可以创建核心线程数，一个线程池刚创建的时候内部没有线程</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// true表示核心线程</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 如果创建失败，重新获取ctl值（没加锁）</span><br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 判读线程池是否在运行，将任务添加到阻塞队列中,</span><br>    <span class="hljs-comment">/// 工作线程数大于核心线程数，且阻塞队列没有满</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 如果不是running，移除任务</span><br>        <span class="hljs-comment">// 相当于两次检查, remove方法源码如下：</span><br> <span class="hljs-comment">/*public boolean remove(Runnable task) &#123;</span><br><span class="hljs-comment">        boolean removed = workQueue.remove(task);</span><br><span class="hljs-comment">        tryTerminate(); // In case SHUTDOWN and now empty</span><br><span class="hljs-comment">        return removed;</span><br><span class="hljs-comment">    &#125;  */</span><br>        <span class="hljs-comment">// 当线程池的状态发生变化的时候，就需要将刚刚提交的任务从阻塞队列中进行删除</span><br>        <span class="hljs-comment">// 如果删除失败，可能是该任务已经被别的线程所处理了</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command); <span class="hljs-comment">// 拒绝策略</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 工作线程为0</span><br>            <span class="hljs-comment">// 担保机制，得保证线程池在running状态下至少得有一个线程在工作。</span><br>            <span class="hljs-comment">// 不然队列中的任务可能就一直无法被消耗</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 阻塞队列有任务，但是没有工作线程，添加一个任务为空的工作线程处理阻塞队列中的任务</span><br>    &#125; <span class="hljs-comment">// 创建非核心线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        <span class="hljs-comment">// 创建非核心线程失败，拒绝策略</span><br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><p>主要作用是创建一个线程，也就是一个Worker，来处理新提交的任务firstTask，如果firstTask为null，该Worker就会从任务队列中获取任务来执行。core参数表示本次添加的线程是否是核心线程。</p><p>在线程池中，其实并没有对核心线程和非核心线程采取不同的实现方式，都统一封装成Worker。</p><p>查看execute方法中的<strong>addWorker源码</strong></p><ul><li><strong>处于shutdown状态下的线程池是允许添加新的线程来处理队列中剩余的任务的，只是不能添加新的任务</strong></li><li><strong>处于STOP、TIDYING、TERMINATED状态下的线程池都会中断正在处理任务的线程，并且不再接受新的任务和处理队列中的任务，也无法创建新的线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry: <span class="hljs-comment">// 标记，内部for循环跳出外部for循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c); <span class="hljs-comment">// 获取线程池状态</span><br><br>        <span class="hljs-comment">// 如果当前线程池不是Running</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; <span class="hljs-comment">// 除了RUNNING都有可能</span><br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// 任务为空</span><br>               ! workQueue.isEmpty())) <span class="hljs-comment">// 阻塞队列不为null</span><br>            <span class="hljs-comment">// 总的来说，返回false的情况</span><br>            <span class="hljs-comment">// - 当前线程池的状态不是Running</span><br>            <span class="hljs-comment">// - 如果是Shutdown就必须得保证队列中没有任务，或者firstTask不为null</span><br>            <span class="hljs-comment">// 因为如果是shutdown，可以新增线程处理队列中未完成的任务，但是不允许添加新的任务</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || <span class="hljs-comment">// 如果当前线程已经大于线程池最大容量就不去创建</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="hljs-comment">// wc是否超过核心线程或者最大线程</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="hljs-comment">// 使用CAS将工作线程数+1</span><br>                <span class="hljs-comment">// 如果添加成功了就可以去执行真正的添加逻辑了</span><br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl CAS失败</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs) <span class="hljs-comment">// 如果此时线程池的状态发生了改变，就重新执行外层的for循环</span><br>                <span class="hljs-comment">// 如果状态没有发生变化，就再次执行内部的for循环，也就是重新CAS</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/// 上述经过大量判断将工作线程数标识+1</span><br><span class="hljs-comment">// 开始执行真正的的添加线程逻辑</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 内部调用线程工厂创建线程</span><br>        <span class="hljs-comment">// this.thread = getThreadFactory().newThread(this);</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 使用全局锁</span><br>            <span class="hljs-comment">// private final ReentrantLock mainLock = new ReentrantLock();</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-comment">// 避免我添加任务时，其他线程干掉线程池，因为干掉线程池需要先获取这个锁。</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><span class="hljs-comment">// 如果线程池状态是Running或者</span><br>                <span class="hljs-comment">// 是shutdown并且当前任务为null，相当于shutdown状态下去处理队列中剩余的任务</span><br>                <span class="hljs-comment">// 只是没有判断队列是否为空了</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-comment">// 当线程start之后，线程的isAlive才会为true</span><br>                        <span class="hljs-comment">// 防止某些程序员在使用线程工厂创建线程返回之前就将线程给启动了</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w); <span class="hljs-comment">// 使用HashSet来保存所有的Worker</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start(); <span class="hljs-comment">// 启动线程</span><br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w); <span class="hljs-comment">// 添加线程失败逻辑</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w); <span class="hljs-comment">// 将当前线程从set中移除，因为线程启动失败了</span><br>        decrementWorkerCount(); <span class="hljs-comment">// 内部使用CAS + 自旋来保证成功</span><br>        tryTerminate(); <span class="hljs-comment">// 尝试将线程池的状态变为terminate</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><p>如果遇见了添加线程失败的时候，就尝试一下，看看是否需要终止掉线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 1. 当前线程池状态为Running</span><br>        <span class="hljs-comment">// 2. 在TIDYING及以上，说明有其他的线程正在执行从</span><br>        <span class="hljs-comment">// 3. 或者处于SHUTDOWN且工作队列不为null 特殊情况，得等到等待队列中的任务处理完</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 当前正在工作的线程不为0</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            <span class="hljs-comment">// 只中断一个？？？？</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">// 来到这里的，workCount为0，但是这个是提前减了的数量，</span><br>        <span class="hljs-comment">// 因此这个线程是最后一个线程</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 通过CAS来设置当前线程池运行状态为TIDYING并且活跃线程数为0</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 将状态设置为TERMINATED，工作线程为0</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Worker的封装"><a href="#Worker的封装" class="headerlink" title="Worker的封装"></a>Worker的封装</h3><p>线程池中，将线程都封装成一个个的Worker，而调用thread.start的时候，其实会调用Worker中重写好的run方法；</p><p><strong>同时，Worker还继承了AQS，自己实现相关AQS的相关接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    Runnable firstTask; <span class="hljs-comment">// 当前线程的第一个任务</span><br>    <span class="hljs-comment">// 每个线程的任务计数器</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>    Worker(Runnable firstTask) &#123;<br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 利用线程工厂创建线程</span><br>    &#125;<br><br>    <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 初始化当前worker的state为0（AQS中的state），并且设置exclusiveOwnerThread为null</span><br>    <span class="hljs-comment">// 因为在创建worker的时候，通过它的构造方法会将state设置为-1</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts 允许中断</span><br>    <span class="hljs-comment">// true表示发生异常退出，需要做一些处理，false是正常退出</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// getTask可能会阻塞线程</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// shutdown的时候会判断当前worker的状态，根据锁是否空闲来判断当前worker是否正在工作</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 1. 如果状态处于STOP、TIDYING、TERMINATION，给他中断信号</span><br>            <span class="hljs-comment">// 2. </span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task); <span class="hljs-comment">// 留给子类实现</span><br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// task可能是FutureTask也可能是Runnable实现类</span><br>                    task.run(); <span class="hljs-comment">// 执行任务</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown); <span class="hljs-comment">// 留给子类实现</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 回收线程</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><p>什么时候会返回null？</p><ol><li>线程池状态最低也是STOP状态</li><li>状态是shutdown，等待队列为空</li><li>线程池中的线程数量超过最大限制，会有一部分线程返回null</li><li>线程池中的线程数超过核心线程数，可能会有一部分线程超时，返回null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><span class="hljs-comment">// 到这里的时候，线程池的状态要么是running，要么是shutdown，但是队列不为空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><span class="hljs-comment">// allowCoreThreadTimeOut表示核心线程数内的线程也可以被回收</span><br>        <span class="hljs-comment">// 否则只能是超过核心线程数的那些线程才会被回收</span><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>       <span class="hljs-comment">// 如果timedOut为true表示上一次循环的时候，线程获取任务超时了</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// cas失败，可能是有别的线程先于它成功退出了，而可能再一次循环的时候，上面if的timed可能为false</span><br>            <span class="hljs-comment">// 于是该线程也可能不需要被回收了</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果该线程有超时回收机制，就使用poll（有超时限制），否则使用使用take（拿不到就一直阻塞）</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-comment">// 如果为null，就只能表示超时了，在下一次循环的时候应该退出，然后进行后续的回收</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><p>在runWorker中获取任务如果失败了，就会走这个逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        <span class="hljs-comment">// 如果是异常的退出</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w); <span class="hljs-comment">// 移除该worker</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    tryTerminate(); <span class="hljs-comment">// 根据线程池的状态判断是否结束线程池</span><br><br>    <span class="hljs-comment">// 担保机制，如果队列中还有任务，最起码还得留一个线程</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 如果 running或者shutdown</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123; <span class="hljs-comment">// 如果是正常退出</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">// 重新创建一个线程代替被销毁的线程</span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章-四种拒绝策略"><a href="#第四章-四种拒绝策略" class="headerlink" title="第四章 四种拒绝策略"></a>第四章 四种拒绝策略</h2><p><strong>拒绝策略需要实现RejectedExecutionHandler接口，并实现rejectedExecution方法</strong></p><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>默认的拒绝策略，其实内部啥也没做，只是抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>内部甚至连异常都懒得抛了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Does nothing, which has the effect of discarding task r.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>从队列中抛出最开始的任务，然后执行当前的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Obtains and ignores the next task that the executor</span><br><span class="hljs-comment">     * would otherwise execute, if one is immediately available,</span><br><span class="hljs-comment">     * and then retries execution of task r, unless the executor</span><br><span class="hljs-comment">     * is shut down, in which case task r is instead discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>直接使用当前线程去执行该任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span><br><span class="hljs-comment">     * has been shut down, in which case the task is discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-阻塞队列"><a href="#第五章-阻塞队列" class="headerlink" title="第五章 阻塞队列"></a>第五章 阻塞队列</h2><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><h4 id="基本概念及其使用"><a href="#基本概念及其使用" class="headerlink" title="基本概念及其使用"></a>基本概念及其使用</h4><p>DelayQueue是一个实现了BlockingQueue的无界阻塞队列，它<strong>存放的元素必须实现Delayed接口</strong>，同时也只能在它到期的时候才能够被取走。不支持null的存储。</p><p>作用：</p><ul><li>缓存的对象如果超过了空闲时间就从缓存中移除</li><li>对于超时任务的处理，比如网络编程中可以处理超时未响应的请求。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDelay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> delayedTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String taskName;<br><br>    <span class="hljs-comment">// 毫秒单位</span><br>    MyDelay(String taskName, <span class="hljs-type">long</span> delayedTime) &#123;<br>        <span class="hljs-built_in">this</span>.taskName = taskName;<br>        <span class="hljs-built_in">this</span>.delayedTime = System.currentTimeMillis() + delayedTime;<br>    &#125;<br>    <span class="hljs-comment">// 当前任务离过期时间还有多久</span><br>    <span class="hljs-comment">// 如果返回值小于等于0，表示该任务可以被取出了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(delayedTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>    &#125;<br><span class="hljs-comment">// 比较，在添加任务的时候会进行比较</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>        <span class="hljs-type">MyDelay</span> <span class="hljs-variable">myDelay</span> <span class="hljs-operator">=</span> (MyDelay)o;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(<span class="hljs-built_in">this</span>.delayedTime - myDelay.delayedTime);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyDelay&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;delayedTime=&quot;</span> + delayedTime +<br>            <span class="hljs-string">&quot;, taskName=&#x27;&quot;</span> + taskName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看DelayQueue的内部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueue</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Delayed</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt;();<br><br>    <span class="hljs-comment">// leader线程会去PriorityQueue堆的头部取任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">leader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Condition signalled when a newer element becomes available</span><br><span class="hljs-comment">     * at the head of the queue or a new thread may need to</span><br><span class="hljs-comment">     * become leader.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-x2F-put-x2F-offer"><a href="#add-x2F-put-x2F-offer" class="headerlink" title="add&#x2F;put&#x2F;offer"></a>add&#x2F;put&#x2F;offer</h4><p>向队列中添加元素，无论调用哪个方法，其实内部都是调用的offer方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        q.offer(e); <span class="hljs-comment">// 向堆里面添加元素</span><br>        <span class="hljs-keyword">if</span> (q.peek() == e) &#123; <span class="hljs-comment">// 如果是第一次添加或者直接添加到头部</span><br>            leader = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 将leader设置为null，然后唤醒其中一个等待的线程</span><br>            available.signal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek(); <span class="hljs-comment">// 如果堆里面没有元素可以取，就直接阻塞</span><br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 取出它的过期时间，就是我们重写的getDelay方法</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 说明该任务已经过期了，可以被消费</span><br>                    <span class="hljs-keyword">return</span> q.poll();<br>                <span class="hljs-comment">// 当前还无法被消费</span><br>                <span class="hljs-comment">// 防止长时间的等待导致内存泄漏</span><br>                <span class="hljs-comment">// 从这里开始就是leader-follower模式</span><br>                first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting </span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 只能让leader等待了</span><br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 让当前线程成为leader</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 阻塞堆头任务的过期时间</span><br>                        available.awaitNanos(delay);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 最终释放掉</span><br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>            available.signal(); <span class="hljs-comment">// 唤醒其他的线程去堆的头部拿任务</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/m0_37550986/article/details/126882839">(53条消息) DelayQueue（JDK1.8）—— take的源码分析_狂奔的蜗牛已被占用的博客-CSDN博客_delayqueue源码</a></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="0-线程池优点"><a href="#0-线程池优点" class="headerlink" title="0. 线程池优点"></a>0. 线程池优点</h3><ol><li><strong>线程复用</strong>：降低资源消耗，通过重复利用自己创建的线程降低线程创建和销毁造成的损耗</li><li><strong>提高响应速度：</strong>因为线程池中的线程数没有超过线程池的最大上限时，有的线程处于正在等待分配任务的状态，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>管理线程：</strong>提高线程的可管理性。使用线程池可以对线程进行统一分配、调优和监控。</li><li><strong>控制最大并发数</strong></li></ol><h3 id="1-线程池种类"><a href="#1-线程池种类" class="headerlink" title="1. 线程池种类"></a>1. 线程池种类</h3><ul><li><strong>newCachedThreadPool</strong>：线程池的大小不固定，可灵活回收空闲线程，若无可回收，则新建线程。****</li><li><strong>newFixedThreadPool</strong>：固定大小的线程池，当有新的任务提交，线程池中如果有空闲线程，则立即执行，否则新的任务会被缓存在一个任务队列中，等待线程池释放空闲线程。</li><li><strong>newScheduledThreadPool</strong>：定时线程池，支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor</strong>：只创建一个线程，它只会用唯一的工作线程来执行任务，保证所有任务按顺序指定执行。</li></ul><h3 id="2-线程池的拒绝策略"><a href="#2-线程池的拒绝策略" class="headerlink" title="2. 线程池的拒绝策略"></a>2. 线程池的拒绝策略</h3><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：默认的策略。即丢弃并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃任务，但是不抛出异常。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最前面的任务，然后重新提交被拒绝的任务，不抛出异常。</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务，不会丢弃任务，也不抛出异常。</li></ol><h3 id="3-线程池常见的阻塞队列"><a href="#3-线程池常见的阻塞队列" class="headerlink" title="3. 线程池常见的阻塞队列"></a>3. 线程池常见的阻塞队列</h3><ul><li><strong>ArrayBlockingQueue</strong>：是一个我们常用的典型的有界队列，其内部的实现是基于数组来实现的。</li><li><strong>LinkedBlockingQueue</strong>：由链表实现的队列，队列的长度是Integer.MAX_VALUE，基本上是可以任务是无界队列</li><li><strong>SynchronousQueue</strong>：是一个不存储任何元素的阻塞队列，每一个put操作都必须等待take操作，否则不能添加元素，同时它也支持公平锁和非公平锁。</li><li><strong>PriorityBlockingQueue</strong>：支持优先级排序的无界阻塞队列，插入的对象必须是可比较大小的，否则会报错</li><li><strong>DelayQueue</strong>：一个实现PriorityBlockingQueue的延迟获取的无界队列。具有延迟的功能。</li></ul><h3 id="4-线程池的运行原理"><a href="#4-线程池的运行原理" class="headerlink" title="4. 线程池的运行原理"></a>4. 线程池的运行原理</h3><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用execute方法添加一个请求任务时，线程池会做如下判断：<ol><li>如果正在运行的线程数小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数大于或等于corePoolSize，那么将这个任务放入队列</li><li>如果这时候队列满了且正在运行的线程数还小于maximumPoolSize，那么还是要创建非核心线程立即运行这个任务</li><li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li></ol></li><li>当一个线程完成任务时，他会从队列中取下一个任务执行</li><li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉</li></ol><h3 id="5-如何合理设置线程池的核心参数"><a href="#5-如何合理设置线程池的核心参数" class="headerlink" title="5. 如何合理设置线程池的核心参数"></a>5. 如何合理设置线程池的核心参数</h3><p>当线程池中核心线程数过大时，线程和线程之间会争夺CPU资源，会导致频繁上下文切换，过多的上下文切换会消耗CPU，增加线程的执行时间，影响了整体的执行效率。</p><p>当线程池中核心线程数过小时，如果同一时间有大量任务需要处理，可能会导致大量任务在任务队列中排队等待执行，甚至可能会执行拒绝策略，或者大量任务堆积在任务队列导致内存溢出OOM。</p><p>对于IO密集型（MySQL数据库、文件的读写、网络通信等任务）：<strong>线程数 &#x3D; CPU核数 * （1  + IO耗时 &#x2F; CPU耗时）</strong>或者<strong>CPU核数 * 2</strong>。可以理解为当线程A正在执行IO操作的时候，另外的IO&#x2F;CPU的线程数就可以执行完自己的CPU计算。因为这种情况任务最大线程数一般都会大于CPU核心数很多倍，因为IO读写速度相比于CPU的读写速度而言是比较慢的，如果我们设置过少的线程数就可能导致CPU资源的浪费，而如果我们设置更多的线程数，那么当一部分线程正在等待IO的时候，他们此时并不需要CPU来计算，那么另外的线程便可以利用CPU去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好的利用资源。</p><p>对于CPU密集型（加解密、压缩、计算）：<strong>CPU核数</strong>，这样可以充分利用所有CPU的核心。如果线程数远远超出了CPU核心数量，反而会使任务效率下降，因为频繁的切换线程也是需要消耗时间的（因为此时CPU每个核心几乎都是满负荷运行）。不过在工程上，<strong>线程数的数量一般会设置为CPU核数 + 1</strong>，这样的化，当线程因为偶尔的内存页失效或其它原因导致阻塞时，这个额外的线程可以顶上，从而保证CPU利用率。</p><p><strong>当然过少的线程会使整体性能降低，过多的线程也会消耗内存等其他资源，所以想要准确的话，可以进行压测，监控JVM的线程情况以及CPU的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</strong></p><p><strong>极端情况下当任务队列满了之后，继续增加非核心线程，直到达到最大线程数，那么效率其实会逐渐降低</strong></p><p>把握住一条原则：<strong>将硬件的性能发挥到极致</strong>，在实际场景中，IO耗时和CPU耗时的比值是一个关键参数，但这个参数其实是动态的，如果要估算这个参数，需要在各种不同的场景下压测来验证我们的估计。需要重点关注CPU、IO设备的利用率和性能指标（响应时间、吞吐量）之间的关系。</p><h3 id="6-为什么阿里不建议使用Executors创建线程池？"><a href="#6-为什么阿里不建议使用Executors创建线程池？" class="headerlink" title="6. 为什么阿里不建议使用Executors创建线程池？"></a>6. 为什么阿里不建议使用Executors创建线程池？</h3><ul><li>对于<strong>newFixedThreadPool和newSingleThreadExector</strong>来说，它们底层都是用的<strong>LinkedBlockingQueue</strong>，<strong>当添加任务的速度大于线程池处理任务的速度，可能会在队列堆积大量的请求，消耗很大的内存，甚至导致OOM。</strong></li><li>对于<strong>newCachedThreadPool和newScheduledThreadPool</strong>来说，它们的<strong>最大线程数都是Integer.MAX_VALUE</strong>；当添加任务的速度大于线程池处理任务的速度，可能会创建大量的线程，消耗资源，甚至导致OOM。</li></ul><h3 id="7-execute-amp-submit"><a href="#7-execute-amp-submit" class="headerlink" title="7. execute &amp; submit"></a>7. execute &amp; submit</h3><p>两个都是属于线程池中的方法。</p><ul><li>execute只能提交Runnable类型的任务；submit可以提交Runnable或Callable类型的任务</li><li>execute会直接抛出任务执行时的异常，submit不会，它可以通过Future的get方法将任务执行时的异常重新抛出</li><li>execute所属顶层接口是Executor，而submit是ExecutorService。实现类ThreadPoolExecutor重写了execute方法,抽象类AbstractExecutorService重写了submit方法。</li></ul><h3 id="8-能不能先创建非核心线程，再引入阻塞队列？"><a href="#8-能不能先创建非核心线程，再引入阻塞队列？" class="headerlink" title="8. 能不能先创建非核心线程，再引入阻塞队列？"></a>8. 能不能先创建非核心线程，再引入阻塞队列？</h3><p>按照正常流程， 当我们的核心线程数达到了之后，再有新的任务进来就会先放到阻塞队列中，直到阻塞队列满了创建非核心线程，那么能不能反过来呢？</p><p>不能，因为创建线程的代价其实是很大的，需要获取mainlock，因此能不创建线程就不创建线程，引入阻塞队列，等到核心线程数处理不过来的时候，才去考虑创建非核心线程。</p><h3 id="9-线程池复用原理"><a href="#9-线程池复用原理" class="headerlink" title="9. 线程池复用原理"></a>9. 线程池复用原理</h3><p>线程池将线程和任务进行解耦，在线程池中，同一个线程可以从阻塞队列中不断获取新的任务来执行，因为线程池中的线程是去执行一个循环任务，在循环里面不停检查阻塞队列中是否有任务需要被执行，如果有就直接执行，也就是调用任务中的run方法，将方法当成一个普通的方法执行。</p><h3 id="10-为什么使用阻塞队列？"><a href="#10-为什么使用阻塞队列？" class="headerlink" title="10. 为什么使用阻塞队列？"></a>10. 为什么使用阻塞队列？</h3><p>阻塞队列可以保证在任务队列中没有任务的时候阻塞获取任务的线程，线程进入wait状态，释放CPU资源。如果队列中有新的任务进来，就会唤醒线程来获取任务。</p><h3 id="11-线程执行中出现异常，线程池如何处理"><a href="#11-线程执行中出现异常，线程池如何处理" class="headerlink" title="11. 线程执行中出现异常，线程池如何处理"></a>11. 线程执行中出现异常，线程池如何处理</h3><ul><li><strong>如果使用的是execute，出现了未处理的异常，会直接打印堆栈异常的输出</strong></li></ul><p>源码中，其实就是在执行runWorker方法的时候，会调用task的run方法，如果出现了异常，就会将异常给抛出去，而线程池中其实并没有相关的处理这个抛出的异常的机制。</p><p>那么异常是如何被处理的？其实是在<strong>Java.lang.ThreadGroup的uncaughtException</strong>中处理的</p><p>当一个线程因为未捕获异常而即将终止的时候，JVM将使用Thread.getUncaughtExceptionHandler方法获取已经设置的Handler实例，并通过调用它的uncaughtException方法来处理相关的异常信息。如果线程并没有设置相关的handler，就将ThreadGroup作为它的handler，它会将异常进行打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>t.setUncaughtExceptionHandler(newThread.UncaughtExceptionHandler() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><strong>如果使用的是submit，不会显示的输出，而是将异常结果放到Future中，直到你去调用future.get方法</strong></li></ul><p>在底层，submit其实还是会调用execute方法，只不过它将传入的task给封装成FutureTask，并最终将该ft对象给返回。</p><p>而FutureTask对run方法也进行了重写，它内部最终会调用它的call方法，然后对于它抛出来的异常，会使用setException方法，将异常给保存下来。如果使用future.get方法，就会取得保存的异常，并最终打印出来。</p><ul><li><strong>对于出现了异常的线程，将会被回收，然后创建一个新的线程，不影响其他的线程任务。</strong></li></ul><p>在源码中，其实就是在执行runWorker方法的时候，finally最终会执行processWorkerExit方法，将当前出现异常的线程从workers中移除，然后创建一个新的线程，去队列中获取任务执行。</p><h3 id="12-线程是如何被销毁的？"><a href="#12-线程是如何被销毁的？" class="headerlink" title="12. 线程是如何被销毁的？"></a>12. 线程是如何被销毁的？</h3><p>我们都知道，线程池中的线程复用逻辑是通过一个for(;;)来做的，如果当前线程超过了最大线程数或者超过了核心线程数，并且它在超时时间之后其实都没有能够拿到任务，就会退出这个循环，然后会将当前的worker从HashSet中移除，然后真正的销毁逻辑其实是交给GC来做的。 </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解决父子线程中ThreadLocal无法传递数据的问题</title>
    <link href="/Java/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%ADThreadLocal%E6%97%A0%E6%B3%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/Java/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%ADThreadLocal%E6%97%A0%E6%B3%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="如何解决父子线程中ThreadLocal无法传递数据的问题"><a href="#如何解决父子线程中ThreadLocal无法传递数据的问题" class="headerlink" title="如何解决父子线程中ThreadLocal无法传递数据的问题"></a>如何解决父子线程中ThreadLocal无法传递数据的问题</h1><p>对于之前分析的 <code>ThreadLocal</code>，它虽然能做到数据的线程隔离，也就是不同的线程中存在不同的数据副本，然而，它却存在一个致命问题：无法在父子线程之间传递数据。因为子线程和父线程不是同一个线程，因此它们的数据副本也不会一样。</p><p>在 <code>Netty</code> 中的 <code>FastThreadLocal</code> 虽然以空间换时间的形式实现了自己的 <code>ThreadLocal</code>，能在自己的业务需求上提升一定的性能，但是它并没有解决上述问题。</p><h2 id="1-官方提供的-InheritableThreadLocal"><a href="#1-官方提供的-InheritableThreadLocal" class="headerlink" title="1. 官方提供的 InheritableThreadLocal"></a>1. 官方提供的 InheritableThreadLocal</h2><p><code>InheritableThreadLocal</code> 继承自 <code>ThreadLocal</code>，它的核心部分和 <code>ThreadLocal</code> 大差不差，主要是重写了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">// 传递什么参数就返回什么，如果想要这个方法有不同的行为，可以重写该方法</span><br>    <span class="hljs-comment">// 也就是我们可以利用这个在收到父线程传递过来的数据的时候，去做一些特殊的操作，</span><br>    <span class="hljs-comment">// 比如将数据进行修改，或者打印日志</span><br>    <span class="hljs-comment">// This method merely returns its input argument, </span><br>    <span class="hljs-comment">// and should be overridden if a different behavior is desired.</span><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">childValue</span><span class="hljs-params">(T parentValue)</span> &#123;<br>        <span class="hljs-keyword">return</span> parentValue;<br>    &#125;<br><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是通过这三个方法，让我们操控的时候，使用的是 <code>Thread</code> 中的另一个 <code>threadLocalMap</code> 属性，也就是 <code>inheritableThreadLocals</code>，而不是我们之前操控的 <code>threadLocals</code>。</p><p>同时，在 <code>new Thread</code> 的过程中，内部其实是通过复制父线程的 <code>inheritableThreadLocals</code> 来进行父子线程之间的数据传递功能，但是这样也造成了一个问题，那就是只有当父线程在创建子线程的过程中，才能数据传递。如果使用场景是线程池，对线程是复用的，并没有新建的操作，这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br>            <span class="hljs-built_in">this</span>.inheritableThreadLocals =<br>                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br></code></pre></td></tr></table></figure><h2 id="2-Alibaba-开源的-ttl"><a href="#2-Alibaba-开源的-ttl" class="headerlink" title="2. Alibaba 开源的 ttl"></a>2. Alibaba 开源的 ttl</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>transmittable-thread-local<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>TransmittableThreadLocal</code> 对于在线程池中的父子线程信息的传递而言，应用需要的实际上是把<strong>任务提交给线程池</strong>时的 <code>ThreadLocal</code> 值传递到<strong>任务执行时</strong>。</p><p><code>TTL</code> 的使用需要配合 <code>TtlRunnable</code> 和 <code>TtlCallable</code> 来修饰传入线程池的 <code>Runnable</code> 和 <code>Callable</code>。然而，<strong>即使时同一个 <code>Runnable</code>  任务多次提交到线程池的时候，每次提交的时候都需要通过修饰操作以抓取这次提交时的 <code>TTL</code> 上下文的值</strong>；即如果同一个任务下一次提交的时候不执行修饰而仍然使用上一次的 <code>TtlRunnable</code>，则提交的任务运行时会是之前修饰操作所抓取的上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">TransmittableThreadLocal&lt;String&gt; context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-comment">// 第一次提交</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTask</span>();<br>executorService.submit(TtlRunnable.get(task));<br><br><span class="hljs-comment">// ...业务逻辑代码，</span><br><span class="hljs-comment">// 并且修改了 TransmittableThreadLocal上下文 ...</span><br>context.set(<span class="hljs-string">&quot;value-modified-in-parent&quot;</span>);<br><br><span class="hljs-comment">// 再次提交</span><br><span class="hljs-comment">// 重新执行修饰，以传递修改了的 TransmittableThreadLocal上下文</span><br>executorService.submit(TtlRunnable.get(task));<br></code></pre></td></tr></table></figure><p>当然，也可以通过工具类 <code>TtlExecutors</code> 来对 <code>Executor</code>、<code>ExecutorService</code> 和 <code>ScheduledExecutorService</code> 进行修饰，省去每次的 <code>Runnable</code> 和 <code>Callable</code> 传入线程池时的修饰。具体的操作方法可以查看官网。</p><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><p>从大体上来说，<code>TTL</code> 主要是实现了自己的 <code>Runnable</code> ，在任务创建的时候将数据进行传递。</p><p>具体的源码分析可以在参考文献中进行查看。</p><h2 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3. 参考文献"></a>3. 参考文献</h2><p><a href="https://github.com/alibaba/transmittable-thread-local">alibaba&#x2F;transmittable-thread-local</a></p><p><a href="https://blog.csdn.net/u010833547/article/details/99647118">InheritableThreadLocal与阿里的TransmittableThreadLocal设计思路解析 by liangdu_Zuker</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>ThreadLocal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal和FastThreadLocal源码分析</title>
    <link href="/Java/ThreadLocal%E5%92%8CFastThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Java/ThreadLocal%E5%92%8CFastThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal总览"><a href="#ThreadLocal总览" class="headerlink" title="ThreadLocal总览"></a>ThreadLocal总览</h2><p>对于每个Thread实例对象，它内部都会有一个threadlocals字段，而该属性字段的类型其实就是ThreadLocal中的内部类ThreadLocalMap。它以ThreadLocal为key，同时使用开放定址法来解决哈希冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Entry[] table;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，ThreadLocalMap对ThreadLocal进行了虚引用，并且将其进行扩展，组成k-v键值对。</p><blockquote><p>虚引用的作用</p></blockquote><p>一般而言，一个ThreadLocal对象被创建出来之后，会被放到ThreadLocalMap中，如果使用的是线程池，那么Thread的生命周期很长，在ThreadLocal失去了它原本的强引用之后，还存在着Map对它的强引用，这可能就会造成内存泄漏</p><p>在我们实际开发中，都会初始化一个全局的static的ThreadLocal对象，因此一般而言该TL对象都会有一个外部的强引用指向它，因此此时在get或者set的时候的各种检查过期机制都不会生效，因为我的TL对象是存在强引用的，因为不会被GC掉，从而导致Entry中的key不会为null。</p><p>因此我们就必须去调用remove方法，它不仅会显示的将虚引用给断开，同时还会执行一次探测性清除，在这里面会将对应槽位的Entry设置为null，将它的value也设置为null。</p><p>如果使用的是全局的static的TL + 线程池的方式，那么调用remove更多的是防止之前的结果对后续的结果造成影响。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 对于threadlocal的实现来说，其实就是调用t.threadlocals;</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>); <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>在getEntry方法里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i]; <span class="hljs-comment">// 如果直接找到了，就返回</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 没找到</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getEntryAfterMiss"><a href="#getEntryAfterMiss" class="headerlink" title="getEntryAfterMiss"></a>getEntryAfterMiss</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 执行探测性清除</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span> <br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li>get的逻辑相对于简单，直接根据key计算出对应的槽位，如果是该key就直接返回；</li><li>如果不是，就往后遍历，如果发现了过期的key就执行探测性清除</li><li>如果找不到，就返回null</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述流程其实非常基本，我们继续往下看看set方法的详情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// 该hash的计算，其实是通过一个static 的 AtomicInteger nextHashCode 来计算的，</span><br>    <span class="hljs-comment">// 它每次调用的时候都会增加一个黄金分割数，也叫斐波拉契数，</span><br>    <span class="hljs-comment">// 这样子会让 key 的分布更加的均衡</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>); <span class="hljs-comment">// 计算该key在map中的哈希值，并且计算它的位置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果k为null了，就得执行清理工作，下面的就是核心方法</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123; <br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 上面的没有return掉，说明map中找不到该key，就直接插入在i位置吧</span><br>    <span class="hljs-comment">// 注意这个 i 位置会变化的，可能不是之前通过哈希值计算得到的位置</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-comment">// threshold一般为数组长度的三分之二</span><br>    <span class="hljs-comment">// 如果cleanSomeSlots没有清理一个</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>replaceStaleEntry</p><p>这是当set的时候发现了key为null的时候才会执行的方法，它会清理掉一些过期的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    Entry e;<br><span class="hljs-comment">// slotToExpunge表示它之前的槽位没有过期的entry，</span><br>    <span class="hljs-comment">// 当然这是建立在一段连续的槽位之中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot; <br>    <span class="hljs-comment">// 向前搜索</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 如果发现有entry的key为null，就记录好它的位置</span><br>            slotToExpunge = i;<br><span class="hljs-comment">// 开始向后搜索</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">// 如果在向后搜索的过程中，发现了存在set进来的key</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br><span class="hljs-comment">// 注意staleSlot对应的槽位其实是过期entry</span><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br><br>            <span class="hljs-comment">// 如果在向前搜索或者向后搜索的时候都没有发现过期的entry</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i; <span class="hljs-comment">// 说明i位置之前的连续槽位都没有过期entry</span><br>            <span class="hljs-comment">// 于是就得从它的后面开始查看</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果我们都没有找到对应的key，就直接放在一开始的过期entry的位置上吧</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><span class="hljs-comment">// 如果上述流程期间发现了过期entry，就进行清除</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="探测性清除expungeStaleEntry"><a href="#探测性清除expungeStaleEntry" class="headerlink" title="探测性清除expungeStaleEntry"></a>探测性清除expungeStaleEntry</h3><p>探测式清理，是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null 为止，才停止 rehash 计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot 进行当前位置的清理</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i; <span class="hljs-comment">// 向后进行清除，直到遇见entry为null</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">// 如果该位置过期了，就直接进行清除</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果没有过期，就将其移动到最靠近它的hash值所对应的槽位上</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启发式清除cleanSomeSlots"><a href="#启发式清除cleanSomeSlots" class="headerlink" title="启发式清除cleanSomeSlots"></a>启发式清除cleanSomeSlots</h3><p>试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素。当添加新元素或删除另一个过时元素时，将调用此函数。它执行对数扫描次数，作为不扫描（快速但保留垃圾）和与元素数量成比例的扫描次数之间的平衡，这将找到所有垃圾，但会导致一些插入花费O（n）时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        <span class="hljs-comment">// 如果发现了过期的entry，就执行一次探测性清除</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123;<br>            n = len; <span class="hljs-comment">// 将n给恢复成len</span><br>            removed = <span class="hljs-literal">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果没有发现过期entry的话，log(n)就结束了</span><br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br></code></pre></td></tr></table></figure><p>可以看到，当我们执行启发式清除的时候，如果没有发现可清除entry，并且此时的entry数量大于或等于数组长度的三分之二，就会进入rehash逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    expungeStaleEntries(); <span class="hljs-comment">// 做一次全量清理</span><br><br>    <span class="hljs-comment">// Use lower threshold for doubling to avoid hysteresis</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，rehash的时候一上来就做一次全量清理，也就是从数组的开始到结束，查询每个entry，如果它是过期的就进行一次探测性清除。</p><p>如果做完全量清理了发现数组的使用率在百分之五十以上，就会进入resize流程，进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li>先根据当前的线程，取到它内部的ThreadLocalMap属性，然后根据key计算它的初始位置</li><li>从当前位置一直往后遍历，直到访问到的槽位为空<ul><li>如果找到了相同的key就直接进行值的更新</li><li>如果发现了过期的key，就执行replaceStaleEntry方法<ul><li>先从当前位置staleSlot往前走，如果发现了过期的entry，就更新slotToExpunge的值，直到遇到了空的entry就停止</li><li>接着从staleSlot往后走，如果遇到了相同的key，就将key-value放入到staleSlot对应的槽上，然后将发现key对应的位置上的槽位值为过期槽位，也就是进行了一个交换，然后在return之前进行一次启发式清理</li><li>如果整个往后遍历都结束了，也就是遇到为空的entry，还没return，就直接在staleSlot处插入我们的k-v，然后再进行启发式清理</li></ul></li></ul></li><li>当上述流程遍历完之后都没有return，就将该key放置到经过开放定址法后的槽位当中</li><li>执行一遍启发式清理，如果没有可清理对象并且size大于len的三分之二，进行rehash</li><li>在rehash的时候，进行一次全量清理，清理之后如果size还是大于一半就进行扩容。</li></ul><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear(); <span class="hljs-comment">// 显式断开弱引用</span><br>            expungeStaleEntry(i); <span class="hljs-comment">// 探测性清除</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FastThreadLocal总览"><a href="#FastThreadLocal总览" class="headerlink" title="FastThreadLocal总览"></a>FastThreadLocal总览</h2><p>FTL是Netty写的一个轮子，它内部维护了一个索引常量index，每次创建FTL的时候都会自动加1，保证下标的不重复性，虽然会产生大量的index，但是避免了计算索引下标位置以及处理hash冲突带来的损耗。相当于以空间换取时间。</p><p>同时，如果想要使用FTL，就得结合FastThreadLocalThread线程类以及它的子类，Netty也提供了DefaultThreadFactory工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DefaultThreadFactory</span> <span class="hljs-variable">defaultThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(Test.class);<br>FastThreadLocal&lt;Integer&gt; fastThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> defaultThreadFactory.newThread(() -&gt; &#123;<br>    fastThreadLocal.set(<span class="hljs-number">1</span>);<br>    fastThreadLocal.get();<br>    fastThreadLocal.remove();<br>&#125;);<br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>以空间换时间，不需要通过TL的哈希值计算当前的下标，而是直接使用一个自增index</strong></li><li><strong>和TL用开放定址法解决哈希冲突不一样，FTL无需解决哈希冲突</strong></li><li><strong>TL扩容的时候需要rehash，而FTL并不需要</strong></li><li><strong>FTL就算结束不使用remove也不用担心内存泄漏，因为它自己在任务结束后调用removeAll方法</strong></li></ul><h3 id="FastThreadLocalRunnable"><a href="#FastThreadLocalRunnable" class="headerlink" title="FastThreadLocalRunnable"></a>FastThreadLocalRunnable</h3><p>我们上面说到，想要正确使用FTL，就必须结合FTLT线程类以及它的子类，同时构造FTLT的时候，也会通过FastThreadLocalRunnable对Runnable对象进行了包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用DefaultThreadFactory构建FastThreadLocalThread的时候，</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());<br></code></pre></td></tr></table></figure><p>而我们看看FastThreadLocalRunnable的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastThreadLocalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable runnable;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">FastThreadLocalRunnable</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = ObjectUtil.checkNotNull(runnable, <span class="hljs-string">&quot;runnable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            runnable.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            FastThreadLocal.removeAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">wrap</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">return</span> runnable <span class="hljs-keyword">instanceof</span> FastThreadLocalRunnable ? runnable : <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocalRunnable</span>(runnable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其实可以看到，它的run方法执行的时候，会自动的执行removeAll方法，这样其实就不需要我们显示的在方法执行完毕之后去调用FTL的remove方法，其实它的内部会自动的进行处理。</strong></p><h3 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h3><p>和普通的Thread对象一样，在FastThreadLocalThread中，也有一个Map用来存储FTL，而这个Map其实就是InternalThreadLocalMap。</p><p>InternalThreadLocalMap继承了UnpaddedInternalThreadLocalMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnpaddedInternalThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;InternalThreadLocalMap&gt;();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    <span class="hljs-comment">/** Used by &#123;<span class="hljs-doctag">@link</span> FastThreadLocal&#125; */</span><br>    Object[] indexedVariables;<br><br>    <span class="hljs-comment">// Core thread-locals</span><br>    <span class="hljs-type">int</span> futureListenerStackDepth;<br>    <span class="hljs-type">int</span> localChannelReaderStackDepth;<br>    Map&lt;Class&lt;?&gt;, Boolean&gt; handlerSharableCache;<br>    IntegerHolder counterHashCode;<br>    ThreadLocalRandom random;<br>    Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; typeParameterMatcherGetCache;<br>    Map&lt;Class&lt;?&gt;, Map&lt;String, TypeParameterMatcher&gt;&gt; typeParameterMatcherFindCache;<br><br>    <span class="hljs-comment">// String-related thread-locals</span><br>    StringBuilder stringBuilder;<br>    Map&lt;Charset, CharsetEncoder&gt; charsetEncoderCache;<br>    Map&lt;Charset, CharsetDecoder&gt; charsetDecoderCache;<br><br>    <span class="hljs-comment">// ArrayList-related thread-locals</span><br>    ArrayList&lt;Object&gt; arrayList;<br><br>    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;<br>        <span class="hljs-built_in">this</span>.indexedVariables = indexedVariables;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FastThreadLocal初始化"><a href="#FastThreadLocal初始化" class="headerlink" title="FastThreadLocal初始化"></a>FastThreadLocal初始化</h3><p>在FTL中，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">variablesToRemoveIndex</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.nextVariableIndex();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">// 位于FTL的父类中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FastThreadLocal</span><span class="hljs-params">()</span> &#123;<br>    index = InternalThreadLocalMap.nextVariableIndex();<br>&#125;<br><span class="hljs-comment">// 该方法位于InternalThreadLocalMap中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextVariableIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> nextIndex.getAndIncrement();<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>        nextIndex.decrementAndGet();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;too many thread-local indexed variables&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看，我们的FTL在类加载阶段，就会将variablesToRemoveIndex变量设置为0，然后将nextIndex变为1。同时，我们每次创建一个FastThreadLocal，都会给它一个索引index，初始值为1，每次加1。</p><p>而我们的数据其实是使用一个Object数组进行存储，因此，对于FastThreadLocal来说，<strong>数组的0号位置其实放的是一个存放了所有FastThreadLocal对象的Set，而从1到数组的结尾都是放的value值</strong></p><p><strong>而对于Object数组的初始化，其实就是给它们填充UNSET，也就是static的new Object</strong></p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>在get方法中，我们会拿到该线程对应的Map，<strong>关于FTL兼容TL的逻辑就在这里体现，后续我们再进行分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.get();<br>    <span class="hljs-comment">/*    </span><br><span class="hljs-comment">    public Object indexedVariable(int index) &#123;</span><br><span class="hljs-comment">        Object[] lookup = indexedVariables;</span><br><span class="hljs-comment">        return index &lt; lookup.length? lookup[index] : UNSET;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(index); <span class="hljs-comment">// 拿到该FTL对应的value</span><br>    <span class="hljs-keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123; <span class="hljs-comment">// 说明有值</span><br>        <span class="hljs-keyword">return</span> (V) v;<br>    &#125;<br><span class="hljs-comment">// 这一步会给当前FTL对应的数组中的位置设置为null</span><br>    <span class="hljs-keyword">return</span> initialize(threadLocalMap);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V value)</span> &#123;<br>    <span class="hljs-comment">// set进去的值不为默认值</span><br>    <span class="hljs-keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;<br>        <span class="hljs-comment">// 拿到当前线程的Map</span><br>        <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.get();<br>        <span class="hljs-comment">// 核心逻辑</span><br>        setKnownNotUnset(threadLocalMap, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果是默认值，就清理，可以将当前的FTL从Set中移除</span><br>        remove();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKnownNotUnset</span><span class="hljs-params">(InternalThreadLocalMap threadLocalMap, V value)</span> &#123;<br>    <span class="hljs-comment">// 如果设置成功了并且是第一次设置成功，也就是返回的值是true：oldValue == UNSET</span><br>    <span class="hljs-keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;<br>        <span class="hljs-comment">// 将FTL添加到Set中</span><br>        addToVariablesToRemove(threadLocalMap, <span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToVariablesToRemove</span><span class="hljs-params">(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(variablesToRemoveIndex);<br>    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;<br>    <span class="hljs-keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 创建Set</span><br>        variablesToRemove = Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());<br>        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;<br>    &#125;<br><span class="hljs-comment">// 将当前FTL给添加到Set中</span><br>    variablesToRemove.add(variable);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    remove(InternalThreadLocalMap.getIfSet());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(InternalThreadLocalMap threadLocalMap)</span> &#123;<br>    <span class="hljs-keyword">if</span> (threadLocalMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将当前FTL在Object数组中对应的index位置上的value设置为UNSET，并返回value</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.removeIndexedVariable(index);<br>    <span class="hljs-comment">// 从Object数组0号位置上的set中移除掉当前FTL</span><br>    removeFromVariablesToRemove(threadLocalMap, <span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            onRemoval((V) v); <span class="hljs-comment">// 可以自定义处理逻辑</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            PlatformDependent.throwException(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFromVariablesToRemove</span><span class="hljs-params">(</span><br><span class="hljs-params">    InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> &#123;<br><span class="hljs-comment">// 拿到数组0号位置上的Object</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(variablesToRemoveIndex);<br><br>    <span class="hljs-keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 将其转换为Set</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;<br>    variablesToRemove.remove(variable); <span class="hljs-comment">// 从Set中移除掉当前FTL</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.getIfSet();<br>    <span class="hljs-keyword">if</span> (threadLocalMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> threadLocalMap.indexedVariable(variablesToRemoveIndex);<br>        <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span> &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;<br>            <span class="hljs-comment">// 同样是拿到Set</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;<br>            <span class="hljs-comment">// 转换为数组</span><br>            FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =<br>                variablesToRemove.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocal</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;<br>                <span class="hljs-comment">// 挨个遍历去remove掉</span><br>                tlv.remove(threadLocalMap);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 移除掉当前线程所拥有的Map</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        public static void remove() &#123;</span><br><span class="hljs-comment">        Thread thread = Thread.currentThread();</span><br><span class="hljs-comment">        if (thread instanceof FastThreadLocalThread) &#123;</span><br><span class="hljs-comment">            ((FastThreadLocalThread) thread).setThreadLocalMap(null);</span><br><span class="hljs-comment">        &#125; else &#123;</span><br><span class="hljs-comment">            slowThreadLocalMap.remove();</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;   </span><br><span class="hljs-comment">        */</span><br>        InternalThreadLocalMap.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何兼容TL"><a href="#如何兼容TL" class="headerlink" title="如何兼容TL"></a>如何兼容TL</h3><p>我们在获取当前线程的FTL的时候，需要执行以下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.get();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InternalThreadLocalMap <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-keyword">if</span> (thread <span class="hljs-keyword">instanceof</span> FastThreadLocalThread) &#123;<br>        <span class="hljs-keyword">return</span> fastGet((FastThreadLocalThread) thread);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> slowGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果我们当前线程是FTLT，就执行fastGet，如果是普通的，就执行slowGet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接从FTLT中获取就行，如果没有就创建</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InternalThreadLocalMap <span class="hljs-title function_">fastGet</span><span class="hljs-params">(FastThreadLocalThread thread)</span> &#123;<br>    <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocalMap</span> <span class="hljs-operator">=</span> thread.threadLocalMap();<br>    <span class="hljs-keyword">if</span> (threadLocalMap == <span class="hljs-literal">null</span>) &#123;<br>        thread.setThreadLocalMap(threadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalThreadLocalMap</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> threadLocalMap;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InternalThreadLocalMap <span class="hljs-title function_">slowGet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 其实我们在InternalThreadLocalMap的父类中，有一个static final修饰的常量</span><br>    <span class="hljs-comment">// static final ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = new ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br>    <span class="hljs-comment">// 也就是一个ThreadLocal，它会保证每个线程都会有一份InternalThreadLocalMap</span><br>    <span class="hljs-comment">// 我们直接拿就行</span><br>    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;<br>    <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> slowThreadLocalMap.get();<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">null</span>) &#123;<br>        ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalThreadLocalMap</span>();<br>        slowThreadLocalMap.set(ret);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>ThreadLocal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/Java/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/Java/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>介绍一下HashMap</p></blockquote><p><strong>基本概念</strong>：HashMap基于哈希表的Map接口实现，以key-value形式存储，主要用来存放键值对。它的key和value都可以为null，但是只能存在一个为null的key，它的存放位置在Node&lt;K,V&gt;[] table的第0号位置上。同时HashMap是线程不安全的。</p><p><strong>底层结构</strong>：对于HashMap来说，它在1.8之前底层是由Node数组加上链表组成，链表主要是为了解决哈希冲突而是用的拉链法。而在1.8的时候，HashMap的底层由Node数组 + 链表 + 红黑树，当链表长度大于阈值（默认为8）并且当前数组的长度大于64的时候，将该索引位置上的所有数据都由链表改为红黑树存储。如果此时阈值大于8，但是数组长度不大于64，会选择进行数组扩容。这样做的目的就是因为数组较小的时候更容易出现红黑树结构，而红黑树的转换和保持平衡需要很大的消耗。</p><p><strong>扩容机制</strong>：默认大小是16，每次扩容都是两倍。当数组的长度大于threshold的时候（threshold &#x3D; capacity * loadFactor）就会进行resize，即扩容。</p><h2 id="三种构造器"><a href="#三种构造器" class="headerlink" title="三种构造器"></a>三种构造器</h2><blockquote><p>new HashMap()时做了什么？</p></blockquote><p>在1.8之前，创建HashMap对象之后，会在底层创建长度为16的一维数组Entry[ ] table。而在1.8之后，并没有在创建对象的时候将数组给创建出来，而是在首次调用put方法的时候，才会在底层创建默认长度为16的Node数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><br><span class="hljs-comment"> * (16) and the default load factor (0.75). JDK1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>new HashMap(int initialCapacity)</p></blockquote><p>一般而言，我们使用该构造器进行容量初始化的时候，如果我们传入的初始容量不是2的n次幂，那么HashMap会自动帮我们计算成一个相对合理值。但是这里还是会有一个小问题。</p><p>如果我们的HashMap只需要存放7个键值对，那么如果我们的initialCapacity设置为7，HashMap就会帮我们计算成8，可是注意的是，8 * 0.75 &#x3D; 6，它要大于7，因此其实HashMap就会有一次rehash的过程，而这个rehash其实是很损耗性能的。</p><p>因此一般我们的初始化容量应该设置为<strong>initialCapacity&#x2F;0.75 + 1</strong>，这样虽然可能牺牲一定的内容，但是能够最大程度的避免扩容带来的性能损耗。</p><blockquote><p>new HashMap(map)底层分析</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了putMapEntries方法：该方法可以被putAll调用，也可以被构造器调用，区别在于evict参数的不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// evict false when initially constructing this map, else true (relayed to method afterNodeInsertion).</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size 如果当前table还未初始化</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-keyword">if</span> (t &gt; threshold) <span class="hljs-comment">// 如果计算得到的t要比原map的threshold大</span><br>                <span class="hljs-comment">// 重新计算threshold为2的幂次方   比如 5 -&gt; 8. 15 -&gt; 16</span><br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize(); <span class="hljs-comment">// 扩容</span><br>        <span class="hljs-comment">// 挨个将参数中的m中的键值对给添加到集合中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么HashMap的初始化容量必须是2的n次幂？如果不是会怎么样？</p></blockquote><p>一般而言在对key计算它的存储位置的时候，是让它的hash值%length，即进行取余操作。而在取余操作中，如果除数是2的幂次方的话，就会：**hash%length &#x3D; hash &amp;(length - 1)**。使用二进制与的效率要比取余操作高。</p><p>同时，除了效率问题，这样还可以<strong>有利于均匀分布，减少碰撞</strong>。</p><p><strong>因为hash值始终在和一个大部分数字都为1的值做与运算</strong>，而在与运算中，如果一个数全为1，那么结果就会完全取决于另外一个数（这里指的是hash值），而一个良好的hash函数会导致不同对象的hash值几乎不相等。</p><p>如果不是会怎么样？</p><p><strong>当initialCapacity &gt; 2^30的时候，就让其等于2^30。如果大于0并且小于2^30，就扩充为2的n次幂。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">// 进行一些范围检查</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>规范初始容量的核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment">  返回临界值threshold</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这里cap要-1的原因：</span><br>    <span class="hljs-comment">// 如果此时cap本来就是2的幂次方，同时还未-1，经过下面的计算之后，返回的值会是该cap的两倍。</span><br>    <span class="hljs-comment">// 而按照我们的本意来说，如果是cap本来就是2的幂次方了，就不应该改变。</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// &gt;&gt;&gt; 无符号右移</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果cap为1，则n为0，经过一系列计算之后得到的结果仍然是0，则最后的threshold为1。</li></ul><p>上述tableSizeFor方法的位运算过程其实可以这么理解：我们只需要关注n的最高位的1。然后将其无符号右移一位之后，再与原值进行或操作，就会让其最高位拥有两个1。然后无符号右移两位，再与上一步的n进行或操作，最高位就拥有了4个1（当然不一定是4个，只是笼统的概括）</p><p>加入一开始cap是10，于是n为9，即1001。</p><p>n &#x3D; n | n &gt;&gt;&gt; 1；&#x3D;&#x3D;》 n &#x3D; 1001 | 0100 &#x3D; 1100；</p><p>n &#x3D; n | n &gt;&gt;&gt; 2；&#x3D;&#x3D;》 n &#x3D; 1100 | 0011 &#x3D; 1111; </p><p><strong>最后的结果是n + 1，而这个值赋给了threshold而不是初始容量！</strong></p><blockquote><p>为什么要引入红黑树？阈值为什么是8？</p></blockquote><p>JDK1.8之前HashMap底层是使用链表进行存储，但是即使哈希函数取得再好，也很难让key百分百均匀分布。当HashMap中有大量的元素都存放在同一个桶中，就会让链表变得很长，极端情况下，就可能导致HashMap的查找效率变成O(N)。因此引入红黑树来提升查找效率，O(logn)。</p><p>TreeNode占用的空间是普通Node的两倍，为了权衡空间和时间的消耗，<strong>只有当链表的值大于等于8的时候才会转换为红黑树。而当链表的值小于6的时候又会转换为链表。</strong></p><p>阈值是8的考虑就是源码注释中的，作者参考了泊松分布，在哈希函数良好的情况下，出现链表长度超过8的概率其实是极低的，几乎是不可能事件。因此很难会出现红黑树的转换，同时一旦转换了也容易提升效率。</p><blockquote><p>为什么加载因子设置为0.75？</p></blockquote><p>加载因子表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><blockquote><p>hash值的计算</p></blockquote><p>对于HashMap1.8之前来说，它的hash计算方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，经过了四次运算，效率比较低</p><p>而对于1.8来说，有了如下优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// key.hashCode方法调用的是本地native方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只经过了一次扰动。如果key为null，它的hash值应该为0。如果key不为null，将其hash值计算出来之后，让其和它的哈希值无符号右移16位之后的值进行一个异或操作。</p><p><strong>为什么要异或？</strong></p><p>如果数组的长度比较小，比如是16，那么n - 1就是 1111，这样的值和hash值做与操作，就只有第四位才会参与运算。而如果当哈希值计算的时候高位变化较大而低位变化较小的时候，就很容易造成哈希冲突。</p><p>而使用上述的异或操作，可以让计算出来的哈希值的高16位也能够参与运算，降低产生哈希冲突的概率。</p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>大致流程：</p><ol><li>计算key的hash值，然后根据hash值来判断该key应该映射到哪个桶。</li><li>如果该桶没有碰撞冲突，就直接插入</li><li>如果有冲突，看该冲突解决办法是红黑树还是链表。而且如果链表到达临界值，还会进行一个树化操作。</li><li>如果存在重复的键，就替换为新的value</li><li>如果size + 1之后大于threshold，就进行扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.put and related methods.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to put</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> previous value, or null if none</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// transient Node&lt;K,V&gt;[] table：表示存储Map集合中元素的数组</span><br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">    (tab = table) == null：将table赋值为tab，判断tab是否为null，如果是第一次调用put肯定为null</span><br><span class="hljs-comment">    或者如果tab的长度为0</span><br><span class="hljs-comment">    满足上述两个条件中的其中一个就可以进行数组的初始化。</span><br><span class="hljs-comment">    执行完resize之后，数组tab每个空间都是null</span><br><span class="hljs-comment">        */</span><br>        n = (tab = resize()).length;<br>    <br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果该key应该存放的位置所在的桶为null，就调用newNode方法</span><br>        <span class="hljs-comment">// 创建一个新节点放入桶中</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果桶不为null</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果该桶中的第一个元素的哈希值和参数相等，并且key也相等（地址或者equals）</span><br>        <span class="hljs-comment">// 就将旧的元素整体对象赋值为e，用e来记录</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 如果是红黑树</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 链表的形式存在 使用尾插法</span><br>            <span class="hljs-comment">// 采用循环遍历的方式，判断链表中是否有重复的key</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 为null表示没有下一个元素了，到达了链表尾部</span><br>                    <span class="hljs-comment">// 说明链表中没有重复的key，就插入到链表尾部</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// binCount为0，其实该链表已经存在一个节点了，就直接位于数组上。</span><br>                    <span class="hljs-comment">// 如果binCount为7，就表示链表长度为8，就转换为红黑树。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 说明在桶中找到了key值、hash值和插入元素相等的节点</span><br>        <span class="hljs-comment">// 将旧值变为新值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">// 返回旧值</span><br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 如果插入后的大小大于阈值，就进行扩容操作</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>对于put方法，如果是第一次调用，会进行一次resize操作，去初始化table。</p><p>之后的流程大概就是看key对应位置的桶有没有与其相等的key，如果有就替换旧值；如果没有：</p><ul><li>如果table[i] &#x3D;&#x3D; null，就直接new一个节点放进入</li><li>该桶是红黑树，就调用红黑树相应方法</li><li>如果是链表，遍历完整个链表之后都没有找到相等的key，就将key插入到链表的尾部，此时如果链表长度大于等于8，就进行树化。</li></ul><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>当HashMap中的元素个数超过threshold的时候，就会进行数组扩容；或者是第一次使用put方法的时候，也会调用一次resize方法</p><p>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</p><p>而每次调用resize方法之后，都会进行rehash过程：</p><p>在JDK1.8之前，HashMap的resize方法比较笨重，它会对Map中的每个键值对都进行rehash计算。效率很低。</p><p>在JDK1.8之后，HashMap的resize方法进行了优化。因为每次扩容都是翻倍，与原来计算的(n - 1) &amp; hash的结果相比只是多了一个bit位，所以<strong>节点要么在原来的位置，要么被分配到原位置 + 旧容量这个位置。</strong></p><p>因此我们在进行rehash的时候，不需要重新计算key的hash，只需要看原来的hash值新增的那个bit位是1还是0就可以了。如果是0表示索引不变，如果是1就表示索引变化。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length; <span class="hljs-comment">// 第一次进来的时候oldCap为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold; <span class="hljs-comment">// 第一次进来的时候threshold为0</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果扩容之前的map容量大小超过了最大值就不管了，只好继续碰撞</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 如果没有超过最大值，就扩充为原来的两倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 将老的阈值赋值给新的容量</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        <span class="hljs-comment">// 使用默认值---当第一次调用resize方法，会给默认值</span><br>        <span class="hljs-comment">// newCap为16，newThr为12</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap]; <span class="hljs-comment">// 第一次进来的时候初始化一个16大小的Node数组</span><br>    table = newTab;<br>    <span class="hljs-comment">// 进行元素的rehash过程</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 说明该桶中只有一个键值对</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 如果是红黑树，就使用红黑树相关的rehash过程</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// 链表来处理rehash过程</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 如果为true表示位置不变</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 否则位置要变化 + oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 该链表解决完毕，将处理后的两条链表分别插入到不同的地方</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>在第一次进入resize的时候，首先初始化threshold为默认值12，初始化容量为默认值16，然后创建一个大小为16的Node数组并直接返回，此时Node数组table中每个桶都是null。</p><p>后续每一次resize，都会将容量扩充为原来的两倍，并且也会重新计算新的threshold。之后创建一个是原来两倍大的新table数组。然后就会进行rehash操作。</p><p>在rehash的时候会依次遍历原table的每个桶，分为三种情况：</p><ul><li>如果桶中只有一个键值对，即它的next为null，就newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</li><li>如果桶是红黑树，就会调用其对应的rehash过程</li><li>如果桶是链表，就遍历整个链表，按照它rehash之后的位置分别插入到两条临时链表中，最后遍历完整个链表之后，就分别将两条临时链表插入到新数组对应的槽位中。</li></ul><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><blockquote><p>JDK7扩容造成死循环</p></blockquote><p>在JDK7的时候HashMap采用头插法，而它就可能在多线程并发情况下导致死循环。</p><p><strong>死循环发生在resize方法中的transfer方法中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 创建新的table</span><br>    Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            <span class="hljs-comment">// 获取e指向的Entry</span><br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            <span class="hljs-comment">// e指向扩容后的下标对应的newTable</span><br>            e.next = newTable[i];<br>            <span class="hljs-comment">// 将e放入数组中，头插法</span><br>            newTable[i] = e;<br>            <span class="hljs-comment">// 将next赋给e</span><br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>transfer方法作用：在对table进行扩容到newTable之后，需要将原来数据转移到newTable中，而转移过程中采用的是头插法，也就是链表的顺序会翻转，而这里就是形成死循环的关键点。</p><p>假如有两个线程AB同时进行并发扩容：</p><p><img src="1460000041299578.png" alt="image.png"></p><p>此时T1和T2都指向A，T1.next和T2.next都指向B节点。</p><p>线程T2的时间片用完了从而挂起，此时T1开始执行扩容操作，并顺利完成，则此时的状态如下图所示：</p><p><img src="1460000041299579.png" alt="image.png"></p><p>线程T2被唤醒，并开始执行后续的扩容操作，注意由于transfer中e最后要指向next，即A要指向B，因此就会发生死循环，A指向B，而B又指向A。</p><p><img src="1460000041299580.png" alt="image.png"></p><blockquote><p>同时JDK7时候的HashMap还可能造成数据丢失问题</p></blockquote><p>假如一开始节点如下图所示：</p><p><img src="webp.webp" alt="img"></p><p>线程A被挂起，此时e指向3，next指向5。线程B完成扩容：</p><p><img src="webp-16544154653205.webp" alt="img"></p><p>线程A继续扩容， 它会先将e指向的3放到newTable的正确的位置上，然后让e&#x3D;next，即e指向5。然后完成节点5的存放之后，发现e为null了，就结束本次扩容。此时就发现节点7丢失了。</p><blockquote><p>JDK8数据覆盖</p></blockquote><p>假如AB两个线程都在执行put操作，注意，在put操作中，如果table不为null，会先检查存入的key对应位置上的桶table[i]是否为null，假设AB两线程插入的两条不同的数据hash值一样，并且对应位置上的桶为null：</p><p>线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取时间片，此时线程A不用再进行hash判断了，此时线程A就会将线程B插入的数据给覆盖，线程不安全。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC进阶版</title>
    <link href="/Java/JUC%E8%BF%9B%E9%98%B6%E7%89%88/"/>
    <url>/Java/JUC%E8%BF%9B%E9%98%B6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="开篇-为什么要学习并发编程？"><a href="#开篇-为什么要学习并发编程？" class="headerlink" title="开篇 为什么要学习并发编程？"></a>开篇 为什么要学习并发编程？</h2><p>并发编程其实我们一直都在用，只是并发问题都被tomcat之类的中间件给解决了。除了处理网络问题之外，一些批处理为了提高性能也会用。主要看业务的并发量和数据量。有性能要求了，就自然而然需要技术支持。</p><h2 id="第一章-线程基础知识"><a href="#第一章-线程基础知识" class="headerlink" title="第一章 线程基础知识"></a>第一章 线程基础知识</h2><h3 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1 基础知识"></a>1.1 基础知识</h3><p><strong>1.1、为什么多线程及其重要？</strong></p><ol><li>硬件摩尔定律失效，在主频不再提高且核数在不断增加的情况下， 更想让程序更快就要用到并行或并发编程。</li><li>高并发系统，异步+回调等生产需求</li></ol><p><strong>1.2、从start一个线程说起</strong></p><ol><li>在java中，start一个线程，底层实际上是调用了c&#x2F;c++方法，也就是openjdk的实现，可以在<a href="http://openjdk.java.net/%E7%BD%91%E5%9D%80%E4%B8%8A%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82**openjdk8/hotspot/src/share/vm/runtime">http://openjdk.java.net/网址上下载源码。**openjdk8\hotspot\src\share\vm\runtime</a>**</li></ol><p><strong>1.3、Java多线程相关概念</strong></p><p><strong>进程</strong>：是程序的一次执行，是系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源。</p><p><strong>线程</strong>：在同一个进程内又可以执行多个任务，而这每一个任务我们就可以看作是一个线程。一个进程会有1个或多个线程的。</p><p><strong>管程</strong>：Monitor（监视器），也就是我们<strong>平时所说的锁</strong>。它其实是一种同步机制，它的义务就是保证同一时间只有一个线程可以访问被保护的数据和代码；JVM中同步是基于进入和退出监视器对象（Monitor，管程对象）来实现的，每个对象实例都会有一个Monitor对象。Monitor对象会和Java对象一同创建并销毁，它底层是C++语言来实现的。</p><p><strong>1.4、用户线程和守护线程</strong></p><p>Java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示为守护线程，false表示是用户线程。</strong></p><p>守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程。</p><p>用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。</p><p>重点：当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出；如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了，所以当系统只剩下守护线程的时候，java虚拟机会自动退出；<strong>设置守护线程，需要在start()方法之前进行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当main线程结束之后，a线程立马结束。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in：\t&quot;</span><br>                           +(Thread.currentThread().isDaemon() ? <span class="hljs-string">&quot;守护线程&quot;</span>:<span class="hljs-string">&quot;用户线程&quot;</span>));<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br><br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;a&quot;</span>);<br>    a.setDaemon(<span class="hljs-literal">true</span>);<br>    a.start();<br><br>    <span class="hljs-comment">//暂停几秒钟线程</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot; ----task is over&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-ArrayList"><a href="#1-2-ArrayList" class="headerlink" title="1.2 ArrayList"></a>1.2 ArrayList</h3><p>众所周知，ArrayList是线程不安全的，那么请举个例子表示它是线程不安全的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>            System.out.println(list);<br>        &#125;,String.valueOf(i)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>出现故障<strong>java.util.ConcurrentModificationException</strong>，原因就是并发中各线程互相争抢修改导致。</p><p>解决方案：</p><ol><li><p>new Vector&lt;&gt;( );</p><p>矢量队列，能解决线程安全问题，源码中的add方法被synchronized同步修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ++<span class="hljs-built_in">this</span>.modCount;<br>    <span class="hljs-built_in">this</span>.add(e, <span class="hljs-built_in">this</span>.elementData, <span class="hljs-built_in">this</span>.elementCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个类已经过时了，同时效率较低</p></li><li><p>Collections工具类</p><p>该集合工具类中提供了方法synchronizedList来保证list是同步安全的，同时set和map都可以用这个来确保安全</p></li><li><p>CopyOnWriteArrayList</p><p>相当于线程安全的arraylist，是一个可变数组</p><p>1、最适合于以下特征的应用程序：List大小通常很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突</p><p>2、线程是安全的</p><p>3、通常需要复制整个基础数组，所以可变操作的开销很大</p><p>4、迭代器支持hasNext、next等不可变操作，但是不支持remove等操作</p><p>5、使用迭代器遍历的速度很快，并且不会与其他线程发生冲突</p><p>当我们往一个容器添加元素的时候，不直接往当前容器里面添加，而是先将容器复制一份，然后再在新的容器里面添加元素，添加完之后再将原来的容器的引用指向新的容器</p><p>也就是<strong>读写分离和写时复制技术</strong>，能保证线程安全，但是因为读和写不是对应的同一份数据，因此可能会读到脏数据</p><p>JDK8源码如下（后序的JDK版本可能会稍有不同）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> &#123;<br>    array = a;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>Set</strong></p><p>HashSet也是不安全的，同样可以用Collections里的工具类，也可以用CopyOnWriteArraySet，但是注意的是，CopyOnWriteArraySet底层用的是CopyOnWriteArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an empty set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArraySet</span><span class="hljs-params">()</span> &#123;<br>    al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;E&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>而且HashSet的底层用的是HashMap，进行添加操作的时候，只关系map的key，也就是该添加的元素，至于value的话就是一个Object类常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p><strong>Map</strong></p><p>HashMap没有CopyOnWriteArrayMap，而是用的ConcurrentHashMap</p><h3 id="1-3-公平锁、非公平锁、可重入锁、递归锁、自旋锁谈谈你的理解？请手写一个自旋锁"><a href="#1-3-公平锁、非公平锁、可重入锁、递归锁、自旋锁谈谈你的理解？请手写一个自旋锁" class="headerlink" title="1.3 公平锁、非公平锁、可重入锁、递归锁、自旋锁谈谈你的理解？请手写一个自旋锁"></a>1.3 公平锁、非公平锁、可重入锁、递归锁、自旋锁谈谈你的理解？请手写一个自旋锁</h3><p><strong>公平锁和非公平锁</strong></p><p>公平锁：多个线程按照申请锁的顺序来获取锁，类似于排队打饭；在并发环境中，每个线程在获取锁的时候会先查看此锁维护的等待队列，如果为空， 或者当前线程是等待队列的第一个公平锁，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</p><p>非公平锁：是指在多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取到锁，在高并发的情况下，有可能造成优先级反转或者饥饿现象（线程一直抢不到锁，一直等待）；非公平锁比较粗鲁，一上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</p><p>并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁；</p><p>对于synchronized而言，也是一种非公平锁</p><p><strong>可重入锁（递归锁）</strong></p><p>指的是同一线程外层函数获得锁之后，内存递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>，可以用于<strong>避免死锁问题</strong>。就类似于获得了房子的总钥匙，再进其余的房间就不需要锁了</p><p>ReentrantLock和synchronized就是一个典型的可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        get();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\tget&quot;</span>);<br>            set();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\tset&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 可重入锁(也叫做递归锁)</span><br><span class="hljs-comment"> * 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码</span><br><span class="hljs-comment"> * 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> veliger@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-04-12 23:36</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReenterLockDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Thread-0 get</span><br><span class="hljs-comment">     * Thread-0 set</span><br><span class="hljs-comment">     * Thread-1 get</span><br><span class="hljs-comment">     * Thread-1 set</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(phone);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(phone);<br>        t3.start();<br>        t4.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自旋锁</strong></p><p>是指尝试获取锁的线程不会立即阻塞，而是<strong>采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU，上面讲的CAS就是用到了自旋锁（spinlock）</p><p>手写自旋锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dlf.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题目：实现一个自旋锁</span><br><span class="hljs-comment"> * 自旋锁的好处：循环比较获取直到成功为止，没有类似wait的阻塞</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，</span><br><span class="hljs-comment"> * B随后进来后发现当前有线程持有锁，不是null，</span><br><span class="hljs-comment"> * 所以只能通过自旋等待，直到A释放锁后B随后抢到</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> dlf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-12-13:16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span> &#123;<br><br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在自旋&quot;</span>);<br>            mySleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myUnLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked myUnLock()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            mySleep(<span class="hljs-number">5</span>);<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;AA&quot;</span>).start();<br><br>        mySleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            mySleep(<span class="hljs-number">1</span>);<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;BB&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mySleep</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(time);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">AA     come in</span><br><span class="hljs-comment">BB     come in</span><br><span class="hljs-comment">BB     正在自旋</span><br><span class="hljs-comment">BB     正在自旋</span><br><span class="hljs-comment">BB     正在自旋</span><br><span class="hljs-comment">BB     正在自旋</span><br><span class="hljs-comment">AA     invoked myUnLock()</span><br><span class="hljs-comment">BB     invoked myUnLock()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>独占锁（写）、共享锁（读）、互斥锁</strong></p><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p><p>共享锁：指该锁可被多个线程所持有；对ReentrantReadWriteLock其读锁是共享锁，写锁是独占锁</p><p>读锁的共享锁可保证并发读是非常高效的， 读写、写读、写写的过程都是互斥的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dlf.test;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资源类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCaChe</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保证可见性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">reentrantReadWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        reentrantReadWriteLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t正在写入&quot;</span> + key);<br>            <span class="hljs-comment">//模拟网络延时</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            map.put(key, value);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t正在完成&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            reentrantReadWriteLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        reentrantReadWriteLock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t正在读取&quot;</span>);<br>            <span class="hljs-comment">//模拟网络延时</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> map.get(key);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t正在完成&quot;</span> + result);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            reentrantReadWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearCaChe</span><span class="hljs-params">()</span> &#123;<br>        map.clear();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量</span><br><span class="hljs-comment"> * 读取共享资源应该可以同时进行</span><br><span class="hljs-comment"> * 但是</span><br><span class="hljs-comment"> * 如果有一个线程想去写共享资源来  就不应该有其他线程可以对资源进行读或写</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 小总结:</span><br><span class="hljs-comment"> * 读 读能共存</span><br><span class="hljs-comment"> * 读 写不能共存</span><br><span class="hljs-comment"> * 写 写不能共存</span><br><span class="hljs-comment"> * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> veliger@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-04-13 0:45</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyCaChe</span> <span class="hljs-variable">myCaChe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCaChe</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myCaChe.put(temp + <span class="hljs-string">&quot;&quot;</span>, temp);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myCaChe.get(finalI + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-CountDownLatch、Cyclic-Barrier、Semaphore用过吗？"><a href="#1-4-CountDownLatch、Cyclic-Barrier、Semaphore用过吗？" class="headerlink" title="1.4 CountDownLatch、Cyclic Barrier、Semaphore用过吗？"></a>1.4 CountDownLatch、Cyclic Barrier、Semaphore用过吗？</h3><p><strong>1、CountDownLatch</strong></p><p>让一些线程阻塞直到另外一些完成后才被唤醒，CountDownLatch主要有两个方法，当一个或多个线程  调用await方法时，调用线程会被阻塞，其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        closeDoor();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeDoor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;上完自习&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch.await();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;班长锁门离开教室&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、CyclicBarrier</strong></p><p>CyclicBarrier的字面意思是可循环(Cyclic) 使用的屏障(barrier).它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞,知道最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程才会继续干活,线程进入屏障通过CyclicBarrier的await()方法.</p><p>及其七颗龙珠就能召唤神龙，和CountDownLatch恰好相反</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CyclicBarrier cyclicBarrier=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">7</span>,()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>             System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 收集到第&quot;</span>+ temp +<span class="hljs-string">&quot;颗龙珠&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、Semaphore</strong></p><p>信号量的主要用户有两个目的，一个是用于多和共享资源的相互排斥使用，另一个用于并发资源数的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> veliger@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-04-13 11:08</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//模拟3个停车位</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//模拟6部汽车</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//抢到资源</span><br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t抢到车位&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停3秒离开车位&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//释放资源</span><br>                    semaphore.release();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-阻塞队列"><a href="#1-5-阻塞队列" class="headerlink" title="1.5 阻塞队列"></a>1.5 阻塞队列</h3><p><img src="image-20210918141447740.png" alt="image-20210918141447740"></p><p>上图所示，线程1往阻塞队列中添加元素，线程二从队列中移除元素</p><p>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</p><p>当阻塞队列是满时，往队列中添加元素的操作将会被阻塞</p><p><strong>有什么好处？</strong></p><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即线程阻塞），一旦条件满足，被挂起的线程会被自动唤醒。使用阻塞队列后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为阻塞队列都给你一手包办好了。</p><p><strong>核心方法</strong></p><p><img src="image-20210918141837176.png" alt="image-20210918141837176"></p><table><thead><tr><th align="center">分类</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">抛出异常</td><td align="center">当阻塞队列满时,再往队列里面add插入元素会抛IllegalStateException: Queue full<br/>当阻塞队列空时,再往队列Remove元素时候回抛出NoSuchElementException<br/>element()检查队列是否为空及队首元素是谁 NoSuchElementException</td></tr><tr><td align="center">特殊值</td><td align="center">插入方法,成功返回true 失败返回false<br/>移除方法,成功返回元素,队列里面没有就返回null</td></tr><tr><td align="center">一直阻塞</td><td align="center">当阻塞队列满时,生产者继续往队列里面put元素,队列会一直阻塞直到put数据or响应中断退出<br/>当阻塞队列空时,消费者试图从队列take元素,队列会一直阻塞消费者线程直到队列可用.</td></tr><tr><td align="center">超时退出</td><td align="center">当阻塞队列满时,队列会阻塞生产者线程一定时间,超过后限时后生产者线程就会退出</td></tr></tbody></table><p>​    <strong>种类分析</strong></p><ol><li><p><strong>ArrayBlockingQueue</strong>: 由数组结构组成的有界阻塞队列.</p></li><li><p><strong>LinkedBlockingQueue</strong>: 由链表结构组成的有界(但大小默认值Integer&gt;MAX_VALUE)阻塞队列</p></li><li><p>PriorityBlockingQueue:支持优先级排序的无界阻塞队列.</p></li><li><p>DelayQueue: 使用优先级队列实现的延迟无界阻塞队列.</p></li><li><p><strong>SynchronousQueue</strong>:不存储元素的阻塞队列,也即是单个元素的队列.</p><p>与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronousQueueDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put 1&quot;</span>);<br>                blockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put 2&quot;</span>);<br>                blockingQueue.put(<span class="hljs-string">&quot;2&quot;</span>);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put 3&quot;</span>);<br>                blockingQueue.put(<span class="hljs-string">&quot;3&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + blockingQueue.take());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + blockingQueue.take());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + blockingQueue.take());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;BBB&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>LinkedTransferQueue:由链表结构组成的无界阻塞队列.</p></li><li><p>LinkedBlocking<strong>Deque</strong>:由了解结构组成的双向阻塞队列.</p></li></ol><p><strong>用在哪里？</strong></p><p>生产者消费者模式、线程池、消息中间件</p><p>传统版生产者消费者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span>  Exception &#123;<br>        lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//1.判断</span><br>                <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//等待，不能生产</span><br>                    condition.await();<br>                &#125;<br>                <span class="hljs-comment">//2.干活</span><br>                number++;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>                <span class="hljs-comment">//3.通知唤醒</span><br>                condition.signalAll();<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//减</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span>  Exception &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//1.判断</span><br>            <span class="hljs-keyword">while</span> (number == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//等待，不能生产</span><br>                condition.await();<br>            &#125;<br>            <span class="hljs-comment">//2.干活</span><br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+number);<br>            <span class="hljs-comment">//3.通知唤醒</span><br>            condition.signalAll();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 传统的消费者和生产者Demo</span><br><span class="hljs-comment"> * 题目：一个初始值为零的变量，两个线程对其交替操作，一个加一个减一，来五轮</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">ProdConsumer_TraditionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span> ; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareData.increment();<span class="hljs-comment">//增加</span><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;AAA&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span> ; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareData.decrement();<span class="hljs-comment">//减</span><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;BBB&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞队列版生产者消费者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">FLAG</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//默认开启，进行生产+消费</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;<br>        <span class="hljs-built_in">this</span>.blockingQueue = blockingQueue;<br>        System.out.println(blockingQueue.getClass().getName());<br>    &#125;<br><br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MyProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> retValue ; <span class="hljs-comment">//默认是false</span><br><br>        <span class="hljs-keyword">while</span> (FLAG) &#123;<br>            <span class="hljs-comment">//往阻塞队列填充数据</span><br>            data = atomicInteger.incrementAndGet()+<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//等于++i的意思</span><br>            retValue = blockingQueue.offer(data,<span class="hljs-number">2L</span>, TimeUnit.SECONDS);<br>            <span class="hljs-keyword">if</span> (retValue)&#123; <span class="hljs-comment">//如果是true，那么代表当前这个线程插入数据成功</span><br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t插入队列&quot;</span>+data+<span class="hljs-string">&quot;成功&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//那么就是插入失败</span><br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t插入队列&quot;</span>+data+<span class="hljs-string">&quot;失败&quot;</span>);<br>            &#125;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果FLAG是false了，马上打印</span><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t大老板叫停了，表示FLAG=false,生产结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MyConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (FLAG) &#123; <span class="hljs-comment">//开始消费</span><br>            <span class="hljs-comment">//两秒钟等不到生产者生产出来的数据就不取了</span><br>            result = blockingQueue.poll(<span class="hljs-number">2L</span>,TimeUnit.SECONDS);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == result || result.equalsIgnoreCase(<span class="hljs-string">&quot;&quot;</span>))&#123; <span class="hljs-comment">//如果取不到数据了</span><br>                FLAG = <span class="hljs-literal">false</span>;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 超过两秒钟没有取到数据，消费退出&quot;</span>);<br>                System.out.println();<br>                System.out.println();<br>                <span class="hljs-keyword">return</span>;<span class="hljs-comment">//退出</span><br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t消费队列数据&quot;</span>+result+<span class="hljs-string">&quot;成功&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//叫停方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-built_in">this</span>.FLAG = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProdConsumer_BlockQueueDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">MyResource</span> <span class="hljs-variable">myResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyResource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                myResource.MyProd();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Prod&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);<br>            System.out.println();<br>            System.out.println();<br>            <span class="hljs-keyword">try</span> &#123;<br>                myResource.MyConsumer();<br>                System.out.println();<br>                System.out.println();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Consumer&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>        System.out.println();<br>        System.out.println();<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;5秒钟时间到，大bossMain主线程叫停，活动结束&quot;</span>);<br>        myResource.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-synchronized和Lock的区别"><a href="#1-6-synchronized和Lock的区别" class="headerlink" title="1.6 synchronized和Lock的区别"></a>1.6 synchronized和Lock的区别</h3><p><strong>synchronized</strong></p><ol><li>synchronized是JVM层面，它是JAVA的关键字</li><li>synchronized是不需要手动释放锁，当synchronized代码执行完以后，系统会自动让线程释放对锁的占用</li><li>synchronized不能中断，除非是抛出了异常或者是正常执行完成</li><li>synchronized是非公平锁</li><li>synchronized不支持精确唤醒，只能随机唤醒或者是唤醒全部线程</li></ol><p><strong>lock</strong></p><ol><li>Lock是API层面的具体类，它是java5以后新出的一个类</li><li>lock就需要手动去释放锁，若没有主动的去释放锁，就可能导致死锁的现象</li><li>lock是可以中断的，主要是设置超时的方法，</li><li>lock默认是非公平锁，但是也支持公平锁</li><li>lock可支持精确唤醒</li></ol><p><strong>Lock可以支持绑定多个Condition，进行精确唤醒，并且还可中断Lock</strong></p><hr><p>1、synchronized关键字</p><p>是java中的关键字，是一种同步锁，它可以修饰代码块和方法、静态方法、类。</p><p>虽然可以使用synchronized来定义方法，但是它并不属于方法定义的一部分，因此它不能被继承。如果父类中的某个方法使用了该关键字，而在子类中覆盖了该方法，在子类中的这个方法默认是不同步的，而必须显示地在子类的这个方法上添加该关键字。当然还可以在子类方法中调用父类相应的方法，这样虽然子类中的方法不是同步的，但是子类调用了父类的同步方法，因此子类的方法相当于同步了</p><p>但是对于synchronized关键字来说，获取锁的线程由于要等待IO或者其他原因被阻塞了，但是又没有释放锁，其他线程便只能等待，会影响程序的执行效率。这个时候就需要一种机制不让等待的线程一直无限期的等待下去，通过Lock可以办到</p><p> 2、Lock</p><p>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。他们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象</p><p> 3、区别</p><p>Lock不是java语言内置的，synchronized是java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问</p><p> synchronized不需要用户去手动释放锁，而Lock必须要用户手动释放，不然可能会导致出现死锁的现象</p><p> synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平（两种都可，在创建锁的时候设置）</p><p> 4、Lock接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> var1, TimeUnit var3)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1）lock（）</p><p>用来获取锁，如果锁已经被其它线程获取，则进行等待。一般来说，lock方法必须在try catch块中进行，并且将锁释放的操作放在finally中进行，以保证锁一定被释放，防止死锁的发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Lock lock-….;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock(); <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2）newCondition</p><p>关键字synchronized与wait()&#x2F;notify()这两个方法一起使用可以实现等待&#x2F;通知模式，Lock锁的newContition方法返回Condition对象，也可以实现该模式</p><p>用notify通知时，JVM会随机唤醒某个等待的线程，使用Condition类可以进行选择性通知，常用的两个方法</p><ul><li>await（）：使当前线程等待，同时释放锁，当其他线程调用signal（）时，线程会重新获得锁并继续执行</li><li>signal（）：用于唤醒一个等待的线程</li></ul><p>在调用这两个方法前，需要线程持有相关的Lock锁，调用await后线程会释放这个锁，在singal调用后会从当前Condition对象的等待队列中，唤醒一个线程，唤醒的线程尝试获取锁，一旦获得锁成功就继续执行</p><hr><h3 id="1-7-线程间通信"><a href="#1-7-线程间通信" class="headerlink" title="1.7 线程间通信"></a>1.7 线程间通信</h3><p><strong>一般判断部分要使用循环，防止虚假唤醒（因为唤醒的时候从哪里wait就从哪里开始唤醒，如果是用if进行判断，就会绕过if判断，因此需要循环判断）</strong></p><p>1、线程间通信的模型有两种：共享内存和消息传递，以下方式都是基于这两种模型来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一步 创建资源类，定义属性和操作方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//创建Lock</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//+1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//上锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断</span><br>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            <span class="hljs-comment">//干活</span><br>            number++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; :: &quot;</span>+number);<br>            <span class="hljs-comment">//通知</span><br>            condition.signalAll();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//解锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//-1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;<br>                condition.await();<br>            &#125;<br>            number--;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; :: &quot;</span>+number);<br>            condition.signalAll();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Share</span> <span class="hljs-variable">share</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Share</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    share.incr();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;AA&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    share.decr();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;BB&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、线程间定制化通信：A线程打印5次，B线程打印10次，C线程打印15次，按照顺序循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一步 创建资源类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareResource</span> &#123;<br>    <span class="hljs-comment">//定义标志位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1 AA     2 BB     3 CC</span><br><br>    <span class="hljs-comment">//创建Lock锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//创建三个condition</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//打印5次，参数第几轮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print5</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//上锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断</span><br>            <span class="hljs-keyword">while</span>(flag != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">//等待</span><br>                c1.await();<br>            &#125;<br>            <span class="hljs-comment">//干活</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; :: &quot;</span>+i+<span class="hljs-string">&quot; ：轮数：&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//通知</span><br>            flag = <span class="hljs-number">2</span>; <span class="hljs-comment">//修改标志位 2</span><br>            c2.signal(); <span class="hljs-comment">//通知BB线程</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印10次，参数第几轮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print10</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(flag != <span class="hljs-number">2</span>) &#123;<br>                c2.await();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; :: &quot;</span>+i+<span class="hljs-string">&quot; ：轮数：&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//修改标志位</span><br>            flag = <span class="hljs-number">3</span>;<br>            <span class="hljs-comment">//通知CC线程</span><br>            c3.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印15次，参数第几轮</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print15</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(flag != <span class="hljs-number">3</span>) &#123;<br>                c3.await();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">15</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; :: &quot;</span>+i+<span class="hljs-string">&quot; ：轮数：&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//修改标志位</span><br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//通知AA线程</span><br>            c1.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShareResource</span> <span class="hljs-variable">shareResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareResource</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print5(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;AA&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print10(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;BB&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print15(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;CC&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-Callable接口"><a href="#1-8-Callable接口" class="headerlink" title="1.8 Callable接口"></a>1.8 Callable接口</h3><ol><li><p>可以获取线程的返回结果</p></li><li><p>为实现Callable接口，需要实现在完成时返回结果的call方法，而且call方法可以引发异常，run不能</p></li><li><p>Future接口：</p><ol><li>当call方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程的返回结果，因此就需要Future对象，实现该接口需要重写五个方法</li><li><code>public boolean cancel(boolean mayInterrupt)</code>：用于停止任务，如果尚未启动任务它将停止任务。如果已经启动则仅在mayInterrupt为true时才会中断任务</li><li><code>public Object get()</code>：用于获取任务的结果，如果任务完成， 它将立即返回结果；否则等任务完成后再返回结果</li><li><code>public boolean isDone()</code>：如果任务完成返回true，否则返回false</li></ol></li><li><p>FutureTask：可以通过为其构造函数提供Callable来创建FutureTask。然后将FutureTask对象提供给Thread的构造函数以创建Thread对象</p></li><li><p>重点：</p><ol><li>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程，可以把这些作业交给Future对象在后台完成</li><li>当主线程将来需要时，可以通过Future对象获得后台作业的计算结果或者执行状态</li><li>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</li><li>仅在计算完成时才能检索结果，如果计算尚未完成，则阻塞get方法</li><li>一旦计算完成，就不能再重新开始或取消计算</li><li>get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后回返回结果或抛出异常</li><li>get只计算一次，因此get方法放到最后</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Callable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-comment">//FutureTask</span><br>        FutureTask&lt;Integer&gt; futureTask1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallableImpl</span>());<br><br>        <span class="hljs-comment">//lam表达式</span><br>        FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in callable&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;<br>        &#125;);<br><br>        <span class="hljs-comment">//创建一个线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask1,<span class="hljs-string">&quot;mary&quot;</span>).start();<br><br>        <span class="hljs-comment">//调用FutureTask的get方法</span><br>        System.out.println(futureTask1.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>并发导致Callable接口的出现，主要是用Callable能够实现当多个任务执行当中，若有一个任务完成的耗时时间比较长，那么可以先将其他任务先完成然后等待这个耗时比较长的任务结束后一起进行总的计算。futureTask.get()操作应该放在最后，不然在计算完之前会导致阻塞强行等到计算完成。<strong>如果同一个FutureTask创建了多个线程，只会执行一次</strong></p><h2 id="第三章-谈谈Java锁事"><a href="#第三章-谈谈Java锁事" class="headerlink" title="第三章 谈谈Java锁事"></a>第三章 谈谈Java锁事</h2><h3 id="3-1-乐观锁和悲观锁"><a href="#3-1-乐观锁和悲观锁" class="headerlink" title="3.1 乐观锁和悲观锁"></a>3.1 乐观锁和悲观锁</h3><p><strong>悲观锁</strong>：</p><ol><li>适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>显示的锁定之后再操作同步资源。</li><li>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取的时候会先加锁，确保数据不会被别的线程修改</li><li>synchronized关键字和Lock的实现类都是悲观锁。</li></ol><p><strong>乐观锁</strong></p><ol><li>乐观锁认为自己在使用数据的时候不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</li><li>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。</li><li>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋实现的。</li><li>适合读操作多的场景，不加锁的特点能使读操作的性能大幅提升。</li><li>也可以通过版本号的机制实现。</li></ol><h3 id="3-2-Java8锁事"><a href="#3-2-Java8锁事" class="headerlink" title="3.2 Java8锁事"></a>3.2 Java8锁事</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<span class="hljs-comment">//资源类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;-------sendEmail&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSMS</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;-------sendSMS&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;-------hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123; <span class="hljs-comment">//一切程序的入口，主线程</span><br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<span class="hljs-comment">//资源类1</span><br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<span class="hljs-comment">//资源类2</span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            phone.sendEmail();<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-comment">//暂停毫秒</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//phone.sendSMS();</span><br>            <span class="hljs-comment">//phone.hello();</span><br>            phone2.sendSMS();<br>        &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220124111743340.png" alt="image-20220124111743340"></p><p>其实就是考的sync锁的是对象还是整个类，就会明白了这个。</p><ul><li>作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</li><li>作用于代码块，对括号里配置的对象加锁。</li><li>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</li></ul><h3 id="3-3-反编译查看synchronized实现"><a href="#3-3-反编译查看synchronized实现" class="headerlink" title="3.3 反编译查看synchronized实现"></a>3.3 反编译查看synchronized实现</h3><p><strong>1、反编译同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (objecctLock) &#123;<br>        System.out.println(<span class="hljs-string">&quot;------hello synchronized&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220124115730172.png" alt="image-20220124115730172"></p><p>可以看到，synchronized实际上使用的是monitorenter和monitorexit两个指令，但是可以看到，上述的代码，两者居然不配对，这是因为得sync的底层会保证该锁最后一定会被释放。</p><p>可以手动给m1方法抛出异常</p><p><img src="image-20220124121354189.png" alt="image-20220124121354189"></p><p><strong>2、反编译普通同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220124121515897.png" alt="image-20220124121515897"></p><p>可以看到，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。</p><p>如果设置了，执行线程会先持有monitor然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor。</p><p><strong>3、反编译静态同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220124121848015.png" alt="image-20220124121848015"></p><p>ACC_STATIC, ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法</p><p><strong>4、什么是管程monitor</strong></p><p><strong>面试题：</strong>synchronized实现原理，monitor对象什么时候生产的？知道monitor的monitorenter和monitorexit吗？这两个是怎么保证同步的，或者说，这两个操作计算机底层是如何执行的？</p><p><strong>为什么任何一个对象都可以成为一个锁？</strong></p><p>管程（Monitors，也称为监视器）是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。（把信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，他是<strong>将共享的变量和对于这些共享变量的操作封装起来</strong>，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p><p>方法级的同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，<strong>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</strong>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><ol><li>管程是一种概念，任何语言都可以通用</li><li>在Java中，每个加锁的对象都绑定着一个管程</li><li>线程访问加锁对象，就是去拥有一个管程的过程。比如病人去医院看病，就得去找医生（公共资源），但是医生在门里面，想要访问医生，就必须拥有进入门诊室的资格（管程）。</li><li>所有线程想要访问共享资源，都必须先去拥有管程。</li><li>管程就是一个对象监视器，任何线程想要访问该资源，就要排队进入监控范围。进入之后接受检查。不符合条件就会继续等待，直到被通知，然后继续进入监视器。</li></ol><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p><p><strong>5、C++源码解读</strong></p><p>在HotSpot虚拟机中，monitor采用ObjectMonitor实现。</p><p>objectMonitor.hpp文件中：</p><p><img src="image-20220128211625979.png" alt="image-20220128211625979"></p><table><thead><tr><th>属性名称</th><th>作用</th></tr></thead><tbody><tr><td>_owner</td><td>指向持有ObjectMonitor对象的线程</td></tr><tr><td>_WaitSet</td><td>存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td>存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td>锁的重入次数</td></tr><tr><td>_count</td><td>用来记录该线程获取锁的次数</td></tr></tbody></table><p>每个对象都对应一个monitor对象，在hotspot虚拟机中它是由ObjectMonitor实现的。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系存在很多种实现方式，比如monitor可以和对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它变处于锁定状态。</p><p><strong>ObjectMonitor中有两个队列：WaitSet和EntryList，用来保存ObjectMonitor对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），owner指向持有当前ObjectMonitor对象的线程，当多个线程同时访问同一段同步代码块的时候，首先会进入EntryList集合，当线程获取到对象的monitor之后就会进入到owner区域，并把monitor中的owner变量设置为当前线程，同时将monitor中的计数器count加1。如果该线程调用wait方法，就会释放当前持有的monitor，owner变量就会恢复成null，count自减，同时该线程就会进入WaitSet集合中等待被唤醒。如果当前线程执行完毕之后也会释放monitor，并且复位变量的值，以便其它线程进入获取monitor。</strong></p><p><strong>如果当前synchronized是重量级锁，即锁标识位&#x3D;10，Mark word中会记录指向monitor对象的指针。</strong></p><p><strong>也就是说，其实每个对象天生都带有一个对象监视器；</strong></p><p><strong>所有对象内部都维护了一个状态，而java同步机制就是使用了对象中的状态作为了锁的标识</strong></p><h3 id="3-4-公平锁和非公平锁"><a href="#3-4-公平锁和非公平锁" class="headerlink" title="3.4 公平锁和非公平锁"></a>3.4 公平锁和非公平锁</h3><blockquote><p>可以参照尚硅谷面试题相关笔记</p></blockquote><p><strong>面试题</strong></p><ol><li>为什么会有公平锁和非公平锁&#x2F;为什么默认非公平锁？<ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU等待时间片，尽量减少CPU空闲时间。</li><li>使用多线程很重要的考量点就是线程切换的开销，当采用非公平锁时，<strong>当一个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销</strong></li></ul></li><li>使用非公平锁会有什么问题？<ul><li>公平锁保证了排队的公平性，非公平锁霸气的忽视了这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁</li><li>也就是锁饥饿</li></ul></li><li>什么时候使用公平锁？什么时候使用非公平锁？<ul><li>如果为了更高的吞吐量，选择非公平锁，因为节省很多线程切换时间，吞吐量自然就上去了</li><li>否则就使用公平锁，大家公平使用</li></ul></li></ol><h3 id="3-5-可重入锁"><a href="#3-5-可重入锁" class="headerlink" title="3.5 可重入锁"></a>3.5 可重入锁</h3><p>是指在同一个线程在外层方法获取到锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁对象是同一个对象），不会因为之前已经获取过还没释放而阻塞</p><p>可重入锁可以一定程度上避免死锁。</p><p><strong>synchronized的重入实现机理</strong></p><ul><li><strong>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针</strong></li><li>当执行monitorenter时，如果目标对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1.</li><li>在目标对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁</li><li>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1，计数器为零代表锁已被释放。</li></ul><h3 id="3-6-死锁"><a href="#3-6-死锁" class="headerlink" title="3.6 死锁"></a>3.6 死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源足够，进程的资源请求都能够得到满足，死锁出现的概率很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="image-20220128214911864.png" alt="image-20220128214911864"></p><p>原因：</p><ol><li>系统资源不足</li><li>进程运行的推进顺序不合适</li><li>资源分配不当</li></ol><p><strong>死锁case</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockCase</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 持有锁A，想要锁B&quot;</span>);<br><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁B成功&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;aa&quot;</span>);<br>        aa.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 持有锁B，想要锁A&quot;</span>);<br><br>                <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>                <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁A成功&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;bb&quot;</span>);<br>        bb.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ol><li>jps命令定位进程编号</li><li>jstack找到死锁查看</li></ol><h3 id="3-7-其他锁"><a href="#3-7-其他锁" class="headerlink" title="3.7 其他锁"></a>3.7 其他锁</h3><p>写锁（独占锁）&#x2F;读锁（共享锁）、自旋锁SpinLock</p><p>无锁 → 独占锁 → 读写锁 → 邮戳锁</p><p>无锁 → 偏向锁 → 轻量锁 → 重量锁</p><h3 id="3-8-【如何用一把锁保护多个资源？】"><a href="#3-8-【如何用一把锁保护多个资源？】" class="headerlink" title="3.8 【如何用一把锁保护多个资源？】"></a>3.8 【如何用一把锁保护多个资源？】</h3><p>有这么一个场景：银行业务中的转账操作，账户A减少100元，账户B增加100元，这两个操作是有关联性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>            <span class="hljs-built_in">this</span>.balance -= amt;<br>            target.balance += amt;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码一看就有问题，很容易出现并发问题。如何改进？直觉就是给transfer方法加上锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>            <span class="hljs-built_in">this</span>.balance -= amt;<br>            target.balance += amt;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意的是，此时虽然对转账方法加上了锁，但是临界区中是有两个资源的，分别是this.balance和target.balance，并且用的是同一把锁。不过注意的是，this这把锁可以保护自己的余额，但是保护不了别人的余额。</p><p>比如如果银行中有三个账户ABC，他们分别有200元的balance。但是此时线程1执行A转账100给B，线程2执行B转账100给C，按照正常情况，最终A剩余100元，B剩余200元，C剩余300元，但事实真的如此吗？</p><p>线程1读取到A的余额200，并且减去100，此时A为100，然后读取到B为200，并放到自己的内存空间中。此时线程2开始工作，它也读取到B为200，并且将其减去100，并且刷回主内存中，然后读取到C为200，添加100之后变成300。线程1继续开始执行，它发现自己的工作内存中B的值为200，然后加上100之后变成300并刷新会主内存，最终结果却出乎意料，A剩余100，B剩余300，C剩余300，凭空多出了100块！</p><p>为了解决这个问题，有两种方法：</p><ol><li>将Account无参构造器设置为private，并且暴露出一个有参构造器，这个构造器传入一个Object类型的lock，并且设置为Account重点private Object lock。这样的话如果我们在构造每一个Account的时候，只要传入的是同一个Object，他们加的就是同一把锁。但是这样其实不够优雅，因为如果不同的Account传入的是不同的Object，那么就直接炸了。</li><li>直接使用Account.class作为锁。但是这样所有的转账操作都是串行化的了，对效率肯定影响非常大！</li></ol><p>上面说到了，如果使用Account.class作为锁，这样会导致所有的操作都是串行化的。而在我们现实生活中，转账业务肯定是能够并行执行的，那么该如何编程实现呢？</p><p>首先可以想到我们使用两把锁来进行操作，我们可以先给转账方加锁，锁成功之后再给被转帐方加锁。这样就能将锁进一步细化，<strong>使用细粒度的锁可以提高并行度。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(target) &#123;<br>                <span class="hljs-built_in">this</span>.balance -= amt;<br>                target.balance += amt;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样降低了锁的粒度，但是同样也会造成新的问题：<strong>死锁</strong></p><p>比如线程1拿到了A的锁，同时线程2拿到了B的锁。与此同时线程1想要将A转账给B，就需要B的Account，而线程2想要将B转账给A，就需要A的Account，这就造成了死锁。</p><p><strong>1、破坏占有并等待条件】</strong>一次性申请完所需要的资源。</p><p>可以使用一个账户管理员，由它统一分配所有的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; als = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 一次性申请所有资源</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Object from, Object to)</span> &#123;<br>        <span class="hljs-keyword">if</span> (als.contains(from) || als.contains(to)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        als.add(from);<br>        als.add(to);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Object from, Object to)</span> &#123;<br>        als.remove(from);<br>        als.remove(to);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-comment">// actr为单例</span><br>    <span class="hljs-keyword">private</span> Allocator actr;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!actr.apply(<span class="hljs-built_in">this</span>, target));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 这里还需要加锁是因为可能会有其余的操作影响到共享变量balance造成并发问题</span><br>                <span class="hljs-comment">// 具体转账业务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            actr.free(<span class="hljs-built_in">this</span>, target);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、破坏不可抢占条件</strong></p><p>sycnchronized不可以做到这一点，因为它无法主动释放它占有的资源。但是可以使用Lock来做。</p><p><strong>3、破坏循环等待条件</strong></p><p>可以按照一定的顺序去申请资源，比如先申请id为小的再申请id为大的，这就可以避免死锁了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span> &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> target;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.id &gt; target.id) &#123;<br>            left = target;<br>            right = <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span>(left) &#123;<br>            <span class="hljs-keyword">synchronized</span>(right) &#123;<br>                <span class="hljs-comment">// 具体业务</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述讨论只是教我们可以往哪些方向去思考如何解决死锁问题，因为实际场景中肯定不会这么做，因为每次从数据库查出来的数据都不是同一个对象，一般实际中采用数据库事务加上乐观锁的方式解决。</p><p>同时我们注意到上面说的破坏占有并等待条件中，Account通过Allocator去同时申请所有的资源，是通过while循环去申请的，但是如果此时请求数非常大，就会导致CPU资源消耗非常严重。因此我们就可以使用<strong>等待-通知</strong>去优化我们的申请过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; als = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 一次性申请所有资源</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Object from, Object to)</span> &#123;<br>        <span class="hljs-keyword">while</span> (als.contains(from) || als.contains(to)) &#123;<br>            wait();<br>        &#125;<br>        als.add(from);<br>        als.add(to);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Object from, Object to)</span> &#123;<br>        als.remove(from);<br>        als.remove(to);<br>        notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意的是，我们应该尽量的使用notifyAll来实现通知机制，因为如果使用notify就可能导致某些线程永远不会被通知到。</p><h3 id="3-9-活锁和饥饿"><a href="#3-9-活锁和饥饿" class="headerlink" title="3.9 活锁和饥饿"></a>3.9 活锁和饥饿</h3><p><strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。</strong></p><p>可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“</p><p>等待一个随机时间”的方案虽然很简单，却非常有效，<strong>Raft</strong> 这样知名的分布式一致性算法中也用到了它。</p><p>比如上述的转装业务，双方同时为对方转账，同时进入第一个锁，但是发现获取不到第二个锁，于是释放，进入下一次循环，用的是Lock中的tryLock：比如线程1执行A向B转账，线程2执行B向A转账，线程1获取A的锁，然后想去获取B的锁，同时线程2获取了B的锁想去获取A的锁，发现都获取不到，因此同时释放自己已经获得了的锁，然后进入下一轮循环后又是这样，因此出现了活锁。</p><p><strong>所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。</strong></p><p>“不患寡，而患不均”，如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p><p>那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p><h3 id="3-10-建议"><a href="#3-10-建议" class="headerlink" title="3.10 建议"></a>3.10 建议</h3><p>第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如<strong>线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……</strong></p><p>第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，在1.7的时候使用到的分段锁，同时1.8的时候只锁数组中的一个节点；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><ol><li>永远只在更新对象的成员变量的时候加锁</li><li>永远只在访问可变的成员变量的时候加锁</li><li>永远不要在调用其它对象方法的时候加锁</li></ol><h2 id="第四章-LockSupport与线程中断"><a href="#第四章-LockSupport与线程中断" class="headerlink" title="第四章 LockSupport与线程中断"></a>第四章 LockSupport与线程中断</h2><h3 id="4-1-线程中断机制"><a href="#4-1-线程中断机制" class="headerlink" title="4.1 线程中断机制"></a>4.1 线程中断机制</h3><h4 id="4-1-1、阿里蚂蚁金服面试题"><a href="#4-1-1、阿里蚂蚁金服面试题" class="headerlink" title="4.1.1、阿里蚂蚁金服面试题"></a><strong>4.1.1、阿里蚂蚁金服面试题</strong></h4><p><img src="image-20220128220519739.png" alt="image-20220128220519739"></p><p><strong>如何停止、中断一个运行中的线程？</strong></p><h4 id="4-1-2、什么是中断？"><a href="#4-1-2、什么是中断？" class="headerlink" title="4.1.2、什么是中断？"></a><strong>4.1.2、什么是中断？</strong></h4><ul><li>首先一个线程不应该由其他线程赖强制中断或停止，而是应该由线程自己自行停止。所以Thread.stop, Thread.suspend, Thread.resume都已经被废弃了。</li><li>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制 — 中断</li><li><strong>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</strong></li><li>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设置为true；</strong>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现。</li><li>每个线程对象都有一个标识，用于表示该线程是否被中断；该标识位为true为中断，false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul><h4 id="4-1-3、中断的相关API"><a href="#4-1-3、中断的相关API" class="headerlink" title="4.1.3、中断的相关API"></a><strong>4.1.3、中断的相关API</strong></h4><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>public void interrupt()</td><td>实例方法，仅仅是设置线程的中断状态true，不会停止线程。</td></tr><tr><td>public static boolean interupted</td><td>静态方法，Thread.interrupted()；<br /><strong>判断线程是否被中断，并清除当前状态</strong><br />该方法做了两件事<br />1、<strong>返回当前线程的中断状态</strong><br />2、将当前线程的中断状态设置为false</td></tr><tr><td>public boolean isInterrupted</td><td>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h5 id="4-1-3-1-interrupt源码分析"><a href="#4-1-3-1-interrupt源码分析" class="headerlink" title="4.1.3.1 interrupt源码分析"></a>4.1.3.1 interrupt源码分析</h5><p><img src="image-20220128224551893.png" alt="image-20220128224551893"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread())<br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        <span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>            interrupt0();           <span class="hljs-comment">// Just to set the interrupt flag</span><br>            b.interrupt(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></td></tr></table></figure><p>如上图注释所示，如果该线程被wait、join、sleep方法给阻塞了，调用该方法就会爆出异常。</p><h5 id="4-1-3-2-isInterrupted源码分析"><a href="#4-1-3-2-isInterrupted源码分析" class="headerlink" title="4.1.3.2 isInterrupted源码分析"></a>4.1.3.2 isInterrupted源码分析</h5><p><img src="image-20220128225358749.png" alt="image-20220128225358749"></p><p>调用的是本地方法。</p><h4 id="4-1-4、如何使用中断标识停止线程"><a href="#4-1-4、如何使用中断标识停止线程" class="headerlink" title="4.1.4、如何使用中断标识停止线程"></a>4.1.4、如何使用中断标识停止线程</h4><p>在需要中断的线程中<strong>不断监听中断状态</strong>，一旦发生中断，就执行相应的中断处理业务逻辑。</p><h5 id="4-1-4-1-使用volatile来实现"><a href="#4-1-4-1-使用volatile来实现" class="headerlink" title="4.1.4.1 使用volatile来实现"></a>4.1.4.1 使用volatile来实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptDemp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isStop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thead</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (isStop) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程自己退出了&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot; ------ Hello Interrupt&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        isStop = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-4-2-通过AtomicBoolean"><a href="#4-1-4-2-通过AtomicBoolean" class="headerlink" title="4.1.4.2 通过AtomicBoolean"></a><strong>4.1.4.2 通过AtomicBoolean</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">atomicBoolean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(atomicBoolean.get()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----atomicBoolean.get() = true，程序结束。&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;------hello atomicBoolean&quot;</span>);<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-comment">//暂停几秒钟线程</span><br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        atomicBoolean.set(<span class="hljs-literal">true</span>);<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-4-3-使用Thread自带的api"><a href="#4-1-4-3-使用Thread自带的api" class="headerlink" title="4.1.4.3 使用Thread自带的api"></a>4.1.4.3 使用Thread自带的api</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;------hello Interrupt&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        t1.interrupt();<span class="hljs-comment">//修改t1线程的中断标志位为true</span><br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-5、当前线程的中断标识为true，是不是就立刻停止？"><a href="#4-1-5、当前线程的中断标识为true，是不是就立刻停止？" class="headerlink" title="4.1.5、当前线程的中断标识为true，是不是就立刻停止？"></a>4.1.5、当前线程的中断标识为true，是不是就立刻停止？</h4><p>具体来说，当对一个线程，调用interrupt时</p><ol><li>如果线程处于正常活动状态，那么会将该线程的中断标志设为true，<strong>仅此而已；被设置中断标志的线程将继续正常运行，不受影响。</strong>所以interrupt并不能真正的中断线程，需要被调用的线程自己进行配合才行。</li><li>如果线程处于被阻塞状态（例如处于sleep、wait、join等状态），在别的线程池中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//中断为true后，并不是立刻stop程序</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">300</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;------i: &quot;</span> + i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1.interrupt()调用之后02： &quot;</span>+Thread.currentThread().isInterrupted());<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    System.out.println(<span class="hljs-string">&quot;t1.interrupt()调用之前,t1线程的中断标识默认值： &quot;</span>+t1.isInterrupted());<br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>    <span class="hljs-comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span><br>    t1.interrupt();<br>    <span class="hljs-comment">//活动状态,t1线程还在执行中</span><br>    System.out.println(<span class="hljs-string">&quot;t1.interrupt()调用之后01： &quot;</span>+t1.isInterrupted());<br><br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">3000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>    <span class="hljs-comment">//非活动状态,t1线程不在执行中，已经结束执行了。</span><br>    System.out.println(<span class="hljs-string">&quot;t1.interrupt()调用之后03： &quot;</span>+t1.isInterrupted());<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">t1.interrupt<span class="hljs-params">()</span>调用之前,t1线程的中断标识默认值： <span class="hljs-literal">false</span><br><span class="hljs-params">------i</span>: 1<br><span class="hljs-params">------i</span>: 2<br><span class="hljs-params">------i</span>: 3<br><span class="hljs-params">------i</span>: 4<br><span class="hljs-string">......</span><br>t1.interrupt<span class="hljs-params">()</span>调用之后01： <span class="hljs-literal">true</span><br><span class="hljs-params">------i</span>: 209<br><span class="hljs-params">------i</span>: 210<br><span class="hljs-string">......</span><br><span class="hljs-params">------i</span>: 300<br>t1.interrupt<span class="hljs-params">()</span>调用之后02： <span class="hljs-literal">true</span><br>t1.interrupt<span class="hljs-params">()</span>调用之后03： <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>可以看到，该线程的标志位被设置为true，并没有立即退出线程</strong></p><p>再看下面一个案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m5</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                <span class="hljs-comment">//线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;------hello Interrupt&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>    <span class="hljs-comment">//修改t1线程的中断标志位为true</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t1::interrupt,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是<strong>sleep方法抛出异常后，中断标识也会被清空重置为false</strong>，我们在catch如果没有调用th.interrupt方法再次将中断标识设置为true，这就导致无限循环了。</p><p><img src="image-20220130212634934.png" alt="image-20220130212634934"></p><h4 id="4-1-6、小总结"><a href="#4-1-6、小总结" class="headerlink" title="4.1.6、小总结"></a>4.1.6、小总结</h4><p>中断只是一种协同机制，修改中断标识位而已，不是立即stop打断该线程。</p><h3 id="4-2-线程等待唤醒机制"><a href="#4-2-线程等待唤醒机制" class="headerlink" title="4.2 线程等待唤醒机制"></a>4.2 线程等待唤醒机制</h3><p>JUC中有三种线程等待唤醒机制：</p><ol><li>使用Object中的wait方法让线程等待，使用Object中的notify方法唤醒线程</li><li>使用JUC包中Condition的await方法让线程等待，使用signal方法唤醒线程</li><li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ol><h4 id="4-2-1、Object和Condition限制条件"><a href="#4-2-1、Object和Condition限制条件" class="headerlink" title="4.2.1、Object和Condition限制条件"></a>4.2.1、Object和Condition限制条件</h4><ol><li>线程必须先要获得并持有锁，必须在锁块（synchronized或lock）中</li><li>必须要先等待后唤醒，线程才能够被唤醒。</li></ol><h4 id="4-2-2、LockSupport"><a href="#4-2-2、LockSupport" class="headerlink" title="4.2.2、LockSupport"></a>4.2.2、LockSupport</h4><ul><li><strong>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</strong></li><li><strong>LockSupport中的park()和unpart（）的作用分别是阻塞线程和解除阻塞线程</strong></li><li>通过part()和unpark（thread）方法来实现阻塞和唤醒线程的操作</li><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可，permit只有两个值，1和0。可以把许可看成是一种（0，1）信号量（Semaphore），<strong>但是许可的累加上限是1</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LockSupport.park()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>    UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    setBlocker(t, blocker);<br>    UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    setBlocker(t, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>permit默认为0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后将permit再次设置为0并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>        UNSAFE.unpark(thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用unpark方法后，就会将thread线程的许可permit设置为1（注意多次调用unpark方法不会累加，permit值还是1）会自动唤醒thread线程，即之前阻塞中的LockSupport.part()方法会立即返回</p><p>如果先执行unpart，那么permit就会被设置为1，那么后面再执行park的时候，就相当于park方法不存在，形同虚设，因此不会产生阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;---come in&quot;</span>);<br>        LockSupport.park();<br>        LockSupport.park();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;---被唤醒&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-comment">// 这个示例会导致t1线程阻塞，原因如上面的话。</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.unpark(t1);<br>        System.out.println(<span class="hljs-string">&quot;发出第一条通知&quot;</span>);<br>        LockSupport.unpark(t1);<br>        System.out.println(<span class="hljs-string">&quot;发出第二条通知&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点说明</strong></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</p><p>LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupport调用的Unsafe中的native代码。</p><p>LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</p><p>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit，也就是将1变成0，同时park立即返回。</p><p>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。</p><p>每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累凭证。</p><p><strong>形象的理解</strong></p><p>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</p><p>当调用park方法时</p><ul><li>如果有凭证，则会直接消耗掉这个凭证然后正常退出;</li><li>如果无凭证，就必须阻塞等待凭证可用;</li></ul><p>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无效。</p><h4 id="4-2-3、LockSupport相关面试题"><a href="#4-2-3、LockSupport相关面试题" class="headerlink" title="4.2.3、LockSupport相关面试题"></a>4.2.3、LockSupport相关面试题</h4><p><strong>为什么可以先唤醒线程后阻塞线程</strong></p><p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞</p><p><strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></p><p>因为凭证的数量最多为1，连续调用两次unpark和调用一个unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证</p><h2 id="第五章-JMM内存模型"><a href="#第五章-JMM内存模型" class="headerlink" title="第五章 JMM内存模型"></a>第五章 JMM内存模型</h2><h3 id="5-1、相关面试题"><a href="#5-1、相关面试题" class="headerlink" title="5.1、相关面试题"></a>5.1、相关面试题</h3><ul><li>你知道什么是Java内存模型JMM吗</li><li>JMM与volatile它们两个之间的关系？</li><li>JMM有哪些特性或者它的三大特性是什么？</li><li>为什么要有JMM，它为什么出现？作用和功能是什么</li><li><strong>happens-before先行发生原则你有了解过吗？</strong></li></ul><h3 id="5-2-计算机硬件存储体系"><a href="#5-2-计算机硬件存储体系" class="headerlink" title="5.2 计算机硬件存储体系"></a>5.2 计算机硬件存储体系</h3><p>计算机存储结构，从本地磁盘到主存到CPU缓存，也就是从硬盘到内存，到CPU。一般对应的程序的操作就是从数据库查数据到内存中后到CPU进行计算。</p><p>CPU、内存、I&#x2F;O之间的速度差异导致一系列问题的发生，解决的办法就是在CPU和内存之间添加多级缓存、CPU和IO增加多线程并行处理、多核CPU等措施。</p><ol><li><strong>CPU增加了缓存，用来均衡和内存之间的速度差异【导致可见性】</strong></li><li><strong>操作系统添加了进程、线程，以时分复用CPU，进而均衡CPU和IO设备的速度差异。【导致原子性】</strong></li><li><strong>编译程序优化指令执行顺序，使得缓存能够得到更加合理地利用。【导致有序性】</strong></li></ol><p>高速缓存的出现是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据到来或把数据写入内存。在缓存中的数据是内存中的一小部分，但是这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可以先在缓存中调用，从而加快读取速度。</p><p>距离CPU最近的是三级高速缓存，L1最快，读取的是内存的100倍左右，可以理解为2-4个时钟周期（内存读取200-300时钟周期），L2是10-20个时钟周期左右，L1和L2是核心<strong>隔离</strong>的，L3为20-60时钟周期，是核心<strong>共享</strong>的，大小方面L1&lt;L2&lt;L3。而CPU缓存、寄存器以及内存也是JMM的硬件基础。</p><p><img src="a32472fe38386792db568898579c8a9ba8cad630.png@903w_917h_progressive.webp" alt="电脑CPU中的三级缓存是越大越好吗？三级缓存到底有什么用？"></p><ul><li><strong>一级缓存</strong>都内置在CPU内部并与CPU同速运行，可以有效的提高CPU的运行效率。一级缓存越大CPU的运行效率越高，但是受到CPU内部结构的限制，一级缓存的容量都很小。</li><li><strong>二级缓存</strong>是为了协调一级缓存和内存之间的速度。CPU调用缓存首先是一级缓存，当处理器的速度逐渐提升，会导致一级缓存供不应求，这样就得使用到二级缓存了。二级缓存它比一级缓存的速度相对来说会慢，但是它比一级缓存的空间容量要大。主要是做一级缓存和内存之间数据临时交换的地方用。</li><li><strong>三级缓存</strong>为了读取二级缓存后未命中的数据设计的一种缓存，在拥有三级缓存的CPU中，只有约5%的数据需要从内存中调用，这进一步提高了CPU的效率。原理其实就是如果二级缓存未命中，就去三级缓存中查找，如果三级缓存未命中再去内存中查找。</li></ul><p>因为有这么多级的缓存（CPU和物理主内存的速度不一致的），<strong>CPU的运行并不是直接操作内存，而是先把内存里边的数据读到缓存</strong>，而内存的读和写操作的时候就会造成不一致的问题，比如<strong>一致性、可见性、原子性等问题</strong></p><p><img src="image-20220201223742035.png" alt="image-20220201223742035"></p><p>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，简称JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="5-3-JMM相关基本概念"><a href="#5-3-JMM相关基本概念" class="headerlink" title="5.3 JMM相关基本概念"></a>5.3 JMM相关基本概念</h3><p>Java内存模型，Java Memory Model，简称JMM，本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范。通过规范定制了程序各个变量（包括实例字段、静态字段和构成数组对象的元素）的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术都是围绕多线程的<strong>原子性、可见性和有序性</strong>展开的。</p><p><strong>原则</strong>：JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的</p><p><strong>能干嘛</strong></p><ol><li>通过JMM来实现线程和主内存之间的抽象关系</li><li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li></ol><h3 id="5-4-三大特性"><a href="#5-4-三大特性" class="headerlink" title="5.4 三大特性"></a>5.4 三大特性</h3><p>JMM关于同步规定：①、线程解锁前， 必须把共享变量​的值刷新回主内存；②、线程加锁前， 必须读取主内存的最新值到自己的工作内存；③、加锁解锁是同一把锁</p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>（电脑装的内存条，硬件）中，主内存是共享内存区域，所有线程都可以访问，<strong>但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存中，不能直接操作主内存中的变量</strong>，各个线程中的工作内存储着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，此案成间的通讯（传值）必须通过主内存来完成</p><p><img src="image-20210911143513939.png" alt="image-20210911143513939"></p><p><strong>1、JMM可见性</strong></p><p>通过前面对JMM的介绍，我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存中，操作后再写回主内存中的。</p><p>这就可能存在一个线程AAA修改了共享变量X的值，还未写回主内存中时，另外一个线程BBB又对内存中的一个共享变量X进行操作，但此时AAA线程工作内存中的共享变量X对BBB来说并不可见，这种工作内存与主内存同步延迟现象就造成了<strong>可见性的问题</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IncreaseTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add10k</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx++ &lt; <span class="hljs-number">10000</span>) &#123;<br>            count += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">IncreaseTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IncreaseTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test::add10k);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(test::add10k);<br>        t1.start();<br>        t2.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        System.out.println(test.count + <span class="hljs-string">&quot;==========&gt;finally result&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>就比如上述代码，如果两个线程同时对同一个变量进行操作，就会导致出现可见性问题，最终输出的count的值是一万到两万之间的值。</p><p>因此就必须要有一种机制，<strong>只要有一个线程修改完自己的工作内存中的值，并写回给主内存以后要及时通知其他线程，这种即时通知就是JMM中的可见性。</strong></p><p>代码示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&#123;<br><br>    <span class="hljs-comment">//volatile就是增强了主线程和线程的可见性</span><br>    <span class="hljs-keyword">volatile</span>  <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTO60</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.number = <span class="hljs-number">60</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.验证volatile的可见性</span><br><span class="hljs-comment"> *  1.1 假如int number = 0; number变量之前没有添加volatile关键字修饰，没有可见性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">MyData</span> <span class="hljs-variable">myData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyData</span>();<span class="hljs-comment">//线程操作资源类</span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t come in&quot;</span>);<br>            <span class="hljs-comment">//线程暂停3秒钟</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>            <span class="hljs-comment">//3秒钟以后将把0改为60</span><br>            myData.addTO60();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t updated number value:&quot;</span>+myData.number);<br>        &#125;,<span class="hljs-string">&quot;AAA&quot;</span>).start();<br><br>        <span class="hljs-comment">//第二个线程就是我们的main线程</span><br>        <span class="hljs-keyword">while</span> (myData.number == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//main主线程就一直在这里等待循环，直到number不再等于零</span><br>        &#125;<br>        <span class="hljs-comment">//若这句话打印出来了，说明main主线程感知到了number的值发生了变化，那么此时可见性就会被触发</span><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t mission is over,main get number value:&quot;</span>+myData.number);  <span class="hljs-comment">//这个是main线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AAA线程拿到副本进行操作，几乎同时主线程也拿到了number的副本进行while循环，当AAA三秒之后将number修改为60，随后写入内存中，但是此时主线程还是使用自己的内存空间中的number副本，因此循环继续。</p><p>如果给while语句前面添加上延迟时间，保证while拿到数据的时候AAA线程已经完成了修改并写入主内存，那么while拿到的就是number修改之后的值</p><p><strong>2、JMM原子性</strong></p><p>什么是原子性？其实就是看最终一致性能不能保证。不可分割、完整性。即某个线程正在做某个业务的时候，中间不可以被加塞或者被分割，需要整体完整。</p><p>在以前的操作系统，是基于进程来调度CPU的，但是不同进程之间是不共享内存空间的，所以进程要做任务切换就需要切换内存映射地址，而<strong>一个进程创建的所有的线程都是共享一个内存空间的，所以线程做内存切换的成本就很低了</strong>。现代的操作系统都基于更加轻量的线程来调度，所以“任务切换”都是指“线程切换”。</p><p><strong>正是这种线程间的切换，导致了并发编程中的诡异BUG出现，也就是没有保证原子性</strong></p><p>JMM要求保证原子性，但是volatile是不保证原子性的。</p><p><img src="image-20210911180726641.png" alt="image-20210911180726641"></p><p>number++在多线程的情况下是非线程安全的，除了加synchronized以外，还能通过AtomicInteger来解决。</p><p>为什么number++无法保证线程安全？因为很多值在putfield这步写回主内存的时候可能线程的调度被挂起了，刚好也没有收到最新值的通知，有那么一个纳秒级的时间差，一写就出现了写覆盖，将之前的值给覆盖掉了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>numeber++;<br>atomicInteger.getAndIncrement();<br></code></pre></td></tr></table></figure><p>AtomicInteger（带原子性包装的整形类）的底层原理：CAS</p><p><strong>3、JMM有序性</strong></p><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。</p><p>但是计算机在执行程序时，为了提高性能，编译器和处理器常常会做<strong>指令重排</strong>，一般分为一下3种</p><p><img src="image-20210911181359988.png" alt="image-20210911181359988"></p><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致，即可能产生“脏读“，简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，执行顺序会被优化。</p><ul><li>单线程环境里面确保程序最终执行结果和代码顺序执行结果一致</li><li>处理器在进行重新排序时必须要考虑指令之间的<strong>数据依赖性</strong></li><li>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的，结果无法预测</li></ul><p><strong>4、小总结</strong></p><ul><li>我们定义的所有共享变量都存储在物理主内存中。</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）</li></ul><h3 id="5-5-happens-before"><a href="#5-5-happens-before" class="headerlink" title="5.5 happens-before"></a>5.5 happens-before</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before关系。</p><p><strong>如果仅仅看翻译：先行发生原则，但是它并不是说前面一个操作发生在后续操作的前面，它的真正意思是：前面一个操作的结果对后续操作是可见的。</strong></p><p><strong>案例</strong>：如果线程A执行x &#x3D; 5， 线程B执行y &#x3D; x，那么 y是否等于5呢？</p><p>如果线程A的操作先行发生线程B的操作，那么可以确定线程B执行后y&#x3D;5一定成立；如果它们不存在happens-before原则，那么不一定成立；这就是happens-before原则的威力→<strong>包含可见性和有序性的约束</strong></p><p><strong>先行发生原则说明</strong></p><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦。但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p><strong>我们没有时时刻刻添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个先行发生原则限制和规矩</strong></p><p>它是判断数据是否存在竞争，线程时候安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决<strong>并发环境下两个操作之间是否可能存在冲突的所有问题</strong>，而不需要陷入JMM苦涩难懂的底层编译原理中。</p><p><strong>总原则：</strong></p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在先行发生原则，并不意味着一定要按照该原则制定的顺序来执行。如果重排序之后的执行结果与按照先行发生原则来执行的结果一致，那么这种重排序并不非法。</li></ul><p><strong>8条原则</strong></p><ol><li><p><strong>次序规则</strong></p><ul><li><strong>一个线程内</strong>，按照代码顺序，写在前面的操作先行发生与写在后面的操作；</li><li>前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量x赋值为1，那么后面一个操作肯定能知道x已经变成了1.</li></ul></li><li><p><strong>锁定规则：</strong></p><ul><li><p>一个unLock操作先行发生于后面（这里的后面指的是时间上的先后）对同一个锁的lock操作。</p></li><li><pre><code class="java">public class HappenBeforeDemo&#123;    static Object objectLock = new Object();    public static void main(String[] args) throws InterruptedException &#123;        //对于同一把锁objectLock，threadA一定先unlock同一把锁后B才能获得该锁，   A 先行发生于B        synchronized (objectLock)&#123;        &#125;    &#125;&#125;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**volatile变量规则：**</span><br><br><span class="hljs-bullet">   -</span> 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<span class="hljs-strong">**前面的写对后面的读是可见的**</span>，这里的后面指的是时间上的先后。<br><br><span class="hljs-bullet">4.</span> <span class="hljs-strong">**传递原则：**</span><br><br><span class="hljs-bullet">   -</span> 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br><br><span class="hljs-bullet">5.</span> <span class="hljs-strong">**线程启动规则（Thread Start Rule）：**</span><br><br><span class="hljs-bullet">   -</span> Thread对象的start方法先行发生于此线程的每一个动作。<br><span class="hljs-bullet">   -</span> 主线程A启动子线程B，子线程B能够看到主线程在启动子线程B之前的所有操作。<br><br><span class="hljs-bullet">6.</span> <span class="hljs-strong">**线程中断规则（Thread Interruption Rule）：**</span><br><br><span class="hljs-bullet">   -</span> 对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生；<br><span class="hljs-bullet">   -</span> 可以通过Thread.interrupted检测到是否发生中断。<br><br><span class="hljs-bullet">7.</span> <span class="hljs-strong">**线程终止规则（Thread Termination Rule）：**</span><br><br><span class="hljs-bullet">   -</span> 线程中的的所有操作都可以先行发生于对此线程的终止检测，我们可以通过Thread::join方法是否结束、Thread::isAlive的返回值等手段检测线程是否已经终止执行。<br><br><span class="hljs-code">     ```java</span><br><span class="hljs-code">     Thread B = new Thread(()-&gt;&#123;</span><br><span class="hljs-code">         // 此处对共享变量var修改</span><br><span class="hljs-code">         var = 66;</span><br><span class="hljs-code">     &#125;);</span><br><span class="hljs-code">     // 例如此处对共享变量修改，</span><br><span class="hljs-code">     // 则这个修改结果对线程B可见</span><br><span class="hljs-code">     // 主线程启动子线程</span><br><span class="hljs-code">     B.start();</span><br><span class="hljs-code">     B.join()</span><br><span class="hljs-code">         // 子线程所有对共享变量的修改</span><br><span class="hljs-code">         // 在主线程调用B.join()之后皆可见</span><br><span class="hljs-code">         // 此例中，var==66</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>对象终结规则（Finalizer Rule）：</strong></p><ul><li>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize方法的开始</li><li>也就是对象没有完成初始化之前，是不能调用finalized方法的。</li></ul></li></ol><h3 id="5-6-sync和Lock的可见性"><a href="#5-6-sync和Lock的可见性" class="headerlink" title="5.6 sync和Lock的可见性"></a>5.6 sync和Lock的可见性</h3><p>我们都知道，synchronized和Lock都能够保证可见性，那么如何从happens-before的角度看待它们的可见性？</p><p>sync：首先根据锁定原则，一个锁的unlock操作一定先行发生于它后续的lock操作。假设当线程a释放锁后，线程b拿到了锁并且开始执行代码块中的代码时，线程b必然能够看到线程a看到的所有结果，所以synchronized能够保证线程间数据的可见性。</p><p>lock：将其简化可得如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    read state;<br>    <span class="hljs-keyword">if</span> (can get state)<br>        write state<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    write state;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用volatile变量原则，对一个volatile的写操作一定happens-before于对该volatile变量的读操作。</p><p>当线程b执行获取锁的操作，读取了state变量之后，线程a在写入state变量（即解锁）之前的任何操作结果都是对线程b是可见的。</p><h2 id="第六章-volatile"><a href="#第六章-volatile" class="headerlink" title="第六章 volatile"></a>第六章 volatile</h2><h3 id="6-1-volatile是什么"><a href="#6-1-volatile是什么" class="headerlink" title="6.1 volatile是什么"></a>6.1 volatile是什么</h3><p>volatile是Java虚拟机提供的轻量级的同步机制，基本上遵循了JMM的规范，它有三大特性：保证可见性、<strong>不保证原子性</strong>、禁止指令重排。</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值<strong>立即刷新回主内存中</strong>。</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</li></ul><h3 id="6-2-内存屏障"><a href="#6-2-内存屏障" class="headerlink" title="6.2 内存屏障"></a>6.2 内存屏障</h3><p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排序规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过这些指令，volatile实现了Java内存模型中的可见性和有序性，但是volatile无法保证原子性。</p><ul><li>内存屏障之前的<strong>写</strong>操作都要<strong>回写到主内存</strong>。</li><li>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果（实现了可见性）</li></ul><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</p><p>一句话：对一个volatile域的写，先行发生于任意后续对这个volatile域的读，也叫写后读。</p><p><strong>也就是说，volatile凭什么保证可见性和有序性？就是因为内存屏障</strong></p><p>JMM提供了四类内存屏障指令：</p><p>查看Unsafe.class：</p><p><img src="image-20220203143709073.png" alt="IMG/JUC进阶版.asserts/image-20220203143709073.png"></p><p>它的底层其实就是Unsafe.cpp类</p><p><img src="image-20220203144527688.png" alt="IMG/JUC进阶版.asserts/image-20220203144527688.png"></p><p>再看OrderAccess.hpp类：</p><p><img src="image-20220203144601489.png" alt="IMG/JUC进阶版.asserts/image-20220203144601489.png"></p><p>orderAccess_linux_x86.inline.hpp：</p><p><img src="image-20220203144627544.png" alt="IMG/JUC进阶版.asserts/image-20220203144627544.png"></p><p>那么所谓的四大屏障分别是什么意思呢？</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1；LoadLoad；Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1；StoreStore；Store2</td><td>在Store2及其后的写操作执行前，保证store1的写操作已经刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1；LoadStore；Store2</td><td>在store2及其后的写操作执行前，保证load1的读操作已经读取结束</td></tr><tr><td>StoreLoad</td><td>Store1；StoreLoad；Load2</td><td>保证store1的写操作已经刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table><p>进一步加深理解：</p><p>先行发生原则之volatile变量规则如下所示：</p><p><img src="image-20220203155841704.png" alt="IMG/JUC进阶版.asserts/image-20220203155841704.png"></p><ul><li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li><li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li><li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li></ul><p>可以根据此来看为什么JMM要有四个内存屏障</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li></ul><p><img src="image-20220203164803880.png" alt="IMG/JUC进阶版.asserts/image-20220203164803880.png"></p><ul><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障</li></ul><p><img src="image-20220203165011738.png" alt="IMG/JUC进阶版.asserts/image-20220203165011738.png"></p><h3 id="6-3-volatile特性"><a href="#6-3-volatile特性" class="headerlink" title="6.3 volatile特性"></a>6.3 volatile特性</h3><p><strong>禁止指令重排小总结</strong>（了解）</p><p><img src="image-20210911181631789.png" alt="image-20210911181631789"></p><p><img src="image-20210911181636446.png" alt="image-20210911181636446"></p><p><strong>volatile使用案例</strong></p><p>单例模式DCL代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonDemo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 双重检测机制</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonDemo</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是DCL（双端检锁）机制不一定线程安全，原因是有指令重排的存在，加入volatile可以禁止指令重排，原因在于某一个线程在执行到第一次检测，读取到的instance不为null时，instance的引用对象<strong>可能没有完成初始化</strong></p><p>instance &#x3D; new SingletonDem(); 可以分为以下步骤（伪代码）</p><ol><li>分配对象内存空间 memory &#x3D; allocate();</li><li>在分配的空间上初始化对象 instance(memory);</li><li>设置instance指向刚分配的内存地址，此时instance !&#x3D; null</li></ol><p>步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序执行的结果在单线程中并没有改变，因此这种重排优化是允许的。</p><p>但是如果多线程情况下进行了重排优化，可能第三步先执行，此时对象还没初始化完，<strong>所以当一条线程访问instance不为null时，由于instance实例未必完成初始化，也就造成了线程安全问题。</strong></p><p><img src="64c955c65010aae3902ec918412827d8.png" alt="img"></p><p>因此我们可以加上volatile来禁止指令重排，就能保证多线程间的语义一致性，<code>private static volatile SingletonDemo instance = null</code>。</p><h3 id="6-4-拓展：单例的另一种实现"><a href="#6-4-拓展：单例的另一种实现" class="headerlink" title="6.4 拓展：单例的另一种实现"></a>6.4 拓展：单例的另一种实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingleton</span> &#123;<br>    <span class="hljs-comment">// 内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySingletonHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySingleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySingleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MySingletonHandler.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第七章-CAS"><a href="#第七章-CAS" class="headerlink" title="第七章 CAS"></a>第七章 CAS</h2><h3 id="7-1-CAS"><a href="#7-1-CAS" class="headerlink" title="7.1 CAS"></a>7.1 CAS</h3><p>CAS：比较并交换，如果线程的期望值跟物理内存的真实值一样，就更新值到物理内存中，并返回true；如果线程的期望值跟物理内存的真实值不一样，返回false，本次修改失败，那么此时需要重新获得主物理内存的新值。</p><p>CASDemo代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CASDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>)+<span class="hljs-string">&quot;\t current&quot;</span>+atomicInteger.get());<br>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2014</span>)+<span class="hljs-string">&quot;\t current&quot;</span>+atomicInteger.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、UnSafe</strong></p><p>对于<code>atomicInteger.getAndIncrement()方法的源代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到getAndIncrement方法底层用的是unsafe类中的方法</p><p>下面是AtomicInteger的部分源码</p><p><img src="image-20210911203702980.png" alt="尚硅谷面试题/IMG/尚硅谷面试题第二季.assets/image-20210911203702980.png  100644 → 0"></p><p>UnSafe是CAS的核心类，由于Java方法无法直接访问底层，需要通过本地（native）方法来访问，UnSafe相当于一个后门，基于该类可以直接操作特定的内存数据。UnSafe在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存。</p><p><strong>注意UnSafe类中的所有方法都是native修饰的，也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务</strong></p><p>变量valueOffset就是该变量在内存中的<strong>偏移地址</strong>，因为UnSafe就是根据内存偏移地址来获取数据的。</p><p>变量vlaue用volatile修饰，保证了多线程之间的可见性</p><p><strong>2、什么是CAS</strong></p><p>CAS的全称就是Compare-And-Swap，<strong>它是一条CPU并发原语</strong>，它的功能是判断内存某个位置的值是否为预期值，如果是则更新为新的值，这个过程是原子的。</p><p>CAS并发原语体现在Java语言中就是UnSafe类中的各个方法，调用UnSafe类中的CAS方法，JVM会帮我们实现<strong>CAS汇编指令</strong>，这是一种完全依赖于硬件功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许中断，也就是说CAS是一条原子指令，不会造成所谓的数据不一致问题</p><p><img src="image-20210911211528787.png" alt="image-20210911211528787"></p><p><img src="image-20210911211532186.png" alt="image-20210911211532186"></p><p><img src="image-20210911211535551.png" alt="image-20210911211535551"></p><p>var1 AtomicInteger对象本身.</p><p>var2 该对象值的引用地址</p><p>var4 需要变动的数值</p><p>var5 是用过var1 var2找出内存中绅士的值</p><p>用该对象当前的值与var5比较</p><p>如果相同,更新var5的值并且返回true；如果不同,继续取值然后比较,直到更新完成</p><hr><p>假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上):</p><p>1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存.</p><p>2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这是线程A被挂起.</p><p>3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK.</p><p> 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了.</p><p> 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功.</p><p>原子整型之所以在i++这种多线程的环境下面，不用加synchronized，就凭借着底层UnSafe类也能保证原子性，来保证线程安全，是因为UnSafe是CAS的核心类，且UnSafe是根据内存偏移地址来获取的。</p><p><strong>3、CAS的缺点</strong></p><ol><li>多次比较循环时间长开销很大：如果CAS失败的话，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大的开销</li><li>只能保证一个共享变量的原子性：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时候就可以用锁来保证原子性</li><li>引出来ABA问题</li></ol><p>也就是说，如果使用synchronized进行加锁，一致性得到保证，但是并发性会下降；如果使用CAS，不加锁，能保证一致性，但是它需要多次比较，耗时时间长，开销很大。</p><h3 id="7-2-ABA问题"><a href="#7-2-ABA问题" class="headerlink" title="7.2 ABA问题"></a>7.2 ABA问题</h3><p><strong>1、ABA问题的产生</strong></p><p>CAS会导致ABA问题，CAS算法实现一个重要前需要取出内存中某个时刻的数据并在当下时刻比较并替换， 那么在这个时间差内会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存位置V中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将B变成了A，这个时候one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><strong>尽管one的CAS操作成功，但是不代表这个过程就是没有问题的</strong></p><p><strong>2、原子引用：AtomicReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">zs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-number">22</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">ls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-number">22</span>);<br>        AtomicReference&lt;User&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        reference.set(zs);<br>        System.out.println(reference.compareAndSet(zs, ls)+<span class="hljs-string">&quot;\t&quot;</span>+reference.get().toString());<br>        System.out.println(reference.compareAndSet(zs, ls)+<span class="hljs-string">&quot;\t&quot;</span>+reference.get().toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//结果就是true    user = ls； false    user = ls</span><br></code></pre></td></tr></table></figure><p>原子引用的用法其实和AtomicInteger差不多，只是可以自定义CAS操作对象，且这个同样也有ABA问题</p><p><strong>3、时间戳原子引用：AtomicStampedReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ABA问题的解决</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> veliger@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-04-12 21:30</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;===以下是ABA问题的产生===&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            atomicReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>);<br>            atomicReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-comment">//先暂停1秒 保证完成ABA</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>)+<span class="hljs-string">&quot;\t&quot;</span>+atomicReference.get());<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(<span class="hljs-string">&quot;===以下是ABA问题的解决===&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="hljs-string">&quot;\t值是&quot;</span>+stampedReference.getReference());<br>            <span class="hljs-comment">//暂停1秒钟t3线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>            stampedReference.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 第2次版本号&quot;</span>+stampedReference.getStamp()+<span class="hljs-string">&quot;\t值是&quot;</span>+stampedReference.getReference());<br>            stampedReference.compareAndSet(<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 第3次版本号&quot;</span>+stampedReference.getStamp()+<span class="hljs-string">&quot;\t值是&quot;</span>+stampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="hljs-string">&quot;\t值是&quot;</span>+stampedReference.getReference());<br>            <span class="hljs-comment">//保证线程3完成1次ABA</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 修改成功否&quot;</span>+result+<span class="hljs-string">&quot;\t最新版本号&quot;</span>+stampedReference.getStamp());<br>            System.out.println(<span class="hljs-string">&quot;最新的值\t&quot;</span>+stampedReference.getReference());<br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个可以规避掉ABA问题，就是<strong>新增一种机制，那就是增加时间戳，当时间戳跟要比对的时间戳不一致的话，就说明这个数据在中间被修改过</strong></p><h2 id="第八章-原子操作类之18罗汉增强"><a href="#第八章-原子操作类之18罗汉增强" class="headerlink" title="第八章 原子操作类之18罗汉增强"></a>第八章 原子操作类之18罗汉增强</h2><p><img src="image-20220206103406684.png" alt="image-20220206103406684"></p><p><img src="image-20220206103423934.png" alt="image-20220206103423934"></p><h3 id="8-1-基本类型原子类"><a href="#8-1-基本类型原子类" class="headerlink" title="8.1 基本类型原子类"></a>8.1 基本类型原子类</h3><p>AtomicInteger、AtomicBoolean、AtomicLong</p><p>常用API简介：</p><ul><li>public final int get() &#x2F;&#x2F;获取当前的值</li><li>public final int getAndSet(int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值</li><li>public final int getAndIncrement()&#x2F;&#x2F;获取当前的值，并自增</li><li>public final int getAndDecrement() &#x2F;&#x2F;获取当前的值，并自减</li><li>public final int getAndAdd(int delta) &#x2F;&#x2F;获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int expect, int update) &#x2F;&#x2F;如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPlusPlus</span><span class="hljs-params">()</span> &#123;<br>        atomicInteger.incrementAndGet();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyNumber</span> <span class="hljs-variable">myNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyNumber</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;<br>                        myNumber.addPlusPlus();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, String.value(i)).start();<br>        &#125;<br><br>        countDownLatch.await();<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; -- &quot;</span> myNumberr.atomicInteger.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-数组类型原子类"><a href="#8-2-数组类型原子类" class="headerlink" title="8.2 数组类型原子类"></a>8.2 数组类型原子类</h3><p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;<br>        System.out.println(atomicIntegerArray.get(i));<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    tmpInt = atomicIntegerArray.getAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">1122</span>);<br>    System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">0</span>));<br>    atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>    atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>    tmpInt = atomicIntegerArray.getAndIncrement(<span class="hljs-number">1</span>);<br>    System.out.println(tmpInt+<span class="hljs-string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="hljs-number">1</span>));<br><br>&#125;<br><span class="hljs-comment">// 结果如下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">0    1122</span><br><span class="hljs-comment">2    3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="8-3-引用类型原子类"><a href="#8-3-引用类型原子类" class="headerlink" title="8.3 引用类型原子类"></a>8.3 引用类型原子类</h3><p><strong>1、AtomicReference：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>,<span class="hljs-number">24</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">li4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;li4&quot;</span>,<span class="hljs-number">26</span>);<br><br>    AtomicReference&lt;User&gt; ar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    ar.set(z3);<br><br>    System.out.println(ar.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+ar.get().toString());<br>    System.out.println(ar.compareAndSet(z3,li4)+<span class="hljs-string">&quot;\t&quot;</span>+ar.get().toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用AtomicReference来实现自旋锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题目：实现一个自旋锁</span><br><span class="hljs-comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span><br><span class="hljs-comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span> &#123;<br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t come in&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-literal">null</span>,thread)) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myUnLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread,<span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t myUnLock over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            <span class="hljs-comment">//暂停一会儿线程</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">5</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="hljs-number">1</span> ); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.myLock();<br>            spinLockDemo.myUnLock();<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、AtomicStampedReference</strong></p><p>携带版本号的引用类型原子类，可以解决ABA问题，示例代码见第七章ABA问题</p><p><strong>解决修改过几次</strong></p><p><strong>3、AtomicMarkableReference</strong></p><p>原子更新带有标记位的引用类型对象，它的定义就是将状态戳简化为true|false，类似一次性筷子</p><p><strong>解决是否被修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; amr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> amr.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---默认修改标识：&quot;</span>+marked);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            amr.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,marked,!marked);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> amr.isMarked();<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---默认修改标识：&quot;</span>+marked);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> amr.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">20210308</span>, marked, !marked);<br><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---操作是否成功:&quot;</span>+b);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+ amr.getReference());<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+ amr.isMarked());<br><br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-4-对象的属性修改原子类"><a href="#8-4-对象的属性修改原子类" class="headerlink" title="8.4 对象的属性修改原子类"></a>8.4 对象的属性修改原子类</h3><p>AtomicIntegerFieldUpdater：原子更新对象中int类型字段的值</p><p>AtomicLongFieldUpdater：原子更新对象中Long类型字段的值</p><p>AtomicReferenceFieldUpdater：原子更新引用类型字段的值</p><p>使用目的：<strong>以一种线程安全的方式操作非线程安全对象内的某些字段</strong></p><p>有什么用呢？<strong>一般我们加锁都是锁定整个对象，但是我们使用对象的属性修改原子类，可以减少锁定的范围，只关注长期、敏感性变化的某一个字段，而不是整个对象，已达到精确加锁 + 节约内存的目的；类似医生的微创手术，不用麻痹全身</strong></p><p><strong>使用要求</strong>：更新的对象属性必须使用 public <strong>volatile</strong> 修饰符。因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用**静态方法newUpdater()**创建一个更新器，并且需要设置想要更新的类和属性。</p><p><strong>AtomicIntegerFieldUpdaterDemo</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">bankName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ccb&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, <span class="hljs-string">&quot;money&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(BankAccount bankAccount)</span> &#123;<br>        fieldUpdater.incrementAndGet(bankAccount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                bankAccount.transfer(bankAccount);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 暂停几秒钟线程</span><br>        sleep(<span class="hljs-number">1</span>);<br><br>        sout(bankAccount.money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AtomicReferenceFieldUpdaterDemo</strong></p><p>这个同样可以实现单例模式：<strong>多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; FieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="hljs-string">&quot;isInit&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(MyVar myVar)</span> &#123;<br>        <span class="hljs-keyword">if</span>(FieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE)) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---start init&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---end init&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---抢夺失败，已经有线程在修改中&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyVar</span> <span class="hljs-variable">myVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVar</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myVar.init(myVar);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-5-（重点）原子操作增强类原理深度解析"><a href="#8-5-（重点）原子操作增强类原理深度解析" class="headerlink" title="8.5 （重点）原子操作增强类原理深度解析"></a>8.5 （重点）原子操作增强类原理深度解析</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a><strong>1、基本概念</strong></h4><p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</p><p>除了解决第八章开头的volatile多线程下i++不安全的问题，还可以实现以下功能：</p><ol><li>热点商品点赞计算器，点赞数加加统计，不要求实时精确</li><li>一个很大的List，里面都是int类型，如何实现加加，说说思路</li></ol><h4 id="2、常用API"><a href="#2、常用API" class="headerlink" title="2、常用API"></a><strong>2、常用API</strong></h4><p><img src="image-20220206113432949.png" alt="image-20220206113432949"></p><p><strong>LongAdder只能用来计算加法，且从零开始计算；</strong></p><p><strong>LongAccumulator提供了自定义的函数操作</strong>：long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等</p><p>使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderAPIDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br><br>        longAdder.increment();<br>        longAdder.increment();<br>        longAdder.increment();<br><br>        System.out.println(longAdder.longValue());<br><br>        <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x,y) -&gt; x * y,<span class="hljs-number">2</span>);<br><br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">2</span>);<br>        longAccumulator.accumulate(<span class="hljs-number">3</span>);<br><br>        System.out.println(longAccumulator.longValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、LongAdder高性能对比Code演示"><a href="#3、LongAdder高性能对比Code演示" class="headerlink" title="3、LongAdder高性能对比Code演示"></a><strong>3、LongAdder高性能对比Code演示</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickNumberNet</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickBySync</span><span class="hljs-params">()</span> &#123;<br>        number++;<br>    &#125;<br><br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByAtomicLong</span><span class="hljs-params">()</span> &#123;<br>        atomicLong.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAdder</span><span class="hljs-params">()</span> &#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x,y) -&gt; x + y,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAccumulator</span><span class="hljs-params">()</span> &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@auther</span> zzyy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-21 22:23</span><br><span class="hljs-comment"> * 50个线程，每个线程100W次，总点赞数出来</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ClickNumberNet</span> <span class="hljs-variable">clickNumberNet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClickNumberNet</span>();<br><br>        <span class="hljs-type">long</span> startTime;<br>        <span class="hljs-type">long</span> endTime;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">50</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">50</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">50</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">50</span>);<br><br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; j++) &#123;<br>                        clickNumberNet.clickBySync();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="hljs-string">&quot; 毫秒&quot;</span>+<span class="hljs-string">&quot;\t clickBySync result: &quot;</span>+clickNumberNet.number);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; j++) &#123;<br>                        clickNumberNet.clickByAtomicLong();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch2.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch2.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="hljs-string">&quot; 毫秒&quot;</span>+<span class="hljs-string">&quot;\t clickByAtomicLong result: &quot;</span>+clickNumberNet.atomicLong);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; j++) &#123;<br>                        clickNumberNet.clickByLongAdder();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch3.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch3.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="hljs-string">&quot; 毫秒&quot;</span>+<span class="hljs-string">&quot;\t clickByLongAdder result: &quot;</span>+clickNumberNet.longAdder.sum());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;=<span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; j++) &#123;<br>                        clickNumberNet.clickByLongAccumulator();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch4.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch4.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="hljs-string">&quot; 毫秒&quot;</span>+<span class="hljs-string">&quot;\t clickByLongAccumulator result: &quot;</span>+clickNumberNet.longAccumulator.longValue());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220206114644660.png" alt="image-20220206114644660"></p><h4 id="4、源码、原理分析"><a href="#4、源码、原理分析" class="headerlink" title="4、源码、原理分析"></a><strong>4、源码、原理分析</strong></h4><p><img src="image-20220206134057810.png" alt="image-20220206134057810"></p><p>那么为什么LongAdder这么快呢？</p><p>那是因为<strong>LongAdder是Striped64的子类</strong></p><p>Striped64有几个比较重要的成员函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Number of CPUS, to place bound on table size        CPU数量，即cells数组的最大长度 */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NCPU</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Table of cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment">cells数组，为2的幂，2,4,8,16.....，方便以后位运算</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br><span class="hljs-comment">/**基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。</span><br><span class="hljs-comment"> * Base value, used mainly when there is no contention, but also as</span><br><span class="hljs-comment"> * a fallback during table initialization races. Updated via CAS.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><br><span class="hljs-comment">/**创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。</span><br><span class="hljs-comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h5 id="Striped64中一些变量或者方法的定义"><a href="#Striped64中一些变量或者方法的定义" class="headerlink" title="Striped64中一些变量或者方法的定义"></a><strong>Striped64中一些变量或者方法的定义</strong></h5><ul><li>base：类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上。</li><li>collide：表示扩容意向，false一定不会扩容，true可能会扩容。</li><li>cellsBusy：初始化cells或者扩容cells需要获取锁，0表示无锁状态，1表示其他线程已经持有了锁。</li><li>casCellsBusy（）：通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li><li>NCPU：当前计算机CPU的数量，Cell数组扩容时会用到</li><li>getProbe()：获取当前线程的hash值</li><li>advanceProbe（）：重置当前线程的hash值</li></ul><p>而所谓的Cell类，其实就是<strong>是 java.util.concurrent.atomic 下 Striped64 的一个内部类</strong></p><p><img src="image-20220206134940151.png" alt="image-20220206134940151"></p><p>LongAdder的基本思路就是<strong>分散热点</strong>，将value值分散到一个<strong>Cell数组</strong>中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只需将各个槽中的变量值累加返回。</p><p>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到更多个value中去，<strong>从而降级更新热点</strong></p><p><img src="image-20220206135334565.png" alt="image-20220206135334565"></p><p>内部有一个base变量，一个Cell数组</p><p>base变量：非竞争条件下，直接累加到该变量上</p><p>cell数组：竞争条件下，累加到各个线程自己的槽Cell[i]中。</p><p><img src="image-20220206135356216.png" alt="image-20220206135356216"></p><p>LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220206135838869.png" alt="image-20220206135838869"></p><p><img src="%E5%9B%BE%E7%89%87.png" alt="图片"></p><ol><li>最初无竞争时只更新base</li><li>如果更新base失败后，首次新建一个Cell[]数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容</li></ol><h5 id="longAccumulate方法"><a href="#longAccumulate方法" class="headerlink" title="longAccumulate方法"></a><strong>longAccumulate方法</strong></h5><ul><li>long x ：需要增加的值，一般默认都是1</li><li>LongBinrayOperator fn ：默认传递的是null</li><li>wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false。</li></ul><p><img src="image-20220206204659299.png" alt="image-20220206204659299"></p><p><img src="image-20220206204712443.png" alt="image-20220206204712443"></p><p><img src="image-20220206204716485.png" alt="image-20220206204716485"></p><p><img src="image-20220206204721049.png" alt="image-20220206204721049"></p><p><strong>接下来看总纲</strong></p><p><img src="image-20220206204805772.png" alt="image-20220206204805772"></p><p>上述代码首先给当前线程分配一个hash值，然后进入一个for(;;)自旋，这个自旋分为三个分支：</p><ul><li>CASE1：Cell[]数组已经初始化</li><li>CASE2：Cell[]数组未初始化(首次新建)</li><li>CASE3：Cell[]数组正在初始化中</li></ul><p>接下来分开看：</p><p><strong>1、刚刚要初始化Cell[]数组(首次新建)：</strong></p><p>未初始化过Cell[]数组，尝试占有锁并首次初始化cells数组</p><p><img src="image-20220206205242031.png" alt="image-20220206205242031"></p><p>如果上面条件都执行成功就会执行数组的初始化及赋值操作， Cell[] rs &#x3D; new Cell[2]表示数组的长度为2，rs[h &amp; 1] &#x3D; new Cell(x) 表示创建一个新的Cell元素，value是x值，默认为1。h &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法，通常都是hash &amp; (table.len - 1)。同hashmap一个意思。</p><p><strong>2、兜底</strong></p><p>多个线程尝试CAS修改失败的线程会走到这个分支</p><p><img src="image-20220206205314265.png" alt="image-20220206205314265"></p><p>该分支实现直接操作base基数，将值累加到base上，也即其它线程正在初始化，多个线程正在更新base的值。</p><p><strong>3、Cell数组不再为空且可能存在Cell数组扩容</strong></p><p>多个线程同时命中一个cell的竞争</p><p>总体代码如下：</p><p><img src="image-20220206205342462.png" alt="image-20220206205342462"></p><p><strong>3.1</strong></p><p><img src="image-20220206211522791.png" alt="image-20220206211522791"></p><p>上面代码判断当前线程hash后指向的数据位置元素是否为空，如果为空则将Cell数据放入数组中，跳出循环。如果不空则继续循环。</p><p><strong>3.2</strong></p><p><img src="image-20220206211544806.png" alt="image-20220206211544806"></p><p><strong>3.3</strong></p><p><img src="image-20220206211555812.png" alt="image-20220206211555812"></p><p>说明当前线程对应的数组中有了数据，也重置过hash值，这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。</p><p><strong>3.4</strong></p><p><img src="image-20220206211615943.png" alt="image-20220206211615943"></p><p><strong>3.5</strong></p><p><img src="image-20220206211624502.png" alt="image-20220206211624502"></p><p><strong>3.6</strong></p><p><img src="image-20220206211632200.png" alt="image-20220206211632200"></p><p><strong>上述六部总结如下</strong></p><p><img src="image-20220206211645742.png" alt="image-20220206211645742"></p><h5 id="sum方法"><a href="#sum方法" class="headerlink" title="sum方法"></a><strong>sum方法</strong></h5><p>sum()会将所有Cell数组中的value和base累加作为返回值。核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><p><strong>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</strong></p><p>首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了，而此时局部变量sum不会更新，造成不一致。</p><p>其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。</p><p><img src="image-20220206211930658.png" alt="image-20220206211930658"></p><h4 id="5、使用总结"><a href="#5、使用总结" class="headerlink" title="5、使用总结"></a>5、使用总结</h4><ul><li>AtomicLong<ul><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li><li>保证精度，性能代价</li><li>AtomicLong是多个线程针对单个热点值value进行原子操作</li></ul></li><li>LongAdder<ul><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li><li>保证性能，精度代价</li><li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li></ul></li></ul><h3 id="8-6-小总结"><a href="#8-6-小总结" class="headerlink" title="8.6 小总结"></a>8.6 小总结</h3><p><strong>AtomicLong：</strong></p><p>原理：CAS + 自旋、incrementAndGet</p><p>场景：低并发下的全局计算；AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性问题。</p><p>缺陷：高并发后性能急剧下降，这是因为AtomicLong的自旋造成瓶颈</p><p>N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。</p><p><strong>LongAdder VS Atomic Long Performance</strong></p><p><a href="http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/">http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/</a></p><p><strong>LongAdder</strong></p><p>原理：CAS + Base + Cell数组分散；空间换时间并分散了热点数据</p><p>场景：高并发下的全局计算</p><p>缺陷：sum求和后还有计算线程修改结果的话，最后结果不够准确</p><h2 id="第十章-Java对象内存布局和对象头"><a href="#第十章-Java对象内存布局和对象头" class="headerlink" title="第十章 Java对象内存布局和对象头"></a>第十章 Java对象内存布局和对象头</h2><p><img src="image-20220205125505913.png" alt="image-20220205125505913"></p><p>Object object &#x3D; new Object()，谈谈你对这句话的理解？一般而言，JDK8按照默认情况下，new一个对象占多少内存空间？</p><h3 id="10-1-对象在堆内存中的存储布局"><a href="#10-1-对象在堆内存中的存储布局" class="headerlink" title="10.1 对象在堆内存中的存储布局"></a>10.1 对象在堆内存中的存储布局</h3><p><strong>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实际数据、对齐填充</strong></p><p><img src="image-20220205125656777.png" alt="image-20220205125656777"></p><h3 id="10-1-1-对象头"><a href="#10-1-1-对象头" class="headerlink" title="10.1.1 对象头"></a>10.1.1 对象头</h3><p><strong>对象头包含对象标记（Mark Word）和类元信息（又叫类型指针）</strong></p><p><img src="image-20220205130518985.png" alt="image-20220205130518985"></p><p><strong>1、对象标记：</strong></p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀（重量级锁定）</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p>在64位系统中，MarkWord占了8个字节，类型指针占了8个字节，一共是16个字节。</p><p><img src="image-20220205132040145.png" alt="image-20220205132040145"></p><ul><li>默认存储对象的HashCode、分代年龄和锁标志位等信息。</li><li>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。</li><li>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</li></ul><p><strong>2、类元信息（类型指针）</strong></p><p><img src="image-20220205132454203.png" alt="image-20220205132454203"></p><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="10-1-2-实例数据"><a href="#10-1-2-实例数据" class="headerlink" title="10.1.2 实例数据"></a>10.1.2 实例数据</h3><p>存放类的属性（Field）数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p><h3 id="10-1-3-对齐填充"><a href="#10-1-3-对齐填充" class="headerlink" title="10.1.3 对齐填充"></a>10.1.3 对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅只是为了字节对齐，这部分内存按8字节补充对齐。</p><h3 id="10-2-再说对象头的MarkWord"><a href="#10-2-再说对象头的MarkWord" class="headerlink" title="10.2 再说对象头的MarkWord"></a>10.2 再说对象头的MarkWord</h3><p><img src="image-20220205132832941.png" alt="image-20220205132832941"></p><p><img src="image-20220205132859119.png" alt="image-20220205132859119"></p><p><img src="image-20220205133200557.png" alt="image-20220205133200557"></p><p><img src="image-20220205133206455.png" alt="image-20220205133206455"></p><ul><li>hash：保存对象的哈希码</li><li>age：保存对象的分代年龄</li><li>biased_lock：偏向锁标识位</li><li>lock：锁状态标识位</li><li>JavaThread*：保存持有偏向锁的线程ID</li><li>epoch：保存偏向时间戳</li></ul><p><strong>对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化</strong></p><h3 id="10-3-聊聊Object-obj-x3D-new-Object"><a href="#10-3-聊聊Object-obj-x3D-new-Object" class="headerlink" title="10.3 聊聊Object obj &#x3D; new Object()"></a>10.3 聊聊Object obj &#x3D; new Object()</h3><p><a href="http://openjdk.java.net/projects/code-tools/jol/">http://openjdk.java.net/projects/code-tools/jol/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">官网：http://openjdk.java.net/projects/code-tools/jol/</span><br><span class="hljs-comment">定位：分析对象在JVM的大小和分布</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">//引入了JOL，直接使用</span><br>    System.out.println(ClassLayout.parseInstance(object).toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="image-20220205133815247.png" alt="image-20220205133815247"></p><p>其中MarkWord8个字节，类型指针4个字节</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>OFFSET</td><td>偏移量，也就是这个字段位置所占用的byte数</td></tr><tr><td>SIZE</td><td>后面类型的字节大小</td></tr><tr><td>TYPE</td><td>是Class中定义的类型</td></tr><tr><td>DESCRIPTION</td><td>类型的描述</td></tr><tr><td>VALUE</td><td>TYPE在内存中的值</td></tr></tbody></table><p>注意到上述的类型指针只有4个字节，但是我们之前说类型指针应该是8个才对，这是因为<strong>JVM默认开启了类型指针的压缩，来节省空间</strong></p><p>使用<code>-XX:-UseCompressedClassPointers</code>来关闭默认开启的类型指针压缩</p><p><img src="image-20220205134512658.png" alt="image-20220205134512658"></p><p>如果换成其他的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectHeadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">O</span>()).toPrintable());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">O</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="image-20220205141630791.png" alt="image-20220205141630791"></p><h2 id="第十一章-Synchronized与锁升级"><a href="#第十一章-Synchronized与锁升级" class="headerlink" title="第十一章 Synchronized与锁升级"></a>第十一章 Synchronized与锁升级</h2><p>源码下载：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/">jdk8u&#x2F;jdk8u&#x2F;hotspot: log (java.net)</a></p><ul><li>整体逻辑：无锁&#x3D;》偏向锁&#x3D;》轻量级锁&#x3D;》重量级锁</li><li>偏向锁无冲突逻辑；发生冲突之后偏向锁的撤销，到安全点的两个分支逻辑；hashcode对偏向锁的影响；批量重偏向和批量撤销；匿名偏向</li><li>轻量级锁基本逻辑；LR；发生竞争之后轻量级锁的膨胀</li><li>重量级锁，cxq、entrylist、waitset；自旋；mutex、futex</li></ul><h3 id="11-1-锁升级基本概念"><a href="#11-1-锁升级基本概念" class="headerlink" title="11.1 锁升级基本概念"></a>11.1 锁升级基本概念</h3><p>用锁能够实现数据的安全性，但是会带来性能下降。无锁能够基于线程并行提升程序性能，但是会带来安全性下降。</p><p><img src="image-20220205144231834.png" alt="image-20220205144231834"></p><p>synchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略</p><p>在Java5之前，只有Synchronized，这个是操作系统级别的重量级操作。<strong>重量级锁</strong>，假如锁的竞争比较激烈的话，性能下降。Java5之前，用户态和内核态之间的切换。</p><p>Java的线程是映射到操作系统原生线程之上的。如果要阻塞或唤醒一个线程就需要操作系统介入，需要用户态和核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>在Java早期版本中，<strong>Synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的</strong>，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</p><p><strong>Java6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁。</strong></p><p><strong>Monitor与Java对象以及线程是如何关联的？</strong></p><ul><li>如果一个Java对象被某个线程锁住，则该Java对象的MarkWord字段中LockWord指向monitor的起始地址</li><li>Monitor的Owner字段会存放拥有相关联对象锁的线程id</li></ul><p>Motex Lock的切换需要从用户态转换到核心态，因此状态转换需要耗费很多的处理器时间。</p><p><strong>三种多线程访问情况：</strong></p><ul><li>只有一个线程来访问</li><li>多个线程交替访问</li><li>竞争激烈，多个线程来访问</li></ul><p><strong>升级流程：synchronized用的锁是存在Java对象头里的MarkWord中，锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位</strong></p><h3 id="11-2-无锁"><a href="#11-2-无锁" class="headerlink" title="11.2 无锁"></a>11.2 无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        System.out.println(<span class="hljs-string">&quot;10进制hash码：&quot;</span>+o.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;16进制hash码：&quot;</span>+Integer.toHexString(o.hashCode()));<br>        System.out.println(<span class="hljs-string">&quot;2进制hash码：&quot;</span>+Integer.toBinaryString(o.hashCode()));<br><br>        System.out.println( ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20220205152216749.png" alt="image-20220205152216749"></p><h3 id="11-3-偏向锁"><a href="#11-3-偏向锁" class="headerlink" title="11.3 偏向锁"></a>11.3 偏向锁</h3><p><img src="image-20221109214027087.png" alt="image-20221109214027087"></p><blockquote><p>默认情况下，偏向锁会有一个时延，默认四秒。</p><p>因为虚拟机自己会有一些默认的启动的线程，里面会有很多的sync代码。这些代码在启动的时候肯定会有竞争，而如果一开始就可以使用偏向锁，那么就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率低下。 </p><p>在项目刚启动的时候，new出来的对象默认都是无锁的状态（在这个阶段，发生对于无锁状态的竞争会直接进入轻量级锁），但是在经过了偏向锁的时延之后再去创建的对象默认都是偏向锁，但是这个偏向锁其实叫做匿名偏向锁，它对应的对象头的markword中的threadId是0。</p></blockquote><p><strong>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</strong></p><p>HotSpot的作者经过研究发现，大多数情况下：多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况。<strong>偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</strong></p><p><img src="image-20220205152510684.png" alt="image-20220205152510684"></p><p>那么只需要在锁的第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同步锁的代码块时，<strong>不需要再次加锁和释放锁</strong>。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。</p><p>如果相等表示偏向锁时偏向于当前线程的，就不需要再次尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>假如不一致意味着发生了竞争，锁已经不是总是偏向于同一线程了，这时候可能需要升级位轻量级锁，才能保证线程间公平竞争锁。<strong>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的</strong></p><p><strong>开启偏向锁</strong></p><p>实际上偏向锁再JDK1.6之后是默认开启的，但是启动时间 有延迟，所以需要添加参数<code>-XX:BiasedLockingStartupDelay = 0</code>，让其在程序启动时立刻启动。</p><p>开启偏向锁：</p><p><code>-XX:+UseBiasedLocking(开启) -XX:BiasedLockingStartupDelay = 0（关闭延迟）</code></p><p>关闭偏向锁：关闭之后程序默认会直接进入轻量级锁状态</p><p><code>-XX:-UseBiasedLocking</code></p><p><strong>HashCode对偏向锁的影响</strong></p><blockquote><p>对于偏向锁而言，它其实无法存储对象的hashcode，因此如果对象在创建之后使用了hashcode方法， 该对象便无法成为偏向锁了；如果持有偏向锁的线程在同步代码块中调用了锁的hashcode，那么该锁就会立马升级为重量级锁</p></blockquote><p><strong>线程多了之后</strong></p><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁。竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p><p><strong>偏向锁的撤销</strong></p><p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。<br>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： </p><p>①  第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会继续CAS尝试获得该轻量级锁。</p><p>②  第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，但是该锁将无法变成偏向锁了，如果再有线程来获取该无锁，将会直接升级成轻量级锁。</p><p>除此之外，其实如果调用wait&#x2F;notify，也会使得偏向锁或轻量级锁强制升级为重量级锁</p><p><img src="image-20220205213034003.png" alt="image-20220205213034003"></p><p><strong>批量重偏向和批量撤销</strong></p><ul><li><p>对于一个类（源码中获取锁对象的类的元数据  Klass* k &#x3D; o-&gt;klass()），单个偏向撤销的计数达到20，就会进行批量重偏向；当每次发生批量重偏向的时候，会将class的epoch加1，同时遍历JVM中所有线程的栈，找到该class所有正在处于加锁状态的偏向锁，将其epoch字段改为新值。下次加锁的时候，发现当前对象的epoch和class的epoch不想等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。</p><p><strong>理解</strong>：如果一个地区（class）所拥有的夫妻（对象）经常发生离婚（撤销），为了节约偏向锁撤销带来的性能损耗问题（也就是认为该地区有问题，给他们一次换老公的机会，也就是可重偏向），当然只针对于之后的对象。</p><p>同样，如果这个地区换过老公了，离婚率还是很高，直接就别结婚了，也就是批量撤销逻辑，直接禁止成为偏向锁。</p></li><li><p>如果距离上次批量重偏向25s内，并且计数达到40，就会发生<strong>批量撤销</strong>，将该class标记为不可偏向，因为此时JVM会认为该class的使用场景存在多线程竞争，之后对于该class的锁，就直接走轻量级锁的逻辑。</p></li><li><p>每隔25秒（&gt;&#x3D;），会重置在20-40内的计数，这就意味着可以发生多次批量重偏向</p></li><li><p>对于一个类来说，<strong>批量撤销只会发生过一次</strong>，因为批量撤销之后，该类就禁用了可偏向属性，后面该类的对象都是不可偏向的，包括新建的，因此都不是偏向锁了自然无法批量撤销。</p></li></ul><blockquote><p>JVM内部为每个类维护了一个偏向锁revoke计数器，对偏向锁撤销进行计数，当这个值达到指定阈值时，JVM会认为这个类的偏向锁有问题，需要重新偏向(rebias),对所有属于这个类的对象进行重偏向的操作成为 批量重偏向(bulk rebias)。在做bulk rebias时，会对这个类的epoch的值做递增，这个epoch会存储在对象头中的epoch字段。在判断这个对象是否获得偏向锁的条件是:markword的 biased_lock:1、lock:01、threadid和当前线程id相等、epoch字段和所属类的epoch值相同，如果epoch的值不一样，要么就是撤销偏向锁、要么就是rebias； 如果这个类的revoke计数器的值继续增加到一个阈值，那么jvm会认为这个类不适合偏向锁，就需要进行bulk revoke操作</p></blockquote><h3 id="11-4-轻量级锁"><a href="#11-4-轻量级锁" class="headerlink" title="11.4 轻量级锁"></a>11.4 轻量级锁</h3><p>有线程来参与锁的竞争，但是获取锁的冲突时间非常短</p><p><img src="image-20220205213144978.png" alt="image-20220205213144978"></p><p><strong>加锁过程</strong>：</p><p>在代码即将进入 同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为 这份拷贝加了一个Displaced前缀，即Displaced Mark Word） </p><p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个 更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。</p><p> 如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟 机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对 象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果 出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志 的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线 程也必须进入阻塞状态</p><p><strong>解锁过程</strong></p><p>如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有 其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p><h3 id="11-5-重锁"><a href="#11-5-重锁" class="headerlink" title="11.5 重锁"></a>11.5 重锁</h3><p>整个锁膨胀的逻辑实际是获得一个ObjectMonitor对象监视器，通过自旋实现。</p><p>对于重量级锁的竞争逻辑：</p><ol><li>通过CAS将monitor的 _owner字段设置为当前线程，如果设置成功，则直接返回</li><li>如果之前的 _owner指向的是当前的线程，说明是重入，执行 _recursions++增加重入次数</li><li>如果当前线程获取监视器锁成功，将 _recursions设置为1， _owner设置为当前线程</li><li>如果获取锁失败，则等待锁释放</li></ol><p>当然，如果获取锁失败，就需要通过自旋的方式等待锁释放，其实就是将线程封装成ObjectWaiter对象的node，然后通过自旋将push到cxq队列，加到该队列之后，继续通过自旋尝试获取锁，如果自旋之后还是未能获取锁，就只能通过park将当前线程挂起，等待被唤醒；</p><p>当线程释放锁的时候，会根据唤醒策略，从cxq队列或entrylist中挑选一个线程unpark唤醒。</p><p>在唤醒等待队列的时候，会先将owner设置为null，如果这个时候有其他线程进入会获得该锁，也就是owner不为null，这其实也是<strong>非公平锁的体现</strong>，它会给刚进入，但是还没有进入等待队列等待的线程一次抢占的机会。</p><p>如果没有线程能珍惜这次机会，就根据不同的策略从cxq或者entrylist中取出一个线程进行唤醒。但是该唤醒的线程被恢复挂起，恢复之后也不一定能够运行用户代码，不保证一定能获取到。</p><h3 id="11-6-小总结"><a href="#11-6-小总结" class="headerlink" title="11.6 小总结"></a>11.6 小总结</h3><p><img src="image-20220205215228013.png" alt="image-20220205215228013"></p><p><strong>synchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。</strong></p><p>实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。</p><p>JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。</p><p>**偏向锁:**适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法&#x2F;代码块则使用偏向锁。</p><p><strong>轻量级锁</strong>：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</p><p><strong>重量级锁</strong>：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</p><h3 id="11-7-JIT编译器对锁的优化"><a href="#11-7-JIT编译器对锁的优化" class="headerlink" title="11.7 JIT编译器对锁的优化"></a>11.7 JIT编译器对锁的优化</h3><p>Just In Time Compiler，一般翻译为即时编译器</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁消除</span><br><span class="hljs-comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span><br><span class="hljs-comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockClearUPDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//正常的</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----hello LockClearUPDemo&quot;</span>+<span class="hljs-string">&quot;\t&quot;</span>+o.hashCode()+<span class="hljs-string">&quot;\t&quot;</span>+objectLock.hashCode());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LockClearUPDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockClearUPDemo</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                demo.m1();<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁粗化</span><br><span class="hljs-comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，</span><br><span class="hljs-comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockBigDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;11111&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;22222&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;33333&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;44444&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;55555&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;66666&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-8-常见面试题"><a href="#11-8-常见面试题" class="headerlink" title="11.8 常见面试题"></a>11.8 常见面试题</h3><p><strong>问题1：ObjectMonitor和AQS有什么异同</strong><br> ObjectMonitor和AQS（AbstractQueuedSynchronizer）都是依据管程模型的原理开发的。所以在整体架构上基本相同，都有共享变量和等待队列，在实现上又有区别。<br> 1）<strong>共享变量</strong>，ObjectMonitor中使用owner做共享变量，通过CAS设置owner为当前线程来抢锁。而AQS中的共享变量是一个整形的status。因为这一区别，导致ObjectMonitor需要定义一个计数器来记录锁重入次数，而AQS需要额外定义个exclusiveOwnerThread来记录当前持有锁的线程。<br> 2）<strong>等待队列</strong>，ObjectMonitor等待队列使用了两个队列，cxq和entryList，而AQS仅使用了一个等待队列。<br> 3）<strong>条件同步</strong>，AQS支持在同一个锁上创建多个条件变量，wait&#x2F;notify更加灵活和精准。而ObjectMonitor只有一个waitset，所有线程共享一个条件变量。<br> 4）<strong>Share模式</strong>，AQS的Share模式可以使实现读写锁更加简单。</p><p><strong>问题2: 为什么ObjectMonitor需要cxq和entryList两个等待队列</strong><br> ObjectMonitor中加解锁、wait&#x2F;notify都涉及对等待队列的进出队操作。如果使用一个队列冲突的概率会加大，耗费系统资源。分成2个队列后，出入队EntryList队列只有加锁的情况才会操作，不需要CAS和自旋，减少了资源消耗。</p><h2 id="第十二章-AbstractQueuedSynchronizer之AQS"><a href="#第十二章-AbstractQueuedSynchronizer之AQS" class="headerlink" title="第十二章 AbstractQueuedSynchronizer之AQS"></a>第十二章 AbstractQueuedSynchronizer之AQS</h2><p>抽象的队列同步器</p><p>是用来构建锁或者其它同步器组件的<strong>重量级基础框架及整个JUC体系的基石</strong>，通过内置的FIFO<strong>队列</strong>来完成资源获取线程的排队工作，并通过一个<strong>int变量</strong>表示持有锁的状态</p><p><img src="image-20210923185707622.png" alt="image-20210923185707622"></p><p>和AQS有关的内容如下图所示</p><p><img src="image-20210923113321814.png" alt="image-20210923113321814"></p><p>锁，面向锁的使用者，定义了程序员和锁交互的使用层API，隐藏了实现细节，调用就可以</p><p>同步器，面向锁的实现者，比如java并发大神Douglee提出了统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</p><h3 id="12-1-能干嘛"><a href="#12-1-能干嘛" class="headerlink" title="12.1 能干嘛"></a>12.1 能干嘛</h3><p>加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要有某种形式的队列来管理</p><p>抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种排队等候机制，抢占资源失败的线程继续去等待（类似办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候），仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。</p><h3 id="12-2-AQS初步"><a href="#12-2-AQS初步" class="headerlink" title="12.2 AQS初步"></a>12.2 AQS初步</h3><blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">/**<br> * Provides a framework <span class="hljs-keyword">for</span> implementing blocking locks and related<br> * synchronizers (semaphores, events, etc) that rely <span class="hljs-keyword">on</span><br> * first-in-first-out (FIFO) wait queues.  This class is designed <span class="hljs-keyword">to</span><br> * be a useful basis <span class="hljs-keyword">for</span> most kinds of synchronizers that rely <span class="hljs-keyword">on</span> a<br> * single atomic &#123;@code int&#125; value <span class="hljs-keyword">to</span> represent <span class="hljs-keyword">state</span>. Subclasses<br> * must define the protected methods that change this <span class="hljs-keyword">state</span>, and which<br> * define what that <span class="hljs-keyword">state</span> means <span class="hljs-keyword">in</span> terms of this object being acquired<br> * or released.  Given these, the other methods <span class="hljs-keyword">in</span> this class carry<br> * <span class="hljs-keyword">out</span> <span class="hljs-literal">all</span> queuing and blocking mechanics. Subclasses can maintain<br> * other <span class="hljs-keyword">state</span> fields, but only the atomically updated &#123;@code int&#125;<br> * value manipulated using methods &#123;@link <span class="hljs-comment">#getState&#125;, &#123;@link</span><br> * <span class="hljs-comment">#setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect</span><br> * <span class="hljs-keyword">to</span> synchronization.<br></code></pre></td></tr></table></figure><p>依靠单个原子来表示状态，通过占用和释放方法改变状态值</p></blockquote><p>AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改</p><p><img src="image-20210923201402008.png" alt="image-20210923201402008"></p><p>对于state变量来说，如果为0就是相当于自由状态，线程可以进行锁的抢占，类似于银行办理业务的受理窗口可以进行办理；如果大于0，有人占用窗口，线程得进行阻塞等待</p><p>CLH队列是一个双向队列，从尾部入队，头部出队，即AQS就是state变量 + CLH双端Node队列</p><p>Node类在AQS类内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><br>    <span class="hljs-comment">// 共享</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 独占</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 线程被取消了</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 后继线程需要唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 等待condition唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 共享式同步状态获取将会无条件地传播下去</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 初始为0，状态是上面的几种</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>    <span class="hljs-comment">// 后面省略。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Node的waitStatus就是等候区其他顾客（其他线程）的等待状态，队列中每一个排队的个体就是一个Node</p><p><img src="image-20210923203705089.png" alt="image-20210923203705089"></p><p>AQS底层是用LockSupport.park()进行排队的</p><h3 id="12-3-源码解析"><a href="#12-3-源码解析" class="headerlink" title="12.3 源码解析"></a>12.3 源码解析</h3><p>我们以ReentrantLock为例进行解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AQSDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-comment">//带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制</span><br>        <span class="hljs-comment">//3个线程模拟3个来银行网点，受理窗口办理业务的顾客</span><br>        <span class="hljs-comment">//A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;-----A thread come in&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123; TimeUnit.MINUTES.sleep(<span class="hljs-number">20</span>); &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-comment">//第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span><br>        <span class="hljs-comment">//进入候客区</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;-----B thread come in&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br><br>        <span class="hljs-comment">//第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span><br>        <span class="hljs-comment">//进入候客区</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;-----C thread come in&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20210923210904175.png" alt="image-20210923210904175"></p><p>Lock接口的实现类基本上都是通过聚合了一个队列同步器的子类完成线程访问控制的</p><p>对于公平和非公平锁，比较他们的tryAcqure()方法， 其实差别就在于<strong>非公平锁获取锁时比公平锁中少了一个判断</strong><code>!hasQueuedPredecessors()</code>，该方法中判断了是否需要排队。</p><p>公平锁：先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中</p><p>非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark，之后还是需要竞争锁（存在线程竞争的情况下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// hasQueuedPredecessors()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>    <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>    <span class="hljs-comment">// thread is first in queue.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    Node s;<br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>首先看非公平锁的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是第一个线程进来，一开始status为0，因此就能够通过CAS变成1，因此进入if里面进行抢占，在我们的银行例子中，A线程就能抢占到锁。其中<code>setExclusiveOwnerThread</code>设置该锁是被当前线程所占领，即A线程</p><p>此时状态如下：</p><p><img src="image-20210923211027125.png" alt="image-20210923211027125"></p><p>因为A线程设置的时候阻塞了20分钟，因此此时B线程进来抢夺锁，发现state已经被占用了，就执行else里面的<code>acquire(1)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中tryAcquire方法在父类中的实现是抛出一个异常，这是设计模式的内容，旨在强制让子类重写该方法</p><p>本例我们使用的是ReentrantLock中的非公平锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 通过变量state判断锁是否被占用，0表示未被占用</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">            当前锁已经被占用，但是占用锁的是当前线程本身，ReentrantLock支持重入</span><br><span class="hljs-comment">            这里就是重入锁的实现，当已经获取锁的线程每多获取一次锁，state就进行加1操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果线程没有抢到锁，就返回，继续推进条件，走下一步方法addWaiter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当线程B进入nonfairTryAcquire方法时，发现还是无法抢到锁，就返回false，继续执行接下来的方法，也就是addWaiter(Node.EXCLUSIVE,arg)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次进入，tail指向null，也就是CLH队列中还没有线程，就执行enq方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次判断tail指向null，因此新建一个Node节点，让head指向该Node，然后让tail指向head，也就是这个新建的Node，</p><p><img src="image-20210923213116201.png" alt="image-20210923213116201"></p><p>双向链表中，<strong>第一个节点为虚节点，也叫哨兵节点</strong>，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。</p><p>此时方法还没结束，继续下一次循环，注意的是，此时tail已经不为null了，进入else中，而此时的node就是线程B所在的节点，将线程B加入到CLH队列之中。</p><p><img src="image-20220224214430039.png" alt="image-20220224214430039"></p><p>然后这时候C线程也进来了，重复线程B的动作，但是在addWaiter方法能进if里面， 此时将线程C也添加进CLH队列中</p><p><img src="image-20220224214444508.png" alt="image-20220224214444508"></p><p>接着执行下一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 标志异常中断情况</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <span class="hljs-comment">// 获取当前节点的prev节点</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 当前线程抢占锁成功</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果此时A线程仍然没有执行完成，线程B会继续进行抢夺，抢夺失败后执行shouldParkAfterFailedAcquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 获取前驱节点的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 等待被占用的资源释放返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 说明是CANCELLD状态</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 循环判断前驱节点的前驱节点是否也为CANCELLED状态，忽略该状态的节点，重新连接队列</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将当前节点的前驱节点设置为SIGNAL，用于后续唤醒操作</span><br>        <span class="hljs-comment">// 程序第一次执行到这里返回false，还会进行外层第二次循环</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果前驱节点的waitstatus是SINGNAL状态（-1），即该方法会返回true，程序会继续向下执行parkAndCheckInterrupt方法，用于将线程挂起。</p><p>但是此时B节点的前驱节点的waitStatus是0，因此往下走，然后将B前面的哨兵节点的waitstatus的值变成了-1，出去该方法后还会进行第二次循环，然后发现waitstatus是SINGNAL了，就返回true，进行阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说此时线程A还在办理当中，线程B和线程C在CLH队列中进行等候，到这里的时候B线程和C线程就已经被阻塞了。</p><p>当线程A办理完成的时候，会释放锁，然后status变成了0，这时候会调用unlock方法，然后执行release方法，将哨兵节点的waitstatus变成0，然后唤醒线程B，接着就会返回到parkAndCheckInterrupt方法，因为没有什么中断异常，方法返回false，继续acquireQueued方法里面的for循环里面的自旋，然后发现这次执行tryAcquire方法后抢到了锁，就让头节点指向线程B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// acquireQueued中的方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;<br>    head = node;<br>    node.thread = <span class="hljs-literal">null</span>;<br>    node.prev = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程B抢到锁之后，就让线程B变成哨兵节点</p><p><img src="image-20220224214500823.png" alt="image-20220224214500823"></p><p>原来的哨兵节点就被GC回收掉了</p><h3 id="12-4-小细节"><a href="#12-4-小细节" class="headerlink" title="12.4 小细节"></a>12.4 小细节</h3><p>AQS里面的state有三个状态，0表示没占用，1表示被占用，大于1是可重入锁</p><p>如果AB两个线程进来了以后，CLH中总共有三个Node节点，因为还包含哨兵节点。</p><h2 id="第十三章-ReentrantLock、ReentrantReadWriteLock、StampedLock讲解"><a href="#第十三章-ReentrantLock、ReentrantReadWriteLock、StampedLock讲解" class="headerlink" title="第十三章 ReentrantLock、ReentrantReadWriteLock、StampedLock讲解"></a>第十三章 ReentrantLock、ReentrantReadWriteLock、StampedLock讲解</h2><p><img src="image-20220205215707623.png" alt="image-20220205215707623"></p><p>面试题：</p><ul><li>你知道Java里面有哪些锁吗？</li><li>你说你用过读写锁，锁饥饿问题是什么</li><li>有没有比读写锁更快的锁</li><li>StampedLock知道吗</li><li>ReentrantReadWriteLock有锁降级机制策略你知道吗</li></ul><h3 id="13-1-读写锁"><a href="#13-1-读写锁" class="headerlink" title="13.1 读写锁"></a>13.1 读写锁</h3><p>并不是真正意义上的读写分离，<strong>它只允许读读共存，而读写和写写依然是互斥的</strong></p><p>大多实际场景是<strong>读读线程间并不存在互斥关系</strong>，只有读写线程或写写线程间的操作需要互斥的，因此就引入了ReentrantReadWriteLock。</p><p>一个读写锁同时只能存在一个写锁，但是可以存在多个读锁，但是不能同时存在写锁和读锁，也即<strong>一个资源可以被多个读操作访问或者一个写操作访问</strong>，<strong>但是两者不能同时进行</strong></p><p>只有在读多写少的情景下，读写锁才具有较高的性能体现。</p><p><strong>1、特点</strong></p><p>可重入、读写分离</p><p><strong>2、无锁无序 → 加锁 → 读写锁演变复习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;<br>    Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//=====ReentrantLock 等价于 =====synchronized</span><br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//=====ReentrantReadWriteLock 一体两面，读写互斥，读读共享</span><br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String key,String value)</span> &#123;<br>        rwLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---正在写入&quot;</span>);<br>            map.put(key,value);<br>            <span class="hljs-comment">//暂停毫秒</span><br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---完成写入&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            rwLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String key)</span> &#123;<br>        rwLock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---正在读取&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-comment">//后续开启注释修改为2000，演示一体两面，读写互斥，读读共享，读没有完成时候写锁无法获得</span><br>            <span class="hljs-comment">//try &#123; TimeUnit.MILLISECONDS.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;---完成读取result：&quot;</span>+result);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            rwLock.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyResource</span> <span class="hljs-variable">myResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyResource</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myResource.write(finalI +<span class="hljs-string">&quot;&quot;</span>, finalI +<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myResource.read(finalI +<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br><br>        <span class="hljs-comment">//读全部over才可以继续写</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                myResource.write(finalI +<span class="hljs-string">&quot;&quot;</span>, finalI +<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,<span class="hljs-string">&quot;newWriteThread===&quot;</span>+String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、从写锁→读锁，ReentrantReadWriteLock可以降级</strong></p><p>锁的严苛程度变强叫做升级，反之叫做降级</p><p><img src="image-20220205221301989.png" alt="image-20220205221301989"></p><p>锁降级：<strong>遵循获取写锁 → 再获取读锁 → 再释放写锁的次序，写锁能够降级成为读锁。</strong></p><p><strong>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</strong></p><p>Java8 官网说明：重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁,<br>但是，从读锁定升级到写锁是不可能的。</p><p><strong>锁降级是为了让当前线程感知到数据的变化，目的是保证数据可见性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。</span><br><span class="hljs-comment"> * 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockDownGradingDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>        ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br>        ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br><br>        writeLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;-------正在写入&quot;</span>);<br><br>        readLock.lock();<br>        System.out.println(<span class="hljs-string">&quot;-------正在读取&quot;</span>);<br><br>        writeLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略</p><p><strong>4、不可锁升级</strong></p><p>线程获取读锁是不能直接升级为写入锁的。</p><p><img src="image-20220205221840288.png" alt="image-20220205221840288"></p><p>在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会被阻塞。</p><p>所以，需要释放所有读锁，才可获取写锁，</p><p><img src="image-20220205221856490.png" alt="image-20220205221856490"></p><p><strong>5、写锁和读锁是互斥的</strong></p><p>写锁和读锁是互斥的（这里的互斥是指<strong>线程间的互斥</strong>，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁），这是因为读写锁要保持写操作的可见性。</p><p>因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。</p><p>因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：</p><p><strong>读锁全完，写锁有望；写锁独占，读写全堵；</strong></p><p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁；</p><p>即ReadWriteLock读的过程中不允许写，只有等待线程都释放了读锁，当前线程才能获取写锁，<br>也就是写入必须等待，这是一种悲观的读锁，o(╥﹏╥)o，人家还在读着那，你先别去写，省的数据乱。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<strong>后续讲解StampedLock时再详细展开</strong>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>分析StampedLock(后面详细讲解)，会发现它改进之处在于：</p><p>读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！</p><p>所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 </p><p><strong>显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</strong></p><p> <strong>6、源码总结</strong></p><p>锁降级  下面的示例代码摘自ReentrantWriteReadLock源码中：</p><p>ReentrantWriteReadLock支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。</p><p>解读在最下面:</p><p><img src="image-20220205222241508.png" alt="image-20220205222241508"></p><ol><li>代码中声明了一个volatile类型的cacheValid变量，保证其可见性。</li><li>首先获取读锁，如果cache不可用，则释放读锁，获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在释放写锁前获取读锁；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，目的是保证数据可见性。</li></ol><p><strong>如果违背锁降级的步骤</strong> ：如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。</p><p><strong>如果遵循锁降级的步骤</strong> ：线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。</p><p><strong>7、持有写锁了，再获得读锁的意义</strong></p><p>如果我们一开始使用写锁，将一个数据设为5，我们希望外面调用5这个数据，但是，多线程可能导致又一个写进程进来，将5改为88，这样，对外的数据就不是5而是88了。</p><p>也就是说，线程1写完了，我们希望大家马上拿到1.0版本，你们立刻来读取。这样就要立刻加读锁，在读的过程中，不可以让其他写线程进来修改数据。保证我们的1.0版本可以被其他线程完整读取后再进行下一次修改。</p><p><strong>写后立即可以读，感知到数据的变化</strong></p><p>实战代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">writeLock.lock();<br><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">//biz  l;ajfd;lakjsfd;lksajd;lksajf;lakjfds;</span><br>    <span class="hljs-comment">//本次写完立刻被读取。</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * 1</span><br><span class="hljs-comment">            * 2 // 进行相关业务代码</span><br><span class="hljs-comment">            * 3</span><br><span class="hljs-comment">            * 4</span><br><span class="hljs-comment">            * 5----biz end</span><br><span class="hljs-comment">            * */</span><br>    readLock.lock();<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    writeLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-2-邮戳锁"><a href="#13-2-邮戳锁" class="headerlink" title="13.2 邮戳锁"></a>13.2 邮戳锁</h3><p><strong>1、是什么</strong></p><p>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5的读写锁ReentrantReadWriteLock的优化。</p><p>也叫票据锁</p><p>stamp（戳记，long类型）：代表了锁的状态，当stamp返回零的时候，表示线程获取锁失败。并且，当释放锁或者转换锁的时候，都要传入最初获取的stamp值。</p><p><strong>2、饥饿锁问题</strong></p><p>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，<br>假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 </p><p>因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写，o(╥﹏╥)o</p><p>使用”公平“策略可以一定程度上缓解这个问题：<code>new ReentrantReadWriteLock(true)</code>，但是以牺牲系统吞吐量为代价的。</p><p><strong>这就导致了StampedLock类的乐观读锁闪亮登场；</strong></p><p><strong>ReentrantReadWriteLock</strong></p><p>允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的synchronized速度要快很多，<br>原因就是在于ReentrantReadWriteLock支持读并发</p><p><strong>StampedLock横空出世</strong></p><p>ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，所以，在获取乐观读锁后，还需要对结果进行校验。</p><p><strong>3、StampedLock的特点</strong></p><ul><li>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为零表示获取失败，其余都表示成功；</li><li>所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</li><li>StampedLock是<strong>不可重入的</strong>，危险(<strong>如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁</strong>) </li><li>三种访问模式:<ol><li>Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似</li><li>Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似</li><li>Optimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，支持读写并发，<strong>很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</strong></li></ol></li></ul><p>乐观读模式code演示：<strong>读的过程中也允许获取写锁介入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLockDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">37</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;=====写线程准备修改&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            number = number + <span class="hljs-number">13</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;=====写线程结束修改&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//悲观读</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.readLock();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t come in readlock block,4 seconds continue...&quot;</span>);<br>        <span class="hljs-comment">//暂停几秒钟线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">4</span> ; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 正在读取中......&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> number;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot; 获得成员变量值result：&quot;</span> + result);<br>            System.out.println(<span class="hljs-string">&quot;写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//乐观读</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> number;<br>        <span class="hljs-comment">//间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。</span><br>        System.out.println(<span class="hljs-string">&quot;4秒前stampedLock.validate值(true无修改，false有修改)&quot;</span>+<span class="hljs-string">&quot;\t&quot;</span>+stampedLock.validate(stamp));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">4</span> ; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t 正在读取中......&quot;</span>+i+<br>                    <span class="hljs-string">&quot;秒后stampedLock.validate值(true无修改，false有修改)&quot;</span>+<span class="hljs-string">&quot;\t&quot;</span><br>                    +stampedLock.validate(stamp));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!stampedLock.validate(stamp)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;有人动过--------存在写操作！&quot;</span>);<br>            stamp = stampedLock.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;从乐观读 升级为 悲观读&quot;</span>);<br>                result = number;<br>                System.out.println(<span class="hljs-string">&quot;重新悲观读锁通过获取到的成员变量值result：&quot;</span> + result);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp);<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t finally value: &quot;</span>+result);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StampedLockDemo</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLockDemo</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            resource.read();<br>            <span class="hljs-comment">//resource.tryOptimisticRead();</span><br>        &#125;,<span class="hljs-string">&quot;readThread&quot;</span>).start();<br><br>        <span class="hljs-comment">// 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示</span><br>        <span class="hljs-comment">//try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            resource.write();<br>        &#125;,<span class="hljs-string">&quot;writeThread&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、StampedLock的缺点</strong></p><ul><li>StampedLock 不支持重入，没有Re开头</li><li>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</li><li>使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法</li><li>如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly()</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
